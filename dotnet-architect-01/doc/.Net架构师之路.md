[TOC]

# 1.论架构师的思维转变

## 1.1 到底什么是架构师

### 输出价值

架构师就是那个能把十强完整的做出来的人，能真正输出价值的那个人



### 组织业务

优秀的架构的衡量标准是解决业务问题的能力、支撑业务增长的能力



### 组织技术

追逐技术的深度，拓展技术的宽度

跟进最新的技术，从根本上明白技术是解决什么问题的



### 组织人力

团队分工协作、部门协调沟通、需要高情商



### 组织全局、对外输出

最终，是靠架构师去规划、安排、协调，把一件事能从无到有的推动，

从需求、研发、上线、运营全过程的把握。

是真正负责一件事的人。

## 1.2 向前一步，你就是架构师

不要因为是开发人员，就不去关注软件运维，

不要因为是开发人员，就不去关注测试，

不要因为是开发人员，就不去关注运营，

关注越多，越能看清全局的价值目标。

试着转变思维，从架构师的角度思考价值问题，

看看能否将技术贯穿到业务、用户、最终的价值，

做一个真正解决问题的人。

### 发现问题

### 对待问题

### 解决问题



## 1.3 架构师的思维

### 技术的深度

 做到知其所然，知其所以然

### 技术的广度

跳出舒适区去学习新的技术

### 系统思维

不仅是解决宴请的问题，而是解决问题的根源

### 体系思维

一个人是打不赢一场战争的



# 2.CLR核心机制

## 2.1 什么是堆栈

**栈**和**堆**（托管堆）都是存在于进程的虚拟内存中，为程序运行提供存储空间。

- 栈（Stack）是操作系统在建立线程时，为这个线程建立的存储区域。

- 堆（Heap）是应用程序在运行时请求操作系统分配给自己的内存，是申请给予的过程。

  由于从操作系统管理的内存分配，分配和销毁时都占用时间，所以使用堆效率低

### 栈(Stack）

- 栈中存储值类型
- 栈是先进后出
- 栈是自维护，党员数不再被使用会被抛弃
- 栈空间较小，访问速度快

### 堆(Heap）

- 存储引用类型
- 受垃圾处理器GC管理
- 没有访问限制，按地址索引
- 控件较大，访问速度没有栈快

## 2.2 C#堆栈如何分配

- 值类型分配在栈上

- 引用类型分配在堆上

- 值类型里面的引用类型？-->引用类型一定在堆里

- 引用类型里面的值类型？-->值类型会随着对象而存在



## 2.3 引用类型new对象是发生了什么？

1. 调用new的时候 就会去栈上面开辟内存，创建实例
2. 把实例的引用传递给构造函数
3. 执行构造函数
4. 返回引用



## 2.4 IL解析



| **Nop**      | **如果修补操作码，则填充空间。尽管可能消耗处理周期，但未执行任何有意义的操作。** |
| ------------ | ------------------------------------------------------------ |
| **Ret**      | 从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。 |
| **Ldstr**    | 推送对元数据中存储的字符串的新对象引用。                     |
| **Ldloca**   | 将位于特定索引处的局部变量的地址加载到计算堆栈上。           |
| **Ldloca.S** | 将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。 |
| **Ldc.I4.S** | 将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。      |
| **Stfld**    | 用新值替换在对象引用或指针的字段中存储的值。                 |
| **Ldloc.0**  | 将索引 0 处的局部变量加载到计算堆栈上。                      |
| **Ldfld**    | 查找对象中其引用当前位于计算堆栈的字段的值。                 |
| **Ldflda**   | 查找对象中其引用当前位于计算堆栈的字段的地址。               |
| **Stloc**    | 从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。 |

```C#
    public class Student
    {
        public string Name { get; private set; }

        public int Tag;// { get; set; }

        public Student(string name)
        {
            this.Name = name;
        }
        public void Show()
        {
            int iNum = 0;
            Console.WriteLine($"This is {this.Name} {iNum} show!");
        }
    }
```



```C#
    public class StackHeapTest
    {
        ......
        private static void Show2()
        {
            Student student = new Student("晓风灿月");
            //1 先声明  晓风灿月
            //2 计算空间-开辟空间-
            //3 返回引用地址，通过地址就可以操作对象(才有this)
            //4 才是调用构造函数--构造函数只是为了初始化的
            //5 构造函数返回引用
            student.Tag = 2;
            student.Show();
        }
        ......
```

通过反编译工具[ILSpy](https://github.com/icsharpcode/ILSpy)，查看上述的**C#**代码被编译成**IL**语言如下：

```IL
	.method private hidebysig static 
		void Show2 () cil managed 
	{
		// Method begins at RVA 0x21fc
		// Code size 27 (0x1b)
		.maxstack 2
		.locals init (
			[0] class Zhaoxi.ArchitectBattalion.CLRDemo.Student student
		)

		// {
		IL_0000: nop
		// Student student = new Student("晓风灿月");
		IL_0001: ldstr "晓风灿月"
		IL_0006: newobj instance void Zhaoxi.ArchitectBattalion.CLRDemo.Student::.ctor(string)
		IL_000b: stloc.0
		// student.Tag = 2;
		IL_000c: ldloc.0
		IL_000d: ldc.i4.2
		IL_000e: stfld int32 Zhaoxi.ArchitectBattalion.CLRDemo.Student::Tag
		// student.Show();
		IL_0013: ldloc.0
		IL_0014: callvirt instance void Zhaoxi.ArchitectBattalion.CLRDemo.Student::Show()
		// }
		IL_0019: nop
		IL_001a: ret
	} // end of method StackHeapTest::Show2
```



## 2.5 装箱和拆箱

```C#
       private static void Show4()
        {
            int i = 3;
            object k = i;
            int m = (int)k;

            Console.WriteLine($"{i} {k} {m}");
        }
```

IL:

```C#
	.method private hidebysig static 
		void Show4 () cil managed 
	{
		// Method begins at RVA 0x2250
		// Code size 47 (0x2f)
		.maxstack 4
		.locals init (
			[0] int32 i,
			[1] object k,
			[2] int32 m
		)

		// {
		IL_0000: nop
		// int num = 3;
		IL_0001: ldc.i4.3
		IL_0002: stloc.0
		// object obj = num;
		IL_0003: ldloc.0
		IL_0004: box [System.Runtime]System.Int32
		IL_0009: stloc.1
		// int num2 = (int)obj;
		IL_000a: ldloc.1
		IL_000b: unbox.any [System.Runtime]System.Int32
		IL_0010: stloc.2
		// Console.WriteLine($"{num} {obj} {num2}");
		IL_0011: ldstr "{0} {1} {2}"
		IL_0016: ldloc.0
		IL_0017: box [System.Runtime]System.Int32
		IL_001c: ldloc.1
		IL_001d: ldloc.2
		IL_001e: box [System.Runtime]System.Int32
		IL_0023: call string [System.Runtime]System.String::Format(string, object, object, object)
		IL_0028: call void [System.Console]System.Console::WriteLine(string)
		// }
		IL_002d: nop
		IL_002e: ret
	} // end of method StackHeapTest::Show4
```

装箱拆箱消耗性能



## 2.6 字符串

```c#
        private static void Show5()
        {
            string student = "到下个路口";//堆里面
            string studentCopy = student;

            string people = "到下个路口";//堆里面
            Console.WriteLine(object.ReferenceEquals(student, studentCopy));
            Console.WriteLine(object.ReferenceEquals(student, people));
            //2个答案  T/F T/F        TT  C#内存分配的享元模式

            studentCopy = "love佳";
            Console.WriteLine($"{student} {people}");
            //2个答案   路口  佳佳    都是路口  字符串不可变性，不会修改只会新增

            //引用类型在堆上面---堆的空间有限---连续摆放---字符串长短--都会导致大量内存移动--而且要锁定线程---成本太高---OCP---进而就可以享元模式了--节约空间
        }
```

```C#
        private static void Show6()
        {
            string student1 = "雷电法王";
            string student2 = "雷电法王";
            string student3 = "雷电" + "法王";
            string part = "法王";
            string student31 = "雷电" + part;
            string student4 = string.Format("雷电{0}", "法王");
            StringBuilder sb = new StringBuilder();
            sb.Append("雷电");
            sb.Append("法王");
            string student5 = sb.ToString();
            string student6 = $"{"雷电"}{"法王"}";
            string student7 = $"{"雷电"}{part}";
            Console.WriteLine($"{object.ReferenceEquals(student1, student2)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student3)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student31)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student4)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student5)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student6)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student7)}");
            //6个答案   T /F     TTFFFTF
        }
```



## 2.7 垃圾回收GC

内存是有上限的，不可能无止境的分配空间，
因此就产生了GC(Garbage Collector)的需求 .

1. 提高了软件开发的抽象度；
2. 程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；
   可以使模块的接口更加的清晰，减小模块间的偶合；
3. 大大减少了内存人为管理不当所带来的Bug；
4. 使内存管理更加高效。

总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。



### 2.7.1 什么样的对象需要垃圾回收

1 托管资源
2 存在堆里(含值类型+引用类型)

**托管资源**一般是指被CLR控制的内存资源,这些资源的管理可以由CLR来控制,例如程序中分配的对象,作用域内的变量等，大部分对象都是托管资源。

**非托管资源**是CLR不能控制或者管理的部分，这些资源有很多，比如文件流，数据库的连接，系统的窗口句柄，打印机资源，需要调用Dispose方法

### 2.7.2 堆资源是怎么分配的

![image-20201119022100760](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119022100760.png)



###  2.7.3 Mark-Compact 标记压缩算法

**阶段1**: Mark-Sweep 标记清除阶段，先假设堆（heap）中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；

**阶段2:** Compact 压缩阶段，对象回收之后堆（heap）内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。

![image-20201119022153102](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119022153102.png)



### 2.7.4 Timer怪事

只有显示释放计时器，才能活到被释放的那一刻！

```C#
    public class GCTest
    {
        public static void Show()
        {
            System.Threading.Timer timer1 = new System.Threading.Timer(Timer_Elapsed_Thread, null, 0, 2000);
            //System.Timers.Timer timer = new System.Timers.Timer(1000 * 10);
            //timer.Elapsed += Timer_Elapsed;
            //timer.Start();
            Console.WriteLine("输入任意字符结束timer！");
            Console.Read();
        }
        private static void Timer_Elapsed_Thread(object sender)
        {
            Thread.Sleep(100);
            Console.WriteLine($"This is Timer_Thread Invoke....{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff")}");
            GC.Collect(0);//后面大家都研究下，为什么GC时，timer1没有被回收！ 可以在旧版本也试试---大家一起动手
        }

        private static void Timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            Thread.Sleep(100);
            Console.WriteLine($"This is Timer Invoke....{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff")}");
            GC.Collect();
        }
    }
```



### 2.7.5 三个假设

对象越新，生存期越短；
对象越老，生存期越长；
回收部分资源，快过全部回收。



### 2.7.6 分代策略

![image-20201119023836762](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119023836762.png)

第1次，遍历全部对象，找出没有引用的，删除，剩下1代
第2次，遍历0代对象，找出没有引用的，删除，剩下升级1代
             如果还不够空间，才会遍历1代，没有引用的删除，
             还在被使用的，升级为2代。都不够才会检查2代

  

**各代空间大小？**

实际上是没有具体值的，由CLR管理。
初始化时就会给出0代/1代的预算，然后动态调节！
GC后，对象几乎没有留存，那么就会减小预算，
加快回收频率，每次速度快

如果GC后有很多对象留存，那么就会增加预算，
降低回收频率，每次回收内容多

如果空间不够，就会全面回收，再不够就OutOfMemory了



### 2.7.7 什么时候GC

new对象时--临界点
Windows报告内存不够
GC.Collect 强制GC
程序退出或者卸载AppDomain



### 2.7.8 怎么用GC. Collect

大多数情况下，应该让GC自己决定回收时间，以更好的控制各代预算，也避免GC降低响应

如果知道大量对象无效，可以手动GC，尤其是2代



### 2.7.9 大对象策略

85000字节为限
独立的地址空间
不会移动压缩大对象，成本高，但也造成了碎片
大对象总是2代对象



### 2.7.10 垃圾回收模式

- 工作站：单线程回收

- 服务器：多区域并行回收



![image-20201119025151433](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119025151433.png)



# 3.O/RM 探究

## 3.1 什么是O/RM

对象-关系映射（OBJECT/RELATION MAPPING）

对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。



## 3.2 O/RM框架

![image-20201119030935104](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119030935104.png)



## 3.3 O/RM的基本功能

- CRUD的API：通用增删改查
- 自定义查询：表达式目录树
- MAPPING METADATA：自动映射实现机制
- 事务、延迟、缓存等：O/RM进阶特性实现



## 3.4 手写O/RM简易框架

### 通用查询

`SqlHelper.cs`

```c#
        public T Find<T>(int id)
        {
            Type type = typeof(T);

            string columsString = string.Join(",", type.GetProperties().Select(p => $"[{p.Name}]"));
            string sql = $"select {columsString} from [{type.Name}] where id={id}";
            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.Name]);
                    }

                    return t;
                }
            }

            return default(T);
        }
    }
```



### 配置文件管理

`ConfigurationManager.cs`

```c#
using Microsoft.Extensions.Configuration;
using System.IO;

namespace Orm.Common
{
    public class ConfigurationManager
    {
        private static string _sqlConnectionString = null;
        public static string SqlConnectionString
        {
            get
            {
                return _sqlConnectionString;
            }
        }

        static ConfigurationManager()
        {
            var builder = new ConfigurationBuilder()
                       .SetBasePath(Directory.GetCurrentDirectory())
                       .AddJsonFile("appsettings.json");

            IConfigurationRoot configuration = builder.Build();
            _sqlConnectionString = configuration["connectionString"];

        }
    }
}
```



### 用特性(Attribute)作数据库映射

#### 定义映射特性

`MappingAttribute.cs`

```c#
    public class MappingAttribute : Attribute
    {
        private string _Name = null;
        public MappingAttribute(string name)
        {
            this._Name = name;
        }

        public string GetName()
        {
            return this._Name;
        }
    }
```

`TableAttribute.cs`

```C#
    /// <summary>
    /// 做表名称的别名
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class TableAttribute : MappingAttribute
    {
        public TableAttribute(string tableName) : base(tableName)
        {

        }
    }
```



`ColumAttribute.cs`

```C#
    public class ColumnAttribute : MappingAttribute
    {
        public ColumnAttribute(string columnName) : base(columnName)
        {

        }
    }
```



`MappingExtend.cs`

```C#
    public static class MappingExtend
    {
        public static string GetTableName(this Type type)
        {
            if (type.IsDefined(typeof(TableAttribute), true))
            {
                TableAttribute attribute = type.GetCustomAttribute<TableAttribute>();
                return attribute.GetName();
            }
            else
            {
                return type.Name;
            }
        }

        public static string GetMappingName(this MemberInfo member)
        {
            if (member.IsDefined(typeof(MappingAttribute), true))
            {
                MappingAttribute attribute = member.GetCustomAttribute<MappingAttribute>();
                return attribute.GetName();
            }
            else
            {
                return member.Name;
            }
        }

        public static string GetColumnName(this PropertyInfo prop)
        {
            if (prop.IsDefined(typeof(ColumnAttribute), true))
            {
                ColumnAttribute attribute = prop.GetCustomAttribute<ColumnAttribute>();
                return attribute.GetName();
            }
            else
            {
                return prop.Name;
            }
        }
    }
```

#### 使用映射特性

`Company.cs`

```C#
    /// <summary>
    /// 数据库中表名Company  但是程序是CompanyModel
    /// </summary>
    [Table("Company")]
    public class CompanyModel : BaseEntity
    {
        [Column("Name")]
        public string CompanyName { get; set; }

        ......
    }
```



#### 改造查询语句

`SqlHelper.cs`

```C#
    public class SqlHelper
    {
        public T Find<T>(int id)  where T : BaseEntity
        {
            Type type = typeof(T);

            string columsString = string.Join(",", type.GetProperties().Select(p => $"[{p.GetColumnName()}]"));
            string sql = $"select {columsString} from [{type.GetTableName()}] where id={id}";
            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {      ......
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                   ......
            }
           ......
        }
    }
```

- `type.GetTableName()`获取映射的数据库**表名**
- `p.GetColumnName()`获取映射的数据库**列名**

### 查询部分字段

要实现如下查询：

```c#
UserDto userDto = helper.Find<User, UserDto>(1);
```

其中，`UserDto`只包含`User`类的部分字段，并且`User`中的`Name`字段对应`UserDto`中的`UserName`字段

```c#
    public class UserDto
    {
        public int id { get; set; }

        [Column("Name")]
        public string UserName { get; set; }

    }
```

`SqlHelper.cs`

```c#
        /// <summary>
        /// 查询部分字段
        /// </summary>
        /// <typeparam name="E">数据库映射Model类</typeparam>
        /// <typeparam name="D">Dto类型</typeparam>
        /// <param name="id">id</param>
        /// <returns>Dto类型</returns>
        public D Find<E,D>(int id) where E : BaseEntity
        {
            Type modleType = typeof(E);
            Type dtoType = typeof(D);

            string columsString = string.Join(",", dtoType.GetProperties().Select(p => $"[{p.GetColumnName()}]"));
            string sql = $"select {columsString} from [{modleType.GetTableName()}] where id={id}";

            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    D dto = (D)Activator.CreateInstance<D>();
                    foreach (var prop in dtoType.GetProperties())
                    {
                        prop.SetValue(dto, reader[prop.GetColumnName()]);
                    }

                    return dto;
                }
            }

            return default(D);
        }
```



### 插入

实现如下插入操作：

```C#
   CompanyModel company1 = helper.Find<CompanyModel>(1);
   helper.Insert<CompanyModel>(company1);
```

```c#
        public bool Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T);
         /*
            string columnsString = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"[{p.GetMappingName()}]"));
            string valuesString = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"@{p.GetMappingName()}"));
            var insertSql = $"INSERT INTO [{type.GetMappingName()}] ({columnsString}) VALUES({valuesString});";
         */
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectionString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                int iResult = command.ExecuteNonQuery();
                return iResult == 1;
            }
        }
```

```c#
    public static class FilterExtend
    {
        /// <summary>
        /// 过滤掉主键 返回全部属性
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static IEnumerable<PropertyInfo> GetPropertiesWithoutKey(this Type type)
        {
            return type.GetProperties().Where(p => !p.IsDefined(typeof(KeyAttribute), true));
        }
    }
```

### 更新

```c#
        public int Update<T>(T t) where T : BaseModel, new()
        {
            if (!t.Validate<T>())
            {
                throw new Exception("数据校验没有通过");//大家可以再返回点提示信息
            }

            Type type = t.GetType();
            string stringSet = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"{p.GetMappingName()}=@{p.Name}"));
            string sql = $"UPDATE [{type.GetMappingName()}] SET {stringSet} WHERE Id=@Id;";
            //string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(p => new SqlParameter($"@{p.Name}", p.GetValue(t) ?? DBNull.Value)).ToArray();

            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                return command.ExecuteNonQuery();
            }
        }

        //按需更新--界面上只修改了几个字段--大家有什么思路，可以自己动手，然后show出来
        //1 传递一个列表---实体三个属性  字段名称--操作符--值
        //2 改造成json---{"Name":"zzzz","Password":"123245"}
        public int Update<T>(string json, int id) where T : BaseModel, new()
        {
            Type type = typeof(T);
            T t = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(json);//JObject
            string stringSet = string.Join(",", type.GetPropertiesInJson(json).Select(p => $"{p.GetMappingName()}=@{p.Name}"));
            string sql = $"UPDATE {type.GetMappingName()} SET {stringSet} WHERE Id=@Id;";

            var paraArray = type.GetPropertiesInJson(json).Select(p => new SqlParameter($"@{p.Name}", p.GetValue(t) ?? DBNull.Value)).Append(new SqlParameter("@Id", id)).ToArray();
            
            //return type.GetProperties().Where(p => json.Contains($"'{p.Name}':") || json.Contains($"\"{p.Name}\":"));
            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                return command.ExecuteNonQuery();
            }
        }
```

#### 部分更新

```C#
               SqlHelper helper = new SqlHelper();
                string updateJson = Newtonsoft.Json.JsonConvert.SerializeObject(
                        new
                        {
                            CompanyName = "kkk",
                            LastModifyTime = DateTime.Now
                        }
                    ); ;
     
                helper.Update<CompanyModel>(updateJson, 5);
```



#### 数据校验

- 定义数据校验特性，抽象基类`ValidateAttribute : Attribute`：

```C#
    [AttributeUsage(AttributeTargets.Property)]
    public abstract class ValidateAttribute : Attribute
    {
        public abstract bool Validate(object oValue);
    }
```

- int类型值范围

`IntAttribute`.cs

```C#
        private int _Min = 0;
        private int _Max = 0;
        public IntAttribute(int min, int max)
        {
            this._Min = min;
            this._Max = max;
        }

        public override bool Validate(object oValue)
        {
            return oValue != null
                && oValue.ToString().Length >= this._Min
                && oValue.ToString().Length <= this._Max;
        }
    }
```

- 长度

  ```C#
      public class LengthAttribute : ValidateAttribute
      {
          private int _Min = 0;
          private int _Max = 0;
          public LengthAttribute(int min, int max)
          {
              this._Min = min;
              this._Max = max;
          }
  
          public override bool Validate(object oValue)
          {
              return oValue != null
                  && oValue.ToString().Length >= this._Min
                  && oValue.ToString().Length <= this._Max;
          }
      }
  ```

  

- 值不能为Null

  ```C#
      public class RequiredAttribute : ValidateAttribute
      {
          public override bool Validate(object oValue)
          {
              return oValue != null && !string.IsNullOrWhiteSpace(oValue.ToString());
          }
      }
  ```

 

- 数据扩展方法

  ```C#
   public static class ValidateExtend
      {
          public static bool Validate<T>(this T t)
          {
              Type type = t.GetType();
              foreach (var prop in type.GetProperties())
              {
                  if (prop.IsDefined(typeof(ValidateAttribute), true))
                  {
                      object oValue = prop.GetValue(t);
                      var attributeArray = prop.GetCustomAttributes<ValidateAttribute>();
                      foreach (var attribute in attributeArray)
                      {
                          if (attribute.Validate(oValue))
                          {
                              //继续
                          }
                          else
                          {
                              return false;
                          }
                      }
                  }
              }
              return true;
          }
      }
  ```

- 使用校验特性

  ```c#
  using Orm.Framework.SqlDataValidate;
  using Orm.Framework.SqlMapping;
  using System;
  
  namespace Orm.Model
  {
      [Table("Company")]
      public class CompanyModel : BaseEntity
      {
          [Column("Name")]
          [Required, Length(4, 14)]
          public string CompanyName { get; set; }
  
          public DateTime CreateTime { get; set; }
  
          [Int(1, 999999999)]
          public int CreatorId { get; set; }
  
          public Nullable<int> LastModifierId { get; set; }
  
          public DateTime? LastModifyTime { get; set; }
      }
  }
  ```

  

- 在插入或更新时，使用校验

```C#
        public int Update<T>(T t) where T : BaseEntity, new()
        {
            if (!t.Validate<T>())
            {
                throw new Exception("数据校验没有通过");//大家可以再返回点提示信息
            }
            ......
        }
```

- `main.cs`

  ```C#
                  SqlHelper helper = new SqlHelper();
                  CompanyModel company = helper.Find<CompanyModel>(1);
                  company.CompanyName = "";
                  helper.Update<CompanyModel>(company);
  ```

  输出：

  ```md
  "数据校验没有通过"
  ```

  

###  删除

```c#
        public bool Delete<T>(T t) where T : BaseModel, new()
        {
            Type type = t.GetType();
            string sql = $"DELETE FROM [{type.GetMappingName()}] WHERE Id=@Id;";
            var paraArray = new SqlParameter[] { new SqlParameter("@Id", t.Id) };

            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                //var trans = conn.BeginTransaction();
                //trans.Commit();
                //trans.Rollback();
                return 1 == command.ExecuteNonQuery();
            }
        }
```



### 条件查询

实现如下查询：

```c#
     SqlHelper helper = new SqlHelper();
     var companys = helper.FindCondition<CompanyModel>(c => c.Id > 10);
```

使用表达式树解析出`sql`的中`where`语句，做法如下：

```C#
        public IList<T> FindCondition<T>(Expression<Func<T, bool>> func) where T : BaseEntity, new()
        {
            Type type = typeof(T);
            string columnsString = string.Join(",", type.GetProperties().Select(p => $"[{p.GetMappingName()}]"));
            string where = func.ToWhere<T>(out List<SqlParameter> parameters);
            string sql = $"SELECT {columnsString} FROM [{type.GetMappingName()}] WHERE {where}";
            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connString}");
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(parameters.ToArray());
                conn.Open();
                var reader = command.ExecuteReader();
                IList<T> result = new List<T>();
                while (reader.Read())
                {
                    T t = new T();
                    foreach (var prop in type.GetProperties())
                    {
                        string propName = prop.GetMappingName();
                        prop.SetValue(t, reader[propName] is DBNull ? null : reader[propName]);
                    }
                    result.Add(t);
                }
                return result;
            }
        }
```

其中，关键语句如下，

```C#
 string where = func.ToWhere<T>(out List<SqlParameter> parameters);
```

将`Larmda`表达式解析为`wher`语句并获取参数列表



`ExpressionHelper.cs`

```c
    public static class ExpressionHelper
    {
        public static string ToWhere<T>(this Expression<Func<T, bool>> expression, out List<SqlParameter> sqlParameters)
        {
            CustomExpressionVisitor visitor = new CustomExpressionVisitor();
            visitor.Visit(expression);
            string where = visitor.GetWhere(out sqlParameters);
            return where;
        }
    }
```

`CustomExpressionVisitor.cs`

```c#
public class CustomExpressionVisitor : ExpressionVisitor
    {
        private Stack<string> ConditionStack = new Stack<string>();
        //id>10    id>@Id    sqlparameter(@id,10)
        private List<SqlParameter> _SqlParameterList = new List<SqlParameter>();
        private object _TempValue = null;


        public string GetWhere(out List<SqlParameter> sqlParameters)
        {
            string where = string.Concat(this.ConditionStack.ToArray());
            this.ConditionStack.Clear();
            sqlParameters = _SqlParameterList;
            return where;
        }


        public override Expression Visit(Expression node)
        {
            Console.WriteLine($"Visit入口：{node.NodeType} {node.Type} {node.ToString()}");
            return base.Visit(node);
        }

        protected override Expression VisitBinary(BinaryExpression node)
        {
            Console.WriteLine($"VisitBinary：{node.NodeType} {node.Type} {node.ToString()}");
            this.ConditionStack.Push(" ) ");
            base.Visit(node.Right);
            this.ConditionStack.Push(node.NodeType.ToSqlOperator());
            base.Visit(node.Left);
            this.ConditionStack.Push(" ( ");
            return node;
        }

        protected override Expression VisitConstant(ConstantExpression node)
        {
            Console.WriteLine($"VisitConstant：{node.NodeType} {node.Type} {node.ToString()}");
            //this.ConditionStack.Push($"'{node.Value.ToString()}'");
            this._TempValue = node.Value;
            //栈里面不要值，要的是@PropertyName,但是从后往前，先有值再有属性--但是二者是连续的
            return node;
        }

        protected override Expression VisitMember(MemberExpression node)
        {
            Console.WriteLine($"VisitMember：{node.NodeType} {node.Type} {node.ToString()}");
            //this.ConditionStack.Push($"{node.Member.GetMappingName()}");
            if (node.Expression is ConstantExpression)
            {
                var value1 = this.InvokeValue(node);
                var value2 = this.ReflectionValue(node);
                //this.ConditionStack.Push($"'{value1}'");
                this._TempValue = value1;
            }
            else
            {
                //this.ConditionStack.Push($"{node.Member.Name}");
                //this.ConditionStack.Push($"{node.Member.GetMappingName()}");//映射数据
                if (this._TempValue != null)
                {
                    string name = node.Member.GetMappingName();
                    string paraName = $"@{name}{this._SqlParameterList.Count}";
                    string sOperator = this.ConditionStack.Pop();
                    this.ConditionStack.Push(paraName);
                    this.ConditionStack.Push(sOperator);
                    this.ConditionStack.Push(name);

                    var tempValue = this._TempValue;
                    this._SqlParameterList.Add(new SqlParameter(paraName, tempValue));
                    this._TempValue = null;
                }
            }
            return node;
        }

        private object InvokeValue(MemberExpression member)
        {
            var objExp = Expression.Convert(member, typeof(object));//struct需要
            return Expression.Lambda<Func<object>>(objExp).Compile().Invoke();
        }

        private object ReflectionValue(MemberExpression member)
        {
            var obj = (member.Expression as ConstantExpression).Value;
            return (member.Member as FieldInfo).GetValue(obj);
        }

        protected override Expression VisitMethodCall(MethodCallExpression m)
        {
            if (m == null) throw new ArgumentNullException("MethodCallExpression");

            this.Visit(m.Arguments[0]);
            string format;
            switch (m.Method.Name)
            {
                case "StartsWith":
                    format = "({0} LIKE {1}+'%')";
                    break;

                case "Contains":
                    format = "({0} LIKE '%'+{1}+'%')";
                    break;

                case "EndsWith":
                    format = "({0} LIKE '%'+{1})";
                    break;

                default:
                    throw new NotSupportedException(m.NodeType + " is not supported!");
            }
            this.ConditionStack.Push(format);
            this.Visit(m.Object);
            string left = this.ConditionStack.Pop();
            format = this.ConditionStack.Pop();
            string right = this.ConditionStack.Pop();
            this.ConditionStack.Push(String.Format(format, left, right));

            return m;
        }
    }
```

#### 表达式树

[表达式树 (C#)](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/)

[修改表达式树](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-modify-expression-trees)

[如何使用表达式树来生成动态查询 (C#)](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-use-expression-trees-to-build-dynamic-queries)

https://www.cnblogs.com/wolf-sun/p/4234747.html#t1

https://www.cnblogs.com/snailblog/p/11521043.html

#### ExpressionVisitor抽象类源码

此类继承自`ExpressionVisitor`类，此类是`expression`表达式的工具类，可对`expression`表达式内部的成员进行替换

[修改表达式树](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-modify-expression-trees)

```C#

//http://blogs.msdn.com/b/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx
public abstract class ExpressionVisitor
    {
        protected virtual Expression Visit(Expression exp)
        {
            if (exp == null)
                return exp;
            switch (exp.NodeType)
            {
                case ExpressionType.Negate:
                case ExpressionType.NegateChecked:
                case ExpressionType.Not:
                case ExpressionType.Convert:
                case ExpressionType.ConvertChecked:
                case ExpressionType.ArrayLength:
                case ExpressionType.Quote:
                case ExpressionType.TypeAs:
                    return this.VisitUnary((UnaryExpression)exp);
                case ExpressionType.Add:
                case ExpressionType.AddChecked:
                case ExpressionType.Subtract:
                case ExpressionType.SubtractChecked:
                case ExpressionType.Multiply:
                case ExpressionType.MultiplyChecked:
                case ExpressionType.Divide:
                case ExpressionType.Modulo:
                case ExpressionType.And:
                case ExpressionType.AndAlso:
                case ExpressionType.Or:
                case ExpressionType.OrElse:
                case ExpressionType.LessThan:
                case ExpressionType.LessThanOrEqual:
                case ExpressionType.GreaterThan:
                case ExpressionType.GreaterThanOrEqual:
                case ExpressionType.Equal:
                case ExpressionType.NotEqual:
                case ExpressionType.Coalesce:
                case ExpressionType.ArrayIndex:
                case ExpressionType.RightShift:
                case ExpressionType.LeftShift:
                case ExpressionType.ExclusiveOr:
                    return this.VisitBinary((BinaryExpression)exp);
                case ExpressionType.TypeIs:
                    return this.VisitTypeIs((TypeBinaryExpression)exp);
                case ExpressionType.Conditional:
                    return this.VisitConditional((ConditionalExpression)exp);
                case ExpressionType.Constant:
                    return this.VisitConstant((ConstantExpression)exp);
                case ExpressionType.Parameter:
                    return this.VisitParameter((ParameterExpression)exp);
                case ExpressionType.MemberAccess:
                    return this.VisitMemberAccess((MemberExpression)exp);
                case ExpressionType.Call:
                    return this.VisitMethodCall((MethodCallExpression)exp);
                case ExpressionType.Lambda:
                    return this.VisitLambda((LambdaExpression)exp);
                case ExpressionType.New:
                    return this.VisitNew((NewExpression)exp);
                case ExpressionType.NewArrayInit:
                case ExpressionType.NewArrayBounds:
                    return this.VisitNewArray((NewArrayExpression)exp);
                case ExpressionType.Invoke:
                    return this.VisitInvocation((InvocationExpression)exp);
                case ExpressionType.MemberInit:
                    return this.VisitMemberInit((MemberInitExpression)exp);
                case ExpressionType.ListInit:
                    return this.VisitListInit((ListInitExpression)exp);
                default:
                    throw new Exception(string.Format("Unhandled expression type: '{0}'", exp.NodeType));
            }
        }

        protected virtual MemberBinding VisitBinding(MemberBinding binding)
        {
            switch (binding.BindingType)
            {
                case MemberBindingType.Assignment:
                    return this.VisitMemberAssignment((MemberAssignment)binding);
                case MemberBindingType.MemberBinding:
                    return this.VisitMemberMemberBinding((MemberMemberBinding)binding);
                case MemberBindingType.ListBinding:
                    return this.VisitMemberListBinding((MemberListBinding)binding);
                default:
                    throw new Exception(string.Format("Unhandled binding type '{0}'", binding.BindingType));
            }
        }

        protected virtual ElementInit VisitElementInitializer(ElementInit initializer)
        {
            ReadOnlyCollection<Expression> arguments = this.VisitExpressionList(initializer.Arguments);
            if (arguments != initializer.Arguments)
            {
                return Expression.ElementInit(initializer.AddMethod, arguments);
            }
            return initializer;
        }

        protected virtual Expression VisitUnary(UnaryExpression u)
        {
            Expression operand = this.Visit(u.Operand);
            if (operand != u.Operand)
            {
                return Expression.MakeUnary(u.NodeType, operand, u.Type, u.Method);
            }
            return u;
        }

        protected virtual Expression VisitBinary(BinaryExpression b)
        {
            Expression left = this.Visit(b.Left);
            Expression right = this.Visit(b.Right);
            Expression conversion = this.Visit(b.Conversion);
            if (left != b.Left || right != b.Right || conversion != b.Conversion)
            {
                if (b.NodeType == ExpressionType.Coalesce && b.Conversion != null)
                    return Expression.Coalesce(left, right, conversion as LambdaExpression);
                else
                    return Expression.MakeBinary(b.NodeType, left, right, b.IsLiftedToNull, b.Method);
            }
            return b;
        }

        protected virtual Expression VisitTypeIs(TypeBinaryExpression b)
        {
            Expression expr = this.Visit(b.Expression);
            if (expr != b.Expression)
            {
                return Expression.TypeIs(expr, b.TypeOperand);
            }
            return b;
        }

        protected virtual Expression VisitConstant(ConstantExpression c)
        {
            return c;
        }

        protected virtual Expression VisitConditional(ConditionalExpression c)
        {
            Expression test = this.Visit(c.Test);
            Expression ifTrue = this.Visit(c.IfTrue);
            Expression ifFalse = this.Visit(c.IfFalse);
            if (test != c.Test || ifTrue != c.IfTrue || ifFalse != c.IfFalse)
            {
                return Expression.Condition(test, ifTrue, ifFalse);
            }
            return c;
        }

        protected virtual Expression VisitParameter(ParameterExpression p)
        {
            return p;
        }

        protected virtual Expression VisitMemberAccess(MemberExpression m)
        {
            Expression exp = this.Visit(m.Expression);
            if (exp != m.Expression)
            {
                return Expression.MakeMemberAccess(exp, m.Member);
            }
            return m;
        }

        protected virtual Expression VisitMethodCall(MethodCallExpression m)
        {
            Expression obj = this.Visit(m.Object);
            IEnumerable<Expression> args = this.VisitExpressionList(m.Arguments);
            if (obj != m.Object || args != m.Arguments)
            {
                return Expression.Call(obj, m.Method, args);
            }
            return m;
        }

        protected virtual ReadOnlyCollection<Expression> VisitExpressionList(ReadOnlyCollection<Expression> original)
        {
            List<Expression> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                Expression p = this.Visit(original[i]);
                if (list != null)
                {
                    list.Add(p);
                }
                else if (p != original[i])
                {
                    list = new List<Expression>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(p);
                }
            }
            if (list != null)
            {
                return list.AsReadOnly();
            }
            return original;
        }

        protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
        {
            Expression e = this.Visit(assignment.Expression);
            if (e != assignment.Expression)
            {
                return Expression.Bind(assignment.Member, e);
            }
            return assignment;
        }

        protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
        {
            IEnumerable<MemberBinding> bindings = this.VisitBindingList(binding.Bindings);
            if (bindings != binding.Bindings)
            {
                return Expression.MemberBind(binding.Member, bindings);
            }
            return binding;
        }

        protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding)
        {
            IEnumerable<ElementInit> initializers = this.VisitElementInitializerList(binding.Initializers);
            if (initializers != binding.Initializers)
            {
                return Expression.ListBind(binding.Member, initializers);
            }
            return binding;
        }

        protected virtual IEnumerable<MemberBinding> VisitBindingList(ReadOnlyCollection<MemberBinding> original)
        {
            List<MemberBinding> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                MemberBinding b = this.VisitBinding(original[i]);
                if (list != null)
                {
                    list.Add(b);
                }
                else if (b != original[i])
                {
                    list = new List<MemberBinding>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(b);
                }
            }
            if (list != null)
                return list;
            return original;
        }

        protected virtual IEnumerable<ElementInit> VisitElementInitializerList(ReadOnlyCollection<ElementInit> original)
        {
            List<ElementInit> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                ElementInit init = this.VisitElementInitializer(original[i]);
                if (list != null)
                {
                    list.Add(init);
                }
                else if (init != original[i])
                {
                    list = new List<ElementInit>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(init);
                }
            }
            if (list != null)
                return list;
            return original;
        }

        protected virtual Expression VisitLambda(LambdaExpression lambda)
        {
            Expression body = this.Visit(lambda.Body);
            if (body != lambda.Body)
            {
                return Expression.Lambda(lambda.Type, body, lambda.Parameters);
            }
            return lambda;
        }

        protected virtual NewExpression VisitNew(NewExpression nex)
        {
            IEnumerable<Expression> args = this.VisitExpressionList(nex.Arguments);
            if (args != nex.Arguments)
            {
                if (nex.Members != null)
                    return Expression.New(nex.Constructor, args, nex.Members);
                else
                    return Expression.New(nex.Constructor, args);
            }
            return nex;
        }

        protected virtual Expression VisitMemberInit(MemberInitExpression init)
        {
            NewExpression n = this.VisitNew(init.NewExpression);
            IEnumerable<MemberBinding> bindings = this.VisitBindingList(init.Bindings);
            if (n != init.NewExpression || bindings != init.Bindings)
            {
                return Expression.MemberInit(n, bindings);
            }
            return init;
        }

        protected virtual Expression VisitListInit(ListInitExpression init)
        {
            NewExpression n = this.VisitNew(init.NewExpression);
            IEnumerable<ElementInit> initializers = this.VisitElementInitializerList(init.Initializers);
            if (n != init.NewExpression || initializers != init.Initializers)
            {
                return Expression.ListInit(n, initializers);
            }
            return init;
        }

        protected virtual Expression VisitNewArray(NewArrayExpression na)
        {
            IEnumerable<Expression> exprs = this.VisitExpressionList(na.Expressions);
            if (exprs != na.Expressions)
            {
                if (na.NodeType == ExpressionType.NewArrayInit)
                {
                    return Expression.NewArrayInit(na.Type.GetElementType(), exprs);
                }
                else
                {
                    return Expression.NewArrayBounds(na.Type.GetElementType(), exprs);
                }
            }
            return na;
        }

        protected virtual Expression VisitInvocation(InvocationExpression iv)
        {
            IEnumerable<Expression> args = this.VisitExpressionList(iv.Arguments);
            Expression expr = this.Visit(iv.Expression);
            if (args != iv.Arguments || expr != iv.Expression)
            {
                return Expression.Invoke(expr, args);
            }
            return iv;
        }
    }
```





## 3.6 数据库事务

### 3.6.1 ACID

**A**  原子性--要么都成功 要么 都是失败，不会出现中间情况
		
**C**  一致性--数据在执行前后得满足一致性状态，数据得都是有效合法
	
**I**   隔离性--多个事务直接是互不影响的，看不到中间状态
		
**D**  持久性--只要成功了，就一定会固化下来



### 3.6.2 事务实现

- `SqlHelperDelay.cs`

```c#
    /// <summary>
    /// 实现延迟提交，模拟DbConte
    /// </summary>
    public class SqlHelperDelay : IDisposable
    {
        private IList<SqlCommand> _sqlCommandLIist = new List<SqlCommand>();
        
        public void Insert<T>(T entity) where T : BaseEntity
        {
            Type type = typeof(T);
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ).ToArray();

            SqlCommand command = new SqlCommand(sql);
            command.Parameters.AddRange(paraArray);

            _sqlCommandLIist.Add(command);
        }
        
        public void SaveChange()
        {
            string connectString = GetConnectionString(SqlConnectionType.Write);

            if (_sqlCommandLIist.Any())
            {
                using (SqlConnection conn = new SqlConnection(connectString))
                {
                    conn.Open();

                    using (SqlTransaction trans = conn.BeginTransaction())
                    {
                        try
                        {
                            foreach (var command in _sqlCommandLIist)
                            {
                                command.Connection = conn;
                                command.Transaction = trans;
                                command.ExecuteNonQuery();
                            }

                            trans.Commit();
                        }
                        catch (Exception)
                        {
                            trans.Rollback();
                            throw;
                        }
                        finally
                        {
                            _sqlCommandLIist.Clear();
                        }
                    }
                }
            }
        }
        
        public void Dispose()
        {
            _sqlCommandLIist.Clear();
        }
    }
```



1. 使用`private IList<SqlCommand> _sqlCommandLIist = new List<SqlCommand>();`存储的所有command`;

2. 然后在`SaveChange()`中使用同一个连接`conn`的同一个事务里面统一提交;

   

- 测试用例：

```c#
        [TestMethod]
        public void TestSaveChange_Transations_Exception()
        {
            try
            {
                using (SqlHelperDelay sqlHelperDelay = new SqlHelperDelay())
                {
                    var company1 = sqlHelperDelay.Find<CompanyModel>(1);
                    var company2 = sqlHelperDelay.Find<CompanyModel>(2);
                    
                    //字符串超过数据库字段长度，抛出异常
                    company2.CompanyName += "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);";

                    sqlHelperDelay.Insert(company1);
                    sqlHelperDelay.Insert(company2);
                    sqlHelperDelay.SaveChange();
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

        }
```

- 局限性

  该示例的局限性是只能在同一个`SqlHelperDelay`实例对象（同一个连接）中才能确保事务的统一性



## 3.7 Uow（工作单元）

**3.6.2 事务实现**中的示例的局限性是只能在同一个`SqlHelperDelay`实例对象中（多个连接）才能确保事务，

如果要实现**多个实例的事务**，就要使用Uow实现



### 3.7.1 单数据库多个数据库连接对象事务

如下示例，使用**Uow** 实现了，**单数据库多个数据库连接对象（connection）**的事务

- `IUnitOfWork`

  ```C#
      public interface IUnitOfWork : IDisposable
      {
          void Invoke(Action action);
      }
  ```

  

- `UnitOfWork`

  ```C#
          /// <summary>
          /// 提供事务
          /// </summary>
          /// <param name="action">多个数据操作</param>
          public void Invoke(Action action)
          {
              using(var trans = new TransactionScope())
              {
                  action.Invoke();
                  trans.Complete();
              }
  
          }
  
          public void Dispose()
          {
          }
  ```

  

- 测试用例

  ```c#
          [TestMethod]
          public void TestUnitOfWork_Exception()
          {
              using (var uow = new UnitOfWork())
              {
                  SqlHelper sqlHelper = new SqlHelper();
                  var company1 = sqlHelper.Find<CompanyModel>(1);
                  var company2 = sqlHelper.Find<CompanyModel>(2);
  
                  uow.Invoke(() => {
                      sqlHelper.Insert(company1);
                      sqlHelper.Insert(company2);
                      throw new Exception("Exception in Uow!!!");
                  });
              }
          }
  
          [TestMethod]
          public void TestUnitOfWork_Ok()
          {
              using (var uow = new UnitOfWork())
              {
                  SqlHelper sqlHelper = new SqlHelper();
                  var company1 = sqlHelper.Find<CompanyModel>(1);
                  var company2 = sqlHelper.Find<CompanyModel>(2);
  
                  uow.Invoke(() => {
                      sqlHelper.Insert(company1);
                      sqlHelper.Insert(company2);
                  });
              }
          }
  ```

  

## 3.8 分布式事务：多数据库事务

### 3.8.1 MSDTC

为了实现该示例，需要从数据`Architect_Customers`复制出一个新的数据库`Architect_Customers_Other`

在配置文件中新增新的数据库连接`Other`：

```json
{
  "ConnectionStrings": {
    "Write": "...",
    "Read": [ ...
    ],
    "Other": "Data Source=.; Database=Architect_Customers_Other; User ID=sa; Password=123456; MultipleActiveResultSets=True"
  }
}

```

新建一个对应新数据库的查询帮助类`SqlHelperOther `,与`SqlHelper`一样，只是替换了连接字符串的获取方法`GetOtherDbConnectionString()`

```c#
 public class SqlHelperOther
    {
        public T Find<T>(int id) where T : BaseEntity
        {
            Type type = typeof(T);

            string sql = $"{SqlBuilder<T>.GetFindSql()}{id}";
            string connectString = GetOtherDbConnectionString(SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connectString}");
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                    }

                    return t;
                }
            }

            return default(T);
        }


        public int Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T);

            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            string connectString = GetOtherDbConnectionString(SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                object id = command.ExecuteScalar();
                return Convert.ToInt32(id);
            }
        }

```



执行如下可是代码：

```C#
            using (var uow = new UnitOfWork())
            {
                SqlHelper sqlHelper = new SqlHelper();
                var company1 = sqlHelper.Find<CompanyModel>(1);
                company1.CompanyName += "多数据事务";

                SqlHelperOther sqlHelperOther = new SqlHelperOther();
                var company2 = sqlHelperOther.Find<CompanyModel>(1);
                company2.CompanyName += "多数据事务";

                uow.Invoke(() => {
                    sqlHelper.Insert(company1);
                    sqlHelperOther.Insert(company2);
                });
            }
```



```md
System.Data.SqlClient.SqlException:“服务器 'DESKTOP-LDDT7JH' 上的 MSDTC 不可用。”
```

要解决该问题，需要打开windows系统的**DTC**（Distributed Transaction Coordinator）服务，将其设置为**启动**

> MSDTC:
>
> 协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。



启动`MS DTC`服务后，还是会抛出异常：

```md
System.PlatformNotSupportedException:“This platform does not support distributed transactions.”
```

这是在**`.net core 2.1`后就不支持`MSDTC`**了

**同样的代码，`.net framework`中，MSDTC确实可以保证多个数据库间完成事务操作**

#### 3.8.1.1 拓展：局域网MSDTC配置

![image-20201123172107878](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172107878.png)

![image-20201123172136720](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172136720.png)



### 3.8.3 CAP

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172544672.png" alt="image-20201123172544672" style="zoom:80%;" />



P:是一定会发生的，

CAP定理：CAP是不可能同时满足的

目前的分布式往AP方向走 ，C(一致性)延缓，最终一致性



### 3.8.4 DTC-2PC

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123175936640.png" alt="image-20201123175936640" style="zoom:80%;" />



**DTC-2PC** 追求可用性，放弃了可用性



### 3.8.5 数据库事务解决

- .Net Core目前暂未提供简单易用的2PC分布式事务

- Try Confirm Cancel
- 本地消息表



## 3.9 条件查询





# 4. 读写分离



读写分离，主库做增删改，从库只读。

大部分的数据库压力，都是由查询引起的，读写分离可以减轻数据库的压力。

1、在(主)数据库上对需要同步的数据进行发布（创建发布服务）。

2、在(从)数据库上对(主)数据库的发布进行订阅。

![image-20201119193930302](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119193930302.png)



**注意事项**

- 查询服务器的名称和实际计算机的名称，如果两者不一致，就需要修改。

     ```sql
use master
 go
 select @@servername;
 select serverproperty('servername')
     ```



- 将"服务器名", 修改为正确的计算机名

  ```sql
  EXEC sp_dropserver 'aaaaa';      -- 原服务器名
  GO
  EXEC sp_addserver 'aaaaa', 'local'; -- 新服务器名
  ```



**参考**

https://blog.csdn.net/qq_32343577/article/details/82423393



## 4.1 设置发布服务器

- 在设置发布服务器前，先确保服务【SQL Server代理（MSSQL SEVER）】是启动，并且启动模式必须是“自动”

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081423600.png" alt="image-20201122081423600" style="zoom:33%;" />

- 打开【SqlSever管理器】

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122075520349.png" alt="image-20201122075520349" style="zoom:40%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122075538469.png" alt="image-20201122075538469" style="zoom:50%;" />

​    

  实测中直接使用物理路径`E:\ProgramData\SqlServerDatas\snapshot`

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080642440.png" alt="image-20201122080642440" style="zoom:50%;" />





<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080815062.png" alt="image-20201122080815062" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080855479.png" alt="image-20201122080855479" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080945839.png" alt="image-20201122080945839" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081147364.png" alt="image-20201122081147364" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081229813.png" alt="image-20201122081229813" style="zoom:50%;" />

生成的脚本的`ConfigureDistribution-server.sql`：

```sql
/****** 正在编写复制配置的脚本。脚本日期: 2020/11/22 8:12:19 ******/
/****** 请注意: 出于安全原因，所有密码参数均使用 NULL 或空字符串代替。******/

/****** 正在将服务器作为分发服务器安装。脚本日期: 2020/11/22 8:12:19 ******/
use master
exec sp_adddistributor @distributor = N'DESKTOP-LDDT7JH', @password = N''
GO
exec sp_adddistributiondb @database = N'distribution-server', @data_folder = N'E:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\Data', @log_folder = N'E:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\Data', @log_file_size = 2, @min_distretention = 0, @max_distretention = 72, @history_retention = 48, @security_mode = 1
GO

use [distribution-server] 
if (not exists (select * from sysobjects where name = 'UIProperties' and type = 'U ')) 
	create table UIProperties(id int) 
if (exists (select * from ::fn_listextendedproperty('SnapshotFolder', 'user', 'dbo', 'table', 'UIProperties', null, null))) 
	EXEC sp_updateextendedproperty N'SnapshotFolder', N'\\DESKTOP-LDDT7JH\snapshot', 'user', dbo, 'table', 'UIProperties' 
else 
	EXEC sp_addextendedproperty N'SnapshotFolder', N'\\DESKTOP-LDDT7JH\snapshot', 'user', dbo, 'table', 'UIProperties'
GO

exec sp_adddistpublisher @publisher = N'DESKTOP-LDDT7JH', @distribution_db = N'distribution-server', @security_mode = 0, @login = N'sa', @password = N'', @working_directory = N'\\DESKTOP-LDDT7JH\snapshot', @trusted = N'false', @thirdparty_flag = 0, @publisher_type = N'MSSQLSERVER'
GO

```



## 4.2 设置发布

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082141699.png" alt="image-20201122082141699" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082216245.png" alt="image-20201122082216245" style="zoom:50%;" />

选择“事件发布”

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082257246.png" alt="image-20201122082257246" style="zoom:50%;" />

1. 快照复制：变化频率低，变化数据大
2. 事务复制：同步效率高，变化频繁，每个步骤都包含
3. 合并复制：通常用于服务器到客户端的环境中，会冲突



选择要发布的表，如果实际过程中有新增表，得重新设置

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082435803.png" alt="image-20201122082435803" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082537091.png" alt="image-20201122082537091" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082630428.png" alt="image-20201122082630428" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082816786.png" alt="image-20201122082816786" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082846659.png" alt="image-20201122082846659" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083024014.png" alt="image-20201122083024014" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083037511.png" alt="image-20201122083037511" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083244203.png" alt="image-20201122083244203" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083319892.png" alt="image-20201122083319892" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083614013.png" alt="image-20201122083614013" style="zoom:50%;" />



生成的脚本`CreatePublication.sql`：

```sql
use [Architect_Customers]
exec sp_replicationdboption @dbname = N'Architect_Customers', @optname = N'publish', @value = N'true'
GO
-- 添加事务发布
use [Architect_Customers]
exec sp_addpublication @publication = N'Architect_Customers', @description = N'来自发布服务器“DESKTOP-LDDT7JH”的数据库“Architect_Customers”的事务发布。', @sync_method = N'concurrent', @retention = 0, @allow_push = N'true', @allow_pull = N'true', @allow_anonymous = N'true', @enabled_for_internet = N'false', @snapshot_in_defaultfolder = N'true', @compress_snapshot = N'false', @ftp_port = 21, @ftp_login = N'anonymous', @allow_subscription_copy = N'false', @add_to_active_directory = N'false', @repl_freq = N'continuous', @status = N'active', @independent_agent = N'true', @immediate_sync = N'true', @allow_sync_tran = N'false', @autogen_sync_procs = N'false', @allow_queued_tran = N'false', @allow_dts = N'false', @replicate_ddl = 1, @allow_initialize_from_backup = N'false', @enabled_for_p2p = N'false', @enabled_for_het_sub = N'false'
GO

exec sp_addpublication_snapshot @publication = N'Architect_Customers', @frequency_type = 1, @frequency_interval = 0, @frequency_relative_interval = 0, @frequency_recurrence_factor = 0, @frequency_subday = 0, @frequency_subday_interval = 0, @active_start_time_of_day = 0, @active_end_time_of_day = 235959, @active_start_date = 0, @active_end_date = 0, @job_login = null, @job_password = null, @publisher_security_mode = 0, @publisher_login = N'sa', @publisher_password = N''

use [Architect_Customers]
exec sp_addarticle @publication = N'Architect_Customers', @article = N'Company', @source_owner = N'dbo', @source_object = N'Company', @type = N'logbased', @description = null, @creation_script = null, @pre_creation_cmd = N'drop', @schema_option = 0x000000000803509F, @identityrangemanagementoption = N'manual', @destination_table = N'Company', @destination_owner = N'dbo', @vertical_partition = N'false', @ins_cmd = N'CALL sp_MSins_dboCompany', @del_cmd = N'CALL sp_MSdel_dboCompany', @upd_cmd = N'SCALL sp_MSupd_dboCompany'
GO

use [Architect_Customers]
exec sp_addarticle @publication = N'Architect_Customers', @article = N'User', @source_owner = N'dbo', @source_object = N'User', @type = N'logbased', @description = null, @creation_script = null, @pre_creation_cmd = N'drop', @schema_option = 0x000000000803509F, @identityrangemanagementoption = N'manual', @destination_table = N'User', @destination_owner = N'dbo', @vertical_partition = N'false', @ins_cmd = N'CALL sp_MSins_dboUser', @del_cmd = N'CALL sp_MSdel_dboUser', @upd_cmd = N'SCALL sp_MSupd_dboUser'
GO

```

## 4.3 设置订阅

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083855378.png" alt="image-20201122083855378" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084015688.png" alt="image-20201122084015688" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084034540.png" alt="image-20201122084034540" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084140790.png" alt="image-20201122084140790" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084250306.png" alt="image-20201122084250306" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084308266.png" alt="image-20201122084308266" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084445213.png" alt="image-20201122084445213" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084502836.png" alt="image-20201122084502836" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084521236.png" alt="image-20201122084521236" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084549029.png" alt="image-20201122084549029" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084604953.png" alt="image-20201122084604953" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084633245.png" alt="image-20201122084633245" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084642516.png" alt="image-20201122084642516" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084658900.png" alt="image-20201122084658900" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084825532.png" alt="image-20201122084825532" style="zoom:50%;" />

生成的订阅脚本`NewSubscription.sql`:

```sql
-----------------开始: 要在发布服务器“DESKTOP-LDDT7JH”上运行的脚本-----------------
use [Architect_Customers]
exec sp_addsubscription @publication = N'Architect_Customers', @subscriber = N'DESKTOP-LDDT7JH', @destination_db = N'Architect_Customers_01', @subscription_type = N'Push', @sync_type = N'automatic', @article = N'all', @update_mode = N'read only', @subscriber_type = 0
exec sp_addpushsubscription_agent @publication = N'Architect_Customers', @subscriber = N'DESKTOP-LDDT7JH', @subscriber_db = N'Architect_Customers_01', @job_login = null, @job_password = null, @subscriber_security_mode = 0, @subscriber_login = N'sa', @subscriber_password = null, @frequency_type = 64, @frequency_interval = 0, @frequency_relative_interval = 0, @frequency_recurrence_factor = 0, @frequency_subday = 0, @frequency_subday_interval = 0, @active_start_time_of_day = 0, @active_end_time_of_day = 235959, @active_start_date = 20201122, @active_end_date = 99991231, @enabled_for_syncmgr = N'False', @dts_package_location = N'Distributor'
GO
-----------------结束: 要在发布服务器“DESKTOP-LDDT7JH”上运行的脚本-----------------
```

重复上述步骤，再创建一个从库`Architect_Customers_02`



## 4.4 验证是否同步

修改主库`Architect_Customers`都某个字段，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122095423352.png" alt="image-20201122095423352" style="zoom:50%;" />



## 4.5 应用程序读写分离

### 修改获取配置连接字符串的方式

`appsettings.json`

```json
{
  "ConnectionStrings": {
    "Write": "Data Source=.; Database=Architect_Customers; User ID=sa; Password=123456; MultipleActiveResultSets=True",
    "Read": [
      "Data Source=.; Database=Architect_Customers_01; User ID=sa; Password=123456; MultipleActiveResultSets=True",
      "Data Source=.; Database=Architect_Customers_02; User ID=sa; Password=123456; MultipleActiveResultSets=True",
      "Data Source=.; Database=Architect_Customers_03; User ID=sa; Password=123456; MultipleActiveResultSets=True"
    ]
  }
}
```

`SqlConnectionPool.cs`

```c#
public class SqlConnectionPool
    {
        public static string GetConnectionString(SqlConnectionType sqlConnectionType)
        {
            string conn = null;
            switch (sqlConnectionType)
            {
                case SqlConnectionType.Read:
                    conn = Dispatcher(ConfigurationManager.SqlConnectionStringRead);
                    break;
                case SqlConnectionType.Write:
                    conn = ConfigurationManager.SqlConnectionStringWrite;
                    break;
                default:
                    throw new Exception("wrong sqlConnectionType");
            }
            return conn;
        }
        private static int _Seed = 0;
        /// <summary>
        /// 调度分配--随机就是平均
        /// </summary>
        /// <param name="connectionStrings"></param>
        /// <returns></returns>
        private static string Dispatcher(string[] connectionStrings)
        {
            //string conn = connectionStrings[new Random(_Seed++).Next(0, connectionStrings.Length)];//平均策略
            string conn = connectionStrings[_Seed++ % connectionStrings.Length];//轮询--seed需要线程安全
            //能不能根据数据库的状况
            //权重--就是配置文件加点料  
            //2  3  4     9次请求  [1,1,2,2,2,3,3,3,3] 去平均
            return conn;
        }

        public enum SqlConnectionType
        {
            Read,
            Write
        }
    }
```

### 修改读写操作

`SqlHelper.cs`

使用` string connectString = GetConnectionString(SqlConnectionType.Read);`来获取连接字符串

```c#
   public class SqlHelper
    {
        public T Find<T>(int id) where T : BaseEntity
        {
            Type type = typeof(T);
            string sql = $"{SqlBuilder<T>.GetFindSql()}{id}";
            string connectString = GetConnectionString(SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connectString}");
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                    }

                    return t;
                }
            }

            return default(T);
        }
       
        public int Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T)
            //返回Id的insert语句
            //  _InsertSql = $"INSERT INTO [{type.GetMappingName()}] ({columnsString})                   VALUES({valuesString}) Select @@Identity ;";
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            string connectString = GetConnectionString(SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                object id = command.ExecuteScalar();
                return Convert.ToInt32(id);
            }
        }
    }
```



### 检验同步所用时间

`main.js`

```c#
        static void Main(string[] args)
        {
            try
            {
                SqlHelper helper = new SqlHelper();
                CompanyModel company1 = helper.Find<CompanyModel>(1);
                company1.CreateTime = DateTime.Now;
                company1.CompanyName += "-Administrator";
                int id = helper.Insert<CompanyModel>(company1);
                Console.WriteLine($"新增的CompanyId={id}");
                for (int i = 0; i < 100; i++)
                {
                    Console.WriteLine($"------------------开始查询------------------");
                    CompanyModel companyNew = helper.Find<CompanyModel>(id);
                    if (companyNew == null)
                    {
                        Console.WriteLine($"未同步到读库，继续{i}");
                    }
                    else
                    {
                        Console.WriteLine($"第{i}*500ms = {i*500/1000}s 同步到从库成功");
                        break;
                    }
                    Console.WriteLine(" ");

                    Thread.Sleep(500);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            Console.ReadLine();
        }
    }
```

输出：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122133936096.png" alt="image-20201122133936096" style="zoom:50%;" />



# 5. Asp.NetCore（3.1,5.0）

[Asp.Net Core 源码地址](https://github.com/aspnet/AspNetCore)

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-5.0)

## 5.1 扩展

扩展的两种方式：

1. Program
2. Startup

## 5.2 日志

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0)



### 第三方日志

[适用于 ASP.NET Core 的第三方日志记录框架](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#third-party-logging-providers)



### 5.2.1 log4Net

#### 使用步骤：

1. 安装包`Microsoft.Extensions.Logging.Log4Net.AspNetCore`

2. 添加`log4Net`日志组件

   - 方式一：在`Program`类中添加

   ```c#
           public static IHostBuilder CreateHostBuilder(string[] args) =>
               Host.CreateDefaultBuilder(args)
                   .ConfigureLogging(loggingBuilder => 
                   {
                       loggingBuilder.AddLog4Net();
                   })
                   .ConfigureWebHostDefaults(webBuilder =>
                   {
                       webBuilder.UseStartup<Startup>();
                   });
   ```

   其中， 方法`loggingBuilder.AddLog4Net()`默认读取项目更目录的配置文件`log4net.Config`

   - 方式二：在`Startup`类中添加

     ```C#
             public void Configure(......, ILoggerFactory loggerFactory)
             {
                 loggerFactory.AddLog4Net();
                 ......
             }
     ```

     

3. 添加`log4Net`组件的配置文件

   在项目的的根目录下，添加配置文件`log4net.Config`

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <log4net>
   	<!-- Define some output appenders -->
   	<appender name="rollingAppender" type="log4net.Appender.RollingFileAppender">
   		<file value="log\log.txt" />
   		<!--追加日志内容-->
   		<appendToFile value="true" />
   
   		<!--防止多线程时不能写Log,官方说线程非安全-->
   		<lockingModel type="log4net.Appender.FileAppender+MinimalLock" />
   
   		<!--可以为:Once|Size|Date|Composite-->
   		<!--Composite为Size和Date的组合-->
   		<rollingStyle value="Composite" />
   
   		<!--当备份文件时,为文件名加的后缀-->
   		<datePattern value="yyyyMMdd.TXT" />
   
   		<!--日志最大个数,都是最新的-->
   		<!--rollingStyle节点为Size时,只能有value个日志-->
   		<!--rollingStyle节点为Composite时,每天有value个日志-->
   		<maxSizeRollBackups value="20" />
   
   		<!--可用的单位:KB|MB|GB-->
   		<maximumFileSize value="3MB" />
   
   		<!--置为true,当前最新日志文件名永远为file节中的名字-->
   		<staticLogFileName value="true" />
   
   		<!--输出级别在INFO和ERROR之间的日志-->
   		<filter type="log4net.Filter.LevelRangeFilter">
   			<param name="LevelMin" value="ALL" />
   			<param name="LevelMax" value="FATAL" />
   		</filter>
   		<layout type="log4net.Layout.PatternLayout">
   			<conversionPattern value="%date [%thread] %-5level %logger - %message%newline"/>
   		</layout>
   	</appender>
   	<root>
   		<priority value="ALL"/>
   		<level value="ALL"/>
   		<appender-ref ref="rollingAppender" />
   	</root>
   </log4net>
   
   ```

   

4. 使用日志组件，比如在控制器中使用

   ```C#
       public class FirstController : Controller
       {
           private ILogger<FirstController> _logger;
           public FirstController(ILogger<FirstController> logger)
           {
               _logger = logger;
           }
   
           public IActionResult Index()
           {
               _logger.LogInformation("log in FirstController");
               return View();
           }
       }
   ```

5. 在`bin\log`文件夹中生成日志文件`log.txt`：

访问页面`https://localhost:5001/First`,日志文件追加输入如下日志

```md
2020-11-28 18:10:56,034 [4] INFO  AspNetCore31.Jumpstart.Controllers.FirstController - log in FirstController
```



#### ILoggerFactory： 日志的另一种使用方式

1. 依赖注入

   ```C#
       public class FirstController : Controller
       {
           private ILoggerFactory _loggerFactory;
   
           public FirstController(ILoggerFactory loggerFactory)
           {
               _loggerFactory = loggerFactory;
           }
       }
   ```

   

2. 使用：

   ```C#
           public IActionResult Index()
           {
               _loggerFactory.CreateLogger<FirstController>().LogInformation("log in FirstController");
               
               return View();
           }
   ```

   

## 5.3 部署项目

### 5.3.1 部署项目--命令行篇

可以用一个cmd—控制台进程—托管了网站

```md
dotnet AspNetCore31.Jumpstart.dll --urls="http://*:5177" --ip="127.0.0.1" --port=5177
```

需要copy 静态资源(wwwroot文件夹等)
控制台调试



### 5.3.2 部署项目--IIS篇

1. 该发布项目方式，相较于命令行发布，多生成了一个`web.config文件`

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <configuration>
     <location path="." inheritInChildApplications="false">
       <system.webServer>
         <handlers>
           <add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModuleV2" resourceType="Unspecified" />
         </handlers>
         <aspNetCore processPath="dotnet" arguments=".\AspNetCore31.Jumpstart.dll" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout" hostingModel="inprocess" />
       </system.webServer>
     </location>
   </configuration>
   <!--ProjectGuid: 30ba1a71-73cf-43a5-a764-a7052a609a84-->
   ```

   

2. 安装**AspNetCoreModuleV2**

   NetCore + ASP.NET Core Module支持进程内托管模型

3. IIS只是起到反向代理的作用

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201128201809683.png" alt="image-20201128201809683" style="zoom:80%;" />



IIS部署时，其实是把请求交给ModuleV2处理—转给dotnet—启动命令行那一套(IIS没有处理，只是一个代理)



### 5.3.3 理解Kestrel

- Kestrel就是一个简化版IIS web服务器：负责监听请求—转发到代码---完成响应
- Asp.NetCore本质是个控制台：运行起来是个网站---内置了一个Kestral（IIS服务器---所以来能脱离对IIS的依赖，所以才能做到跨平台）
- 有了kestrel，Asp.NetCore才能真正做到跨平台！

## 5.4 依赖注入

[ASP.NET Core 依赖注入](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0)



### 理解IOC&DI

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201129053949370.png" alt="image-20201129053949370" style="zoom:80%;" />



- 控制反转(Inversion of Control，IOC)是一种目标，让程序解耦，可以屏蔽细节
- 依赖倒置（Dependence Inversion Principle，DI），
- DI依赖注入是实现IOC的手段，

### 生命周期

```C#
  services.AddTransient<ITestServiceA, TestServiceA>();//瞬时,每次使用都创建一个实例
  services.AddSingleton<ITestServiceB, TestServiceB>();//单例
  services.AddScoped<ITestServiceC, TestServiceC>();//作用域单例,一次请求只创建一个实例
```



### Autofac

[github](https://github.com/autofac/Autofac)

[英文文档](https://autofaccn.readthedocs.io/en/latest/)

[中文文档](https://autofaccn.readthedocs.io/zh/latest/integration/aspnetcore.html)



[AspNetCore集成示例](https://github.com/autofac/Examples/tree/master/src/AspNetCoreExample)

#### 使用入门

- 安装

  在nuget中安装依赖包：`Autofac.Extensions.DependencyInjection`

  

- 添加`Autoface`组件

  每个版本的添加方式不同：

  - ASP.NET Core 1.1-2.2使用：

  ```C#
    public static void Main(string[] args)
    {
      // ASP.NET Core 1.1 - 2.2:
      // The ConfigureServices call here allows for
      // ConfigureContainer to be supported in Startup with
      // a strongly-typed ContainerBuilder.
      // AddAutofac() is a convenience method for
      // services.AddSingleton<IServiceProviderFactory<ContainerBuilder>>(new AutofacServiceProviderFactory())
      var host = new WebHostBuilder()
          .UseKestrel()
          .ConfigureServices(services => services.AddAutofac())
          .UseContentRoot(Directory.GetCurrentDirectory())
          .UseIISIntegration()
          .UseStartup<Startup>()
          .Build();
  
      host.Run();
    }
  ```

  - 下面是**ASP.NET Core 3+** 和 .NET Core 3+ generic hosting support的集成方式:

  ```C#
   .UseServiceProviderFactory(new AutofacServiceProviderFactory())//设置工厂来替换实例
  ```

  ```C#
          public static IHostBuilder CreateHostBuilder(string[] args) =>
              Host.CreateDefaultBuilder(args)
                  .ConfigureLogging(loggingBuilder => 
                  {
                      loggingBuilder.AddLog4Net();
                  })
                  .UseServiceProviderFactory(new AutofacServiceProviderFactory())//设置工厂来替换实例
                  .ConfigureWebHostDefaults(webBuilder =>
                  {
                      webBuilder.UseStartup<Startup>();
                  });
  ```

  

- 依赖注入

  `Startup类`

  在你的`Startup`类中 (各版本ASP.NET Core基本一致) 你可以使用 `ConfigureContainer` 访问 Autofac container builder 并且直接使用Autofac注册东西.

  ```C#
     public class Startup
      {
          //Asp.Net框架自身会调用该方法
          public void ConfigureContainer(ContainerBuilder containerBuilder)
          {
              // Add any Autofac modules or registrations.
              // This is called AFTER ConfigureServices so things you
              // register here OVERRIDE things registered in ConfigureServices.
              //
              // You must have the call to AddAutofac in the Program.Main
              // method or this won't be called.
              containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
          }
         ......
     }
  ```

   

#### 实例分析

`Startup.cs`

```C#
    public class Startup
    {
        //......
        public void ConfigureServices(IServiceCollection services)
        {
            //......
            services.AddTransient<ITestServiceA, TestServiceA>();//瞬时
            services.AddSingleton<ITestServiceB, TestServiceB>();//单例
            services.AddScoped<ITestServiceC, TestServiceC>();//作用域单例--一次请求一个实例
        }

        public void ConfigureContainer(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterType<TestServiceE>().As<ITestServiceE>().SingleInstance();
        }

```

`FirstController.cs`

```C#
    public class FirstController : Controller
    {
        //.....
        private readonly ITestServiceA _iTestServiceA;
        private readonly ITestServiceB _iTestServiceB;
        private readonly ITestServiceC _iTestServiceC;

        public FirstController(ILogger<FirstController> logger, ILoggerFactory loggerFactory, 
            ITestServiceA iTestServiceA,
            ITestServiceB iTestServiceB,
            ITestServiceC iTestServiceC)
        {
            // ....
            _iTestServiceA = iTestServiceA;
            _iTestServiceB = iTestServiceB;
            _iTestServiceC = iTestServiceC;

        }

        public IActionResult Index()
        {
            Console.WriteLine($"A:{_iTestServiceA.GetHashCode()}");
            Console.WriteLine($"B:{_iTestServiceB.GetHashCode()}");
            
            Console.WriteLine($"C:{_iTestServiceC.GetHashCode()}");
            Console.WriteLine($"C:{_iTestServiceC.GetHashCode()}");
            
            return View();
        }
    }
```

第一次访问`https://localhost:5001/First`输出：

```md
A:65718035
B:37901460
C:57733168
C:57733168
```

第二次访问`https://localhost:5001/First`输出：

```md
A:65718035
B:37901460
C:41149443
C:41149443
```

呈现的结果表明：

​    `ITestServiceA`--单例，被`Autoface`注册为单例覆盖了

​    `ITestServiceB`--单例，使用`IServiceCollection`注册为单例

   `ITestServiceC`--Scoped ,`IServiceCollection`注册为Scoped ,一个请求，共用一个实例

说明：

1. **Autoface与内置的`IServiceCollection`可共存**

2. **在`Autoface`的注册将覆盖在`IServiceCollection`的注册**

   因为使用Autoface的方法`ConfigureContainer()`

   ```c#
           public void ConfigureContainer(ContainerBuilder containerBuilder)
           {
               // Add any Autofac modules or registrations.
               // This is called AFTER ConfigureServices so things you
               // register here OVERRIDE things registered in ConfigureServices.
               //
               // You must have the call to AddAutofac in the Program.Main
               // method or this won't be called.
               containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
           }
   ```

   是在`ConfigureServices`方法之后调用的

   

#### Autofac.Module

`Startup.cs`

```c#
    public class Startup
    {
        //......
        
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllersWithViews();
        }

        //Asp.Net框架自身会调用该方法
        public void ConfigureContainer(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterModule<CustomAutofacModule>();
        }
```

自定一个类`CustomAutofacModule`,继承自`Autofac.Module`

```c#
public class CustomAutofacModule : Autofac.Module
    {
        protected override void Load(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
            containerBuilder.RegisterType<TestServiceC>().As<ITestServiceC>();
            containerBuilder.RegisterType<TestServiceB>().As<ITestServiceB>();
            containerBuilder.RegisterType<TestServiceD>().As<ITestServiceD>();
            containerBuilder.RegisterType<TestServiceE>().As<ITestServiceE>();
        }

    }
```





## 5.4 中间件

[ASP.NET Core 中间件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#create-a-middleware-pipeline-with-iapplicationbuilder)



### 什么是中间件

中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件：

- 选择是否将请求传递到管道中的下一个组件。
- 可在管道中的下一个组件前后执行工作。

请求委托用于生成请求管道。 请求委托处理每个 HTTP 请求。

使用 [Run](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.runextensions.run)[Map](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map) 和 [Use](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use) 扩展方法来配置请求委托。 可将一个单独的请求委托并行指定为匿名方法（称为并行中间件），或在可重用的类中对其进行定义。 这些可重用的类和并行匿名方法即为中间件，也叫中间件组件。



### 使用 IApplicationBuilder 创建中间件管道

ASP.NET Core 请求管道包含一系列请求委托，依次调用。 下图演示了这一概念。 沿黑色箭头执行。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/request-delegate-pipeline.png" alt="request-delegate-pipeline" style="zoom:100%;" />

#### Use

用 [Use](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use) 将多个请求委托链接在一起，

```c#
            app.Use(next =>
            {
                Console.WriteLine("This is middleware 1");
                return new RequestDelegate(
                    async context =>
                    {
                        await next.Invoke(context);
                    });
            });

            app.Use(next =>
            {
                Console.WriteLine("This is middleware 2");
                return new RequestDelegate(
                    async context =>
                    {
                        await next.Invoke(context);
                    });
            });
```

输出：

```md
This is middleware 2
This is middleware 1
```

注意，执行上述的代码后发现，中间件**执行顺序与加入管道的顺序相反**，原因，看源码[ApplicationBuilder](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Http/src/Builder/ApplicationBuilder.cs)：

```C#

namespace Microsoft.AspNetCore.Builder
{
    public class ApplicationBuilder : IApplicationBuilder
    {
        
        private readonly IList<Func<RequestDelegate, RequestDelegate>> _components = new List<Func<RequestDelegate, RequestDelegate>>();
        
        //......
       
       public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
        {
            _components.Add(middleware);
            return this;
        }

        public RequestDelegate Build()
        {  
            //声明一个RequestDelegate，默认处理步骤
            //默认最起始的委托（404中间件）
            RequestDelegate app = context =>
            {
                ......
                context.Response.StatusCode = StatusCodes.Status404NotFound;
                return Task.CompletedTask;    
            }; 

            foreach (var component in _components.Reverse())//集合反转 123进来  321执行--
            {
                //Func<RequestDelegate,RequestDelegate> 是321的顺序
                app = component(app);
                //404--->middleware3-->middleware2-->middleware1  最终的结果Application其实就是middleware1
            }

            return app;
        }
    }
}
```

其中，

```C#

            foreach (var component in _components.Reverse())//集合反转 123进来  321执行--
            {
                //Func<RequestDelegate,RequestDelegate> 是321的顺序
                app = component(app);
                //404--->middleware3-->middleware2-->middleware1  最终的结果Application其实就是middleware1
            }
```

反转中间件集合，反向执行，



##### UseExtensions

`IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware);`使用有点复杂

故，有一个扩展方法，[UseExtensions](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Http.Abstractions/src/Extensions/UseExtensions.cs) 如下：

```c#
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;

namespace Microsoft.AspNetCore.Builder
{
    /// <summary>
    /// Extension methods for adding middleware.
    /// </summary>
    public static class UseExtensions
    {
        /// <summary>
        /// Adds a middleware delegate defined in-line to the application's request pipeline.
        /// </summary>
        /// <param name="app">The <see cref="IApplicationBuilder"/> instance.</param>
        /// <param name="middleware">A function that handles the request or calls the given next function.</param>
        /// <returns>The <see cref="IApplicationBuilder"/> instance.</returns>
        public static IApplicationBuilder Use(this IApplicationBuilder app, Func<HttpContext, Func<Task>, Task> middleware)
        {
            return app.Use(next =>
            {
                return context =>
                {
                    Func<Task> simpleNext = () => next(context);
                    return middleware(context, simpleNext);
                };
            });
        }
    }
}
```

使用如下，

```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
            app.Use(async (context, next) =>
            {
                Console.WriteLine("app.Use(async (context, next) => This is middleware 1--start");
                await next.Invoke();
                Console.WriteLine("app.Use(async (context, next) => This is middleware 1--end");
            });

            app.Use(async (context, next) =>
            {
                Console.WriteLine("app.Use(async (context, next) => This is middleware 2--start");
                await next.Invoke();
                Console.WriteLine("app.Use(async (context, next) => This is middleware 2--end");
            });
    }
}
```

,其中`next` 参数表示管道中的下一个委托。 可通过不调用 next 参数使管道短路

执行上述代码，输出：

```md
app.Use(async (context, next) => This is middleware 1--start
app.Use(async (context, next) => This is middleware 2--start
app.Use(async (context, next) => This is middleware 2--end
app.Use(async (context, next) => This is middleware 1--end
```

这个执行顺序和加入顺序一致，从这个角度看，比使用`app.Use(next =>{})`好理解多了



#### Run

[Run](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.runextensions.run) 委托不会收到 `next` 参数，

第一个 `Run` 委托**始终为终端**，**用于终止管道**。 **`Run` 是一种约定**。

```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.Use(async (context, next) =>
        {
            // Do work that doesn't write to the Response.
            await next.Invoke();
            // Do logging or other work that doesn't write to the Response.
        });

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from 2nd delegate.");
        });
    }
}
```



### 中间件顺序

下图显示了 ASP.NET Core MVC 和 Razor Pages 应用的完整请求处理管道。 你可以在典型应用中了解现有中间件的顺序，以及在哪里添加自定义中间件。 你可以完全控制如何重新排列现有中间件，或根据场景需要注入新的自定义中间件。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/middleware-pipeline.svg" alt="middleware-pipeline" style="zoom:80%;" />

上图中的“终结点”中间件为相应的应用类型（MVC 或 Razor Pages）执行筛选器管道。 



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/mvc-endpoint.svg" alt="mvc-endpoint" style="zoom:80%;" />

下面的 `Startup.Configure` 方法按照建议的顺序增加与安全相关的中间件组件：

```C#
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseDatabaseErrorPage();
    }
    else
    {
        app.UseExceptionHandler("/Error");
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();
    // app.UseCookiePolicy();

    app.UseRouting();
    // app.UseRequestLocalization();
    // app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();
    // app.UseSession();
    // app.UseResponseCaching();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
```



### 对中间件管道进行分支

#### Map扩展

[Map](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map) 扩展用作约定来创建管道分支。 `Map` 基于给定请求路径的匹配项来创建请求管道分支。 如果请求路径以给定路径开头，则执行分支。

```c#
public class Startup
{
    private static void HandleMapTest1(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            await context.Response.WriteAsync("Map Test 1");
        });
    }

    private static void HandleMapTest2(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            await context.Response.WriteAsync("Map Test 2");
        });
    }

    public void Configure(IApplicationBuilder app)
    {
        app.Map("/map1", HandleMapTest1);

        app.Map("/map2", HandleMapTest2);

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from non-Map delegate. <p>");
        });
    }
}
```

#### MapWhen

 [MapWhen](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapwhenextensions.mapwhen) 基于给定谓词的结果创建请求管道分支。

`Func<HttpContext, bool>` 类型的任何谓词均可用于将请求映射到管道的新分支。

```C#
public class Startup
{
    private static void HandleBranch(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            var branchVer = context.Request.Query["branch"];
            await context.Response.WriteAsync($"Branch used = {branchVer}");
        });
    }

    public void Configure(IApplicationBuilder app)
    {
        app.MapWhen(context => context.Request.Query.ContainsKey("branch"),
                               HandleBranch);

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from non-Map delegate. <p>");
        });
    }
}
```

| 请求                          | 响应                         |
| :---------------------------- | :--------------------------- |
| localhost:1234                | Hello from non-Map delegate. |
| localhost:1234/?branch=master | Branch used = master         |



#### UseWhen

[UseWhen](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.usewhenextensions.usewhen) 也基于给定谓词的结果创建请求管道分支。 与 `MapWhen` 不同的是，如果这个分支不发生短路或包含终端中间件，则会重新加入主管道：

```C#
public class Startup
{
    private void HandleBranchAndRejoin(IApplicationBuilder app, ILogger<Startup> logger)
    {
        app.Use(async (context, next) =>
        {
            var branchVer = context.Request.Query["branch"];
            logger.LogInformation("Branch used = {branchVer}", branchVer);

            // Do work that doesn't write to the Response.
            await next();
            // Do other work that doesn't write to the Response.
        });
    }

    public void Configure(IApplicationBuilder app, ILogger<Startup> logger)
    {
        app.UseWhen(context => context.Request.Query.ContainsKey("branch"),
                               appBuilder => HandleBranchAndRejoin(appBuilder, logger));

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from main pipeline.");
        });
    }
}
```

在前面的示例中，响应 "Hello from main pipeline." 是为所有请求编写的。 如果请求中包含查询字符串变量 `branch`，则在重新加入主管道之前会记录其值。



###  内置中间件

ASP.NET Core 附带以下中间件组件。 “顺序”列提供备注，以说明中间件在请求处理管道中的放置，以及中间件可能会终止请求处理的条件。 如果中间件让请求处理管道短路，并阻止下游中间件进一步处理请求，它被称为“终端中间件”。 若要详细了解短路，请参阅[使用 IApplicationBuilder 创建中间件管道](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#create-a-middleware-pipeline-with-iapplicationbuilder)部分。

| 中间件                                                       | 描述                                                         | 顺序                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| [身份验证](https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/identity?view=aspnetcore-5.0) | 提供身份验证支持。                                           | 在需要 `HttpContext.User` 之前。 OAuth 回叫的终端。          |
| [授权](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.authorizationappbuilderextensions.useauthorization) | 提供身份验证支持。                                           | 紧接在身份验证中间件之后。                                   |
| [Cookie 策略](https://docs.microsoft.com/zh-cn/aspnet/core/security/gdpr?view=aspnetcore-5.0) | 跟踪用户是否同意存储个人信息，并强制实施 cookie 字段（如 `secure` 和 `SameSite`）的最低标准。 | 在发出 cookie 的中间件之前。 示例：身份验证、会话、MVC (TempData)。 |
| [CORS](https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0) | 配置跨域资源共享。                                           | 在使用 CORS 的组件之前。 由于[此错误](https://github.com/dotnet/aspnetcore/issues/23218)，`UseCors` 当前必须在 `UseResponseCaching` 之前运行。 |
| [诊断](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/error-handling?view=aspnetcore-5.0) | 提供新应用的开发人员异常页、异常处理、状态代码页和默认网页的几个单独的中间件。 | 在生成错误的组件之前。 异常终端或为新应用提供默认网页的终端。 |
| [转接头](https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-5.0) | 将代理标头转发到当前请求。                                   | 在使用已更新字段的组件之前。 示例：方案、主机、客户端 IP、方法。 |
| [运行状况检查](https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-5.0) | 检查 ASP.NET Core 应用及其依赖项的运行状况，如检查数据库可用性。 | 如果请求与运行状况检查终结点匹配，则为终端。                 |
| [标头传播](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-5.0#header-propagation-middleware) | 将 HTTP 标头从传入的请求传播到传出的 HTTP 客户端请求中。     |                                                              |
| [HTTP 方法重写](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.httpmethodoverrideextensions) | 允许传入 POST 请求重写方法。                                 | 在使用已更新方法的组件之前。                                 |
| [HTTPS 重定向](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0#require-https) | 将所有 HTTP 请求重定向到 HTTPS。                             | 在使用 URL 的组件之前。                                      |
| [HTTP 严格传输安全性 (HSTS)](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0#http-strict-transport-security-protocol-hsts) | 添加特殊响应标头的安全增强中间件。                           | 在发送响应之前，修改请求的组件之后。 示例：转接头、URL 重写。 |
| [MVC](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/overview?view=aspnetcore-5.0) | 用 MVC/Razor Pages 处理请求。                                | 如果请求与路由匹配，则为终端。                               |
| [OWIN](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/owin?view=aspnetcore-5.0) | 与基于 OWIN 的应用、服务器和中间件进行互操作。               | 如果 OWIN 中间件处理完请求，则为终端。                       |
| [响应缓存](https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware?view=aspnetcore-5.0) | 提供对缓存响应的支持。                                       | 在需要缓存的组件之前。 `UseCORS` 必须在 `UseResponseCaching` 之前。 |
| [响应压缩](https://docs.microsoft.com/zh-cn/aspnet/core/performance/response-compression?view=aspnetcore-5.0) | 提供对压缩响应的支持。                                       | 在需要压缩的组件之前。                                       |
| [请求本地化](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/localization?view=aspnetcore-5.0) | 提供本地化支持。                                             | 在对本地化敏感的组件之前。                                   |
| [终结点路由](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-5.0) | 定义和约束请求路由。                                         | 用于匹配路由的终端。                                         |
| [SPA](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.spaapplicationbuilderextensions.usespa) | 通过返回单页应用程序 (SPA) 的默认页面，在中间件链中处理来自这个点的所有请求 | 在链中处于靠后位置，因此其他服务于静态文件、MVC 操作等内容的中间件占据优先位置。 |
| [会话](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/app-state?view=aspnetcore-5.0) | 提供对管理用户会话的支持。                                   | 在需要会话的组件之前。                                       |
| [静态文件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-5.0) | 为提供静态文件和目录浏览提供支持。                           | 如果请求与文件匹配，则为终端。                               |
| [URL 重写](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/url-rewriting?view=aspnetcore-5.0) | 提供对重写 URL 和重定向请求的支持。                          | 在使用 URL 的组件之前。                                      |
| [WebSockets](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-5.0) | 启用 WebSockets 协议。                                       | 在接受 WebSocket 请求所需的组件之前。                        |



### 自定义中间件

[编写中间件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/write?view=aspnetcore-5.0)



编写一个中间件：通过传入区域性测试中间件。 例如，请求 `https://localhost:5001/?culture=no`。

#### 定义中间件类

```C#
using Microsoft.AspNetCore.Http;
using System.Globalization;
using System.Threading.Tasks;

namespace Culture
{
    public class RequestCultureMiddleware
    {
        private readonly RequestDelegate _next;

        public RequestCultureMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var cultureQuery = context.Request.Query["culture"];
            if (!string.IsNullOrWhiteSpace(cultureQuery))
            {
                var culture = new CultureInfo(cultureQuery);

                CultureInfo.CurrentCulture = culture;
                CultureInfo.CurrentUICulture = culture;

            }

            // Call the next delegate/middleware in the pipeline
            await _next(context);
        }
    }
}

```

中间件类必须包括：

- 具有类型为 [RequestDelegate](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.requestdelegate) 的参数的公共构造函数。

- 名为 `Invoke` 或 `InvokeAsync` 的公共方法。

  此方法必须：

  - 返回 `Task`。
  - 接受类型 [HttpContext](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.httpcontext) 的第一个参数。



#### 中间件扩展方法

以下通过 [IApplicationBuilder](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder)的扩展方法 公开中间件：

定义一个扩展方法，封装`builder.UseMiddleware<RequestCultureMiddleware>()`，

```C#
using Microsoft.AspNetCore.Builder;

namespace Culture
{
    public static class RequestCultureMiddlewareExtensions
    {
        public static IApplicationBuilder UseRequestCulture(
            this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestCultureMiddleware>();
        }
    }
}
```

#### 使用中间件

以下代码通过 `Startup.Configure` 调用中间件：


```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.UseRequestCulture();

        app.Run(async (context) =>
        {
            await context.Response.WriteAsync(
                $"Hello {CultureInfo.CurrentCulture.DisplayName}");
        });
    }
}
```



## 5.5 筛选器(Filter)

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#dependency-injection)



### 筛选器类型

每种筛选器类型都在筛选器管道中的不同阶段执行：

- [授权筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#authorization-filters)最先运行，用于确定是否已针对请求为用户授权。 如果请求未获授权，授权筛选器可以让管道短路。
- [资源筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#resource-filters)：
  - 授权后运行。
  - [OnResourceExecuting](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iresourcefilter.onresourceexecuting) 在筛选器管道的其余阶段之前运行代码。 例如，`OnResourceExecuting` 在模型绑定之前运行代码。
  - [OnResourceExecuted](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iresourcefilter.onresourceexecuted) 在管道的其余阶段完成之后运行代码。
- [操作筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#action-filters)：
  - 在调用操作方法之前和之后立即运行代码。
  - 可以更改传递到操作中的参数。
  - 可以更改从操作返回的结果。
  - 页面 **不** 支持 Razor 。
- [异常筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#exception-filters)在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。
- [结果筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#result-filters)在执行操作结果之前和之后立即运行代码。 仅当操作方法成功执行时，它们才会运行。 对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。

下图展示了筛选器类型在筛选器管道中的交互方式。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/filter-pipeline-2.png" alt="filter-pipeline-2" style="zoom:75%;" />

多种筛选器接口具有相应属性，这些属性可用作自定义实现的基类。

筛选器属性：

- [ActionFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute)
- [ExceptionFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.exceptionfilterattribute)
- [ResultFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resultfilterattribute)
- [FormatFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.formatfilterattribute)
- [ServiceFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.servicefilterattribute)
- [TypeFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.typefilterattribute)



### Filter的示例

通过这个示例，串讲`Filte`的相关知识点。

自定义一个`Filter`,名为`CustomExceptionFilterAttribute`，继承自` ExceptionFilterAttribute`

`CustomEceptionFilterAttribute.cs`完整代码：

```C#
    public class CustomExceptionFilterAttribute : ExceptionFilterAttribute
    {
        private readonly ILogger<CustomExceptionFilterAttribute> _logger;
        private readonly IModelMetadataProvider _modelMetadataProvider;
        public CustomExceptionFilterAttribute(ILogger<CustomExceptionFilterAttribute> logger
            , IModelMetadataProvider modelMetadataProvider)
        {
            this._modelMetadataProvider = modelMetadataProvider;
            this._logger = logger;
        }

        /// <summary>
        /// 异常发生，但是没有处理时
        /// 异常之后得写日志
        /// </summary>
        /// <param name="context"></param>
        public override void OnException(ExceptionContext context)
        {
            if (!context.ExceptionHandled)
            {
                this._logger.LogError($"{context.HttpContext.Request.RouteValues["controller"]} is Error");
                if (this.IsAjaxRequest(context.HttpContext.Request))//header看看是不是XMLHttpRequest
                {
                    context.Result = new JsonResult(new
                    {
                        Result = false,
                        Msg = context.Exception.Message
                    });//中断式---请求到这里结束了，不再继续Action
                }
                else
                {
                    var result = new ViewResult { ViewName = "~/Views/Shared/Error.cshtml" };
                    result.ViewData = new ViewDataDictionary(_modelMetadataProvider, context.ModelState);
                    result.ViewData.Add("Exception", context.Exception);
                    context.Result = result;
                }
                context.ExceptionHandled = true;
            }
        }

        private bool IsAjaxRequest(HttpRequest request)
        {
            string header = request.Headers["X-Requested-With"];
            return "XMLHttpRequest".Equals(header);
        }
    }
```



#### 取消和设置短路

通过设置提供给筛选器方法的 [ResourceExecutingContext](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resourceexecutingcontext) 参数上的 [Result](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resourceexecutingcontext.result#Microsoft_AspNetCore_Mvc_Filters_ResourceExecutingContext_Result) 属性，可以使筛选器管道短路。 例如，以下资源筛选器将阻止执行管道的其余阶段：

```C#
                if (this.IsAjaxRequest(context.HttpContext.Request))//header看看是不是XMLHttpRequest
                {
                    context.Result = new JsonResult(new
                    {
                        Result = false,
                        Msg = context.Exception.Message
                    });//中断式---请求到这里结束了，不再继续Action
                }
```



#### 错误页

如何在错误页面提供异常信息呢？

```c#
        var result = new ViewResult { ViewName = "~/Views/Shared/Error.cshtml" };
        result.ViewData = new ViewDataDictionary(_modelMetadataProvider, context.ModelState);
        result.ViewData.Add("Exception", context.Exception);
        context.Result = result;
```

关键代码：

```c#
       result.ViewData.Add("Exception", context.Exception);
```

在`Error.cshtml`显示异常信息：

```C#
//.......

@{
    Exception exception = base.ViewData["Exception"] as Exception;
}
//.....

<h2>@exception.Message</h2>
```



#### 依赖注入

我们注意到，`CustomExceptionFilterAttribute`需要某些服务，

```C#
    public class CustomExceptionFilterAttribute : ExceptionFilterAttribute
    {
        private readonly ILogger<CustomExceptionFilterAttribute> _logger;
        private readonly IModelMetadataProvider _modelMetadataProvider;
        
        public CustomExceptionFilterAttribute(ILogger<CustomExceptionFilterAttribute> logger
            , IModelMetadataProvider modelMetadataProvider)
        {
            this._modelMetadataProvider = modelMetadataProvider;
            this._logger = logger;
        }
       
        // ......
    }
```

如果在控制器或及其方法中使用：

```C#
    [CustomExceptionFilterAttribute]//语法错误，无法编译
    public IActionResult Exce()
    {
        throw new Exception("my Exce");
        return View();
    }
```

上述代码直接使用`[CustomExceptionFilterAttribute]`是无法编译通过的，



官方解释：

>  如果将筛选器作为属性实现并直接添加到控制器类或操作方法中，则该筛选器不能由[依赖关系注入](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0) (DI) 提供构造函数依赖项。 无法由 DI 提供构造函数依赖项，因为：
>
> - 属性在应用时必须提供自己的构造函数参数。
> - 这是属性工作原理上的限制。
>
> **以下筛选器支持从 DI 提供的构造函数依赖项：**
>
> - **[ServiceFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.servicefilterattribute)**
> - **[TypeFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.typefilterattribute)**
> - **在属性上实现 [IFilterFactory](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory)。**



如何为`CustomExceptionFilterAttribute`实现依赖注入呢？，请看下一节【Filter的依赖注入】

### Filter的依赖注入

`Filter`需要某个服务，怎么去获取呢？全程是依赖注入的，怎么为Filte进行依赖注入呢？

##### Filter特性的四种注入方式

###### 全局注册

全局的注册不需要添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
         services.AddControllersWithViews(options => { //定义全局的Filters， 所有的控制器、操作都使用
                options.Filters.Add(typeof(CustomExceptionFilterAttribute));
            });
```



###### ServiceFilter

第一步：添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Add service filters.
    services.AddScoped<CustomExceptionFilterAttribute>();
}
```

第二步：`ServiceFilter` 属性将从 DI 中检索 `CustomExceptionFilterAttribute` 的实例

```c#
        [ServiceFilter(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



###### TypeFilter

使用`TypeFilter`,不需要添加`CustomExceptionFilterAttribute`到 DI 容器中，只是使用`TypeFilter(typeof())`即可

```C#
        [TypeFilter(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



###### IFilterFactory

 就是Filter的工厂，任何环节都可以用工厂代替Filter，`IFilterFactory`里面有ServiceProvider,所以可以IOC了

第一步：

定义一个名为`CustomIOCFilterFactoryAttribute`的特性，继承接口`IFilterFactory`

```C#
    /// <summary>
    /// 基于完成Filter的依赖注入
    /// </summary>
    public class CustomIOCFilterFactoryAttribute : Attribute, IFilterFactory
    {
        private readonly Type _FilterType = null;

        public CustomIOCFilterFactoryAttribute(Type type)
        {
            this._FilterType = type;
        }
        public bool IsReusable => true;

        public IFilterMetadata CreateInstance(IServiceProvider serviceProvider)
        {
            return (IFilterMetadata)serviceProvider.GetService(this._FilterType);
        }
    }
```

第二步：

添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Add service filters.
    services.AddScoped<CustomExceptionFilterAttribute>();
}
```

第三步：

使用`[CustomIOCFilterFactory(typeof())]`特性

```C#
        [CustomIOCFilterFactory(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



### 筛选器作用域

可以将筛选器添加到管道中的以下三个 *范围* 之一：

- 在控制器操作上使用属性。 筛选器属性不能应用于 Razor 页面处理程序方法。

  如以下代码所示， 控制器`FilterController`的`Exce()`操作使用了使用筛选器`CustomExceptionFilterAttribute`

  ```C#
      public class FilterController : Controller
      {
          //[CustomExceptionFilterAttribute]//语法错误，无法编译
          [ServiceFilter(typeof(CustomExceptionFilterAttribute))]
          public IActionResult Exce()
          {
              throw new Exception("my Exce");
              return View();
          }
      }
  ```

  

- 在控制器或页上使用特性 Razor 。

- 针对所有控制器、操作和页面全局 Razor 显示，

  如以下代码所示， 所有的控制器、操作都将使用筛选器`CustomExceptionFilterAttribute`

  ```C#
  public void ConfigureServices(IServiceCollection services)
  {
      services.AddControllersWithViews(options => //定义全局的Filters， 所有的控制器、操作都使用
     {
          options.Filters.Add(typeof(CustomExceptionFilterAttribute));
      });
  }
  ```





### 筛选器执行顺序

当管道的某个特定阶段有多个筛选器时，作用域可确定筛选器执行的默认顺序。 全局筛选器涵盖类筛选器，类筛选器又涵盖方法筛选器。



在筛选器嵌套模式下，筛选器的 after 代码会按照与 before 代码相反的顺序运行。 筛选器序列：

- 全局筛选器的 before 代码。
  - 控制器 *before* 和 Razor 页面筛选器的前代码。
    - 操作方法筛选器的 before 代码。
    - 操作方法筛选器的 after 代码。
  - 控制器 *after* 和 Razor 页面筛选器后的代码。
- 全局筛选器的 after 代码。



执行顺序还跟筛选器的类型有关

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/filter-pipeline-2.png" alt="filter-pipeline-2" style="zoom:75%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201129153951272.png" alt="image-20201129153951272" style="zoom:75%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/mvc-endpoint.svg" alt="mvc-endpoint" style="zoom:80%;" />

#### 示例代码

##### Action级Filter

定义一个`CustomActionFilterAttribute` , 继承自`CustomActionFilterAttribute`

```C#
    public class CustomActionFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnActionExecuted->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
    }
```

抽象类`ActionFilterAttribute`实现的接口如下：

```C#
public abstract class ActionFilterAttribute : Attribute, IActionFilter, IFilterMetadata, IAsyncActionFilter, IAsyncResultFilter, IOrderedFilter, IResultFilter
```

在控制器的方法中是使用该`Filter`:

```c#
  public class FilterController : Controller
    {
        //......
      
        [CustomActionFilterAttribute]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
    }
```

`ExcOrder.cshtml`

```cshtml
@{
    ViewData["Title"] = "Filter执行顺序";
    Console.WriteLine($"This is FilterController View Info");
}
<h4>Filter执行顺序</h4>
```

访问页面:`https://localhost:5001/filter/excorder`, 控制台输出：

```md
//......
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
//......
```



##### Contronller级Filter

再定义一个`Filter`:`CustomControllerFilterAttribute`, 将其使用在`Controller`上

```
    public class CustomControllerFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnActionExecuted ->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
```

```C#
    [CustomControllerFilter]
    public class FilterController : Controller
    {
         //......
        [CustomActionFilterAttribute]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
        //......
    }
```

控制台输出：

```md
//......
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
This CustomControllerFilterAttribute OnResultExecuted->Order:0
//......
```



##### 全局Filter

再定义一个`Filter`:CustomGlobalFilterAttribute, 将其注册为全局Filter

````C#
   public class CustomGlobalFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnActionExecuted->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
````

```C#
        public void ConfigureServices(IServiceCollection services)
        {
             //......
            services.AddControllersWithViews(options => { //定义全局的Filters， 所有的控制器、操作都使用
                options.Filters.Add(typeof(CustomGlobalFilterAttribute));
            });
            //......
        }
```

控制台输出：

```md
//......
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
//......
```

修饰下输出，方便对调用顺序查看：

```C#
//......
//以下为ActionFilter
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
	This CustomControllerFilterAttribute OnActionExecuting->Order:0
		This CustomActionFilterAttribute OnActionExecuting->Order:0
			This is FilterController aciton： ExcOrder
		This CustomActionFilterAttribute OnActionExecuted->Order:0
	This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
    
    
//以下为OnResultFilter
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
	This CustomControllerFilterAttribute OnResultExecuting->Order:0
		This CustomActionFilterAttribute OnResultExecuting->Order:0
			This is FilterController View ExcOrder
		This CustomActionFilterAttribute OnResultExecuted->Order:0
	This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
//......
```



### 重写默认顺序

可以通过实现 [IOrderedFilter](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter) 来重写默认执行序列。 `IOrderedFilter` 公开了 [Order](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter.order#Microsoft_AspNetCore_Mvc_Filters_IOrderedFilter_Order) 属性来确定执行顺序，该属性优先于作用域。 具有较低的 `Order` 值的筛选器：

- 在具有较高的 `Order` 值的筛选器之前运行 before 代码。
- 在具有较高的 `Order` 值的筛选器之后运行 after 代码。

使用构造函数参数设置了 `Order` 属性,



通俗来讲，就是

- **`Order`属性值默认值为：0；**
- **`Order`属性值越小的`filter`，越先执行。**

用上一讲的示例，来验证下，把`CustomActionFilterAttribute `的属性值变成`-1`,

    [CustomControllerFilter]
    public class FilterController : Controller
    {
         //......
        [CustomActionFilterAttribute(Order = -1)]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
        //......
    }
控制台输出：

```c#
//......
This CustomActionFilterAttribute OnActionExecuting->Order:-1
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnActionExecuted->Order:-1
This CustomActionFilterAttribute OnResultExecuting->Order:-1
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuted->Order:-1
//......
```

美化后的输出格式：

```md
//......
//以下为ActionFilter
This CustomActionFilterAttribute OnActionExecuting->Order:-1
	This CustomGlobalFilterAttribute OnActionExecuting->Order:0
		This CustomControllerFilterAttribute OnActionExecuting->Order:0
			This is FilterController aciton： ExcOrder
		This CustomControllerFilterAttribute OnActionExecuted ->Order:0
	This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnActionExecuted->Order:-1

//以下为OnResultFilter
This CustomActionFilterAttribute OnResultExecuting->Order:-1
	This CustomGlobalFilterAttribute OnResultExecuting->Order:0
		This CustomControllerFilterAttribute OnResultExecuting->Order:0
			This is FilterController View ExcOrder
		This CustomControllerFilterAttribute OnResultExecuted->Order:0
	This CustomGlobalFilterAttribute OnResultExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuted->Order:-1
//......
```



### Q&A

- **Q:那什么时候用中间件？什么时候用Filter？**

  **A**：粒度不同的

  ​       Filter是MVC的，中间件能知道action controller，中间件是全部请求都要通过的，Filter可以针对方法/controller，合适选择



## 5.6 认证

[Asp.net MVC中使用Cookie认证](https://www.cnblogs.com/iampkm/p/4699788.html)

[cookie不使用身份验证ASP.NET Core Identity](https://docs.microsoft.com/zh-CN/aspnet/core/security/authentication/cookie?view=aspnetcore-5.0)

### 5.6.1 基于Session传统的认证

#### 登录

`AccountController.cs`

```C#
    /// <summary>
    /// 登录---常规登录靠的是Cookie/Session
    /// </summary>
    public class AccountController : Controller
    {
        private readonly ILogger<AccountController> _logger;
        public AccountController(ILogger<AccountController> logger)
        {
            _logger = logger; ;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpGet]//响应get请求
        public ViewResult Login()
        {
            return View();
        }

        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Login(string name, string password, string verify)
        {
            string verifyCode = base.HttpContext.Session.GetString("CheckCode");
            if (verifyCode != null && verifyCode.Equals(verify, StringComparison.CurrentCultureIgnoreCase))
            {
                if ("KKK".Equals(name) && "123456".Equals(password))
                {
                    CurrentUser currentUser = new CurrentUser()
                    {
                        Id = 123,
                        Name = "KKK",
                        Account = "Administrator",
                        Email = "57265177",
                        Password = "123456",
                        LoginTime = DateTime.Now
                    };

                    base.HttpContext.Session.SetString("CurrentUser", Newtonsoft.Json.JsonConvert.SerializeObject(currentUser));
             
                    return base.Redirect("/Home/Index");
                }
                else
                {
                    base.ViewBag.Msg = "账号密码错误";
                }
            }
            else
            {
                base.ViewBag.Msg = "验证码错误";
            }
            return View();
        }

        public ActionResult VerifyCode()
        {
            string code = "";
            Bitmap bitmap = VerifyCodeHelper.CreateVerifyCode(out code);
            base.HttpContext.Session.SetString("CheckCode", code);
            MemoryStream stream = new MemoryStream();
            bitmap.Save(stream, ImageFormat.Gif);
            return File(stream.ToArray(), "image/gif");
        }

        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Logout()
        {
            #region Cookie
            base.HttpContext.Response.Cookies.Delete("CurrentUser");
            #endregion Cookie

            #region Session
            CurrentUser sessionUser = base.HttpContext.GetCurrentUserBySession();
            if (sessionUser != null)
            {
                this._logger.LogDebug(string.Format("用户id={0} Name={1}退出系统", sessionUser.Id, sessionUser.Name));
            }
            base.HttpContext.Session.Remove("CurrentUser");
            base.HttpContext.Session.Clear();
            #endregion Session

            #region MyRegion
            //HttpContext.User.Claims//其他信息
            HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme).Wait();
            #endregion
            return RedirectToAction("Index", "Home"); ;
        }
    }
```

`CookieSessionHelper`

```c#
 public static class CookieSessionHelper
    {
        public static void SetCookies(this HttpContext httpContext, string key, string value, int minutes = 30)
        {
            httpContext.Response.Cookies.Append(key, value, new CookieOptions
            {
                Expires = DateTime.Now.AddMinutes(minutes)
            });
        }
        public static void DeleteCookies(this HttpContext httpContext, string key)
        {
            httpContext.Response.Cookies.Delete(key);
        }

        public static string GetCookiesValue(this HttpContext httpContext, string key)
        {
            httpContext.Request.Cookies.TryGetValue(key, out string value);
            return value;
        }

        public static CurrentUser GetCurrentUserBySession(this HttpContext context)
        {
            string sUser = context.Session.GetString("CurrentUser");
            if (sUser == null)
            {
                return null;
            }
            else
            {
                CurrentUser currentUser = Newtonsoft.Json.JsonConvert.DeserializeObject<CurrentUser>(sUser);
                return currentUser;
            }
        }
    }
```

`VerifyCodeHelper.cs`

```c#
public class VerifyCodeHelper
    {
        public static Bitmap CreateVerifyCode(out string code)
        {
            //建立Bitmap对象，绘图
            Bitmap bitmap = new Bitmap(200, 60);
            Graphics graph = Graphics.FromImage(bitmap);
            graph.FillRectangle(new SolidBrush(Color.White), 0, 0, 200, 60);
            Font font = new Font(FontFamily.GenericSerif, 48, FontStyle.Bold, GraphicsUnit.Pixel);
            Random r = new Random();
            string letters = "ABCDEFGHIJKLMNPQRSTUVWXYZ0123456789";

            StringBuilder sb = new StringBuilder();

            //添加随机的五个字母
            for (int x = 0; x < 5; x++)
            {
                string letter = letters.Substring(r.Next(0, letters.Length - 1), 1);
                sb.Append(letter);
                graph.DrawString(letter, font, new SolidBrush(Color.Black), x * 38, r.Next(0, 15));
            }
            code = sb.ToString();

            //混淆背景
            Pen linePen = new Pen(new SolidBrush(Color.Black), 2);
            for (int x = 0; x < 6; x++)
                graph.DrawLine(linePen, new Point(r.Next(0, 199), r.Next(0, 59)), new Point(r.Next(0, 199), r.Next(0, 59)));
            return bitmap;
        }
    }
```

`Login.cshtml`

```cshtml
@model AspNetCore31.Jumpstart.Models.CurrentUser
@{
    ViewBag.Title = "登录";
}

<h2>@ViewBag.Title。</h2>
<div class="row">
    <div class="col-md-8">
        <section id="loginForm">
            @using (Html.BeginForm("Login", "Account", new { sid = "123", Account = "Eleven" },
               FormMethod.Post, true, new { @class = "form-horizontal", role = "form" }))
            {
                @Html.AntiForgeryToken()
                <h4>使用本地帐户登录。</h4>
                <hr />
                @Html.ValidationSummary(true)
                <div class="form-group">
                    @Html.LabelFor(m => m.Name, new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.TextBoxFor(m => m.Name, new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    @Html.LabelFor(m => m.Password, new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.PasswordFor(m => m.Password, new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    @Html.Label("VerifyCode", "VerifyCode", new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.TextBox("verify", "", new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    <div class="col-md-10">
                        <img id="img_code" alt="验证码图片" class="img"  src="/Account/VerifyCode" title="点击刷新">
                    </div>
                </div>
                <div class="form-group">
                    <div class="col-md-offset-2 col-md-10">
                        <input type="submit" value="登录" class="btn btn-default" />
                        @base.ViewBag.Msg
                    </div>
                </div>
            }
        </section>
    </div>
</div>
```

`_LoginPartial.cshtml`

```cshtml
@using AspNetCore31.Jumpstart.Models;
@using AspNetCore31.Jumpstart.Utility;
@{
    CurrentUser currentUser = base.Context.GetCurrentUserBySession();
    /*var currentUser = base.Context.User.Identity.Name == null ? null : new CurrentUser()
    {
        Name = base.Context.User.Identity.Name
    };*/
}
@if (currentUser != null)
{
    using (Html.BeginForm("Logout", "Account", FormMethod.Post, new { id = "logoutForm", @class = "navbar-right" }))
    {
        @Html.AntiForgeryToken()

        <ul class="nav navbar-nav navbar-right">
            <li>
                @Html.ActionLink("你好 " + currentUser.Name + "!", "Index", "Home", routeValues: null, htmlAttributes: new { title = currentUser.Name })
            </li>
            <li><a href="javascript:document.getElementById('logoutForm').submit()">注销</a></li>
        </ul>
    }
}
else
{
    <ul class="nav navbar-nav navbar-right">
        <li>@Html.ActionLink("登录", "Login", "Account", routeValues: null, htmlAttributes: new { id = "loginLink" })</li>
    </ul>
}

```



#### 校验

传统的登录校验的方式是：

- 在登录成功后，把当前用户信息存储在`Cookie`或`Session`中

  本例是放在`Session`中

  ```C#
  public ActionResult Login(string name, string password, string verify){
   
      //校验用户名和密码正确后，把用户信息存储在Cookie或Session中 
      CurrentUser currentUser = new CurrentUser()
                  {
                      Id = 123,
                      Name = "KKK",
                      Account = "Administrator",
                      Email = "57265177",
                      Password = "123456",
                      LoginTime = DateTime.Now
                  };
                   base.HttpContext.Session.SetString("CurrentUser"
                     ,JsonConvert.SerializeObject(currentUser));
                  }
  ```

  

- 创建一个Filter（本例为：`CustomCheckLoginActionFilter`），用于检测是否登录，如果未登录，跳转至登录页

  ```C#
      public class CustomCheckLoginActionFilter : ActionFilterAttribute
      {
          #region Identity
          private readonly ILogger<CustomCheckLoginActionFilter> _logger;
          private readonly IModelMetadataProvider _modelMetadataProvider;
          public CustomCheckLoginActionFilter(Microsoft.Extensions.Logging.ILogger<CustomCheckLoginActionFilter> logger
              )
          {
              this._logger = logger;
          }
          #endregion
  
          public override void OnActionExecuting(ActionExecutingContext context)
          {
              CurrentUser currentUser = context.HttpContext.GetCurrentUserBySession();
              if (currentUser == null)
              {
                  //if (this.IsAjaxRequest(context.HttpContext.Request))
                  //{ }
                  context.Result = new RedirectResult("~/Account/Login");
              }
              else
              {
                  this._logger.LogDebug($"{currentUser.Name} 访问系统");
              }
          }
          private bool IsAjaxRequest(HttpRequest request)
          {
              string header = request.Headers["X-Requested-With"];
              return "XMLHttpRequest".Equals(header);
          }
      }
  ```

- 在需要登录才能访问的`Controller`或`Action`放置`CustomCheckLoginActionFilter`

  ```C#
      [TypeFilter(typeof(CustomCheckLoginActionFilter))]
      public class NeedLoginController : Controller
      {
          public IActionResult Index()
          {
              return View();
          }
      }
  ```

   

### 5.6.2 Asp.Net Core的认证模型

《Asp.Net Core 3 框架揭秘》第19章

> 认证是一个旨在确认请求访问这真实身份的过程，与认证相关的还有其它两个基本的操作--登录和注销。要真正理解认证、登录和注销这个3个核心的操作本，就需要对Asp.Net Core 采用的基本“票据”的认证机制有基本的了解。
>
> Asp.Net Core应用的认证实现在一个名为`AuthenticationMiddleware`的中间件中，该中间件在处理分发给它的请求时，会按照指定的认证方案(Authentication Scheme）从请求中提取能够验证用户真实身份的数据，我们一般将该数据成为安全令牌（Security Token）。Asp.Net Core 应用下的安全令牌被称为认证票据（Authentiaction Ticket），所以Asp.Net Core应用采取的是基于票据的认证方式



#### 基于Cookie的认证

##### 启用认证中间件`AddAuthentication`

下面我们采用Asp.Net Core提供的基于Cookie的认证方案。顾名思义，该认证方案采用Cookie来携带认证票据。

添加`AddAuthentication`认证中间件

并且通过` AuthenticationBuilder`的扩展放`AddCookie`使用`Cookie`认证方案

```C#
 public class Startup
 {
         public void ConfigureServices(IServiceCollection services)
        {
            //........
             
            //添加认证中间件
            services.AddAuthentication(options =>
            {
                //设置默认的认证方案
                options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme; //"返回Cookes，Cookie认证方案的默认方案名称"
            }).AddCookie(options => //使用Cookie认证方案
            {
                options.LoginPath = new PathString("/Account/Login"); // 登录地址
                options.AccessDeniedPath = new PathString("/Home/Privacy"); //没有授权跳转页面
            });
             
            //......
```

使用认证中间件

```C#
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
        {
            //......
            app.UseRouting();
            app.UseAuthentication(); //认证：检测是否登录、登录者是谁？并赋值给HttpContext.User
            //......
```

##### 登录

检测用户和和密码都正确后，使用`HttpContext.SignInAsync()`方法进行登录操作

```C#
    public class AccountController : Controller
    {        public ActionResult Login(string name, string password, string verify)
        {
            string verifyCode = base.HttpContext.Session.GetString("CheckCode");
            if (verifyCode != null && verifyCode.Equals(verify, StringComparison.CurrentCultureIgnoreCase))
            {
                if ("KKK".Equals(name) && "123456".Equals(password))
                {
                    var claims = new List<Claim>()
                                        {
                                            new Claim(ClaimTypes.Name,name),
                                            new Claim("password",password),//可以写入任意数据
                                            new Claim("Account","Administrator")
                                        };
                    var userPrincipal = new ClaimsPrincipal(new ClaimsIdentity(claims, "Customer"));

                    //cookie认证方案:CookieAuthenticationDefaults.AuthenticationScheme
                    //--用户信息:userPrincipal
                    //---过期时间:ExpiresUtc
                    HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, userPrincipal, new AuthenticationProperties
                    {
                        ExpiresUtc = DateTime.UtcNow.AddMinutes(30),
                    }).Wait();//没用await

                    return base.Redirect("/Home/Index");
                }
                else
                {
                    base.ViewBag.Msg = "账号密码错误";
                }
            }
            else
            {
                base.ViewBag.Msg = "验证码错误";
            }
            return View();
        }
```

上述代码，创建一个类型为`ClaimsPrincipal`的对象，用于存储基于声明（Claim）的用户信息，

```C#
               var claims = new List<Claim>()
                                        {
                                            new Claim(ClaimTypes.Name,name),
                                            new Claim("password",password),//可以写入任意数据
                                            new Claim("Account","Administrator")
                                        };
                var userPrincipal = new ClaimsPrincipal(new ClaimsIdentity(claims, "Customer"));
```

在登录时，在`HttpContext.SignInAsync()`方法中传入,因为在之前使用了认证中间

```C#
app.UseAuthentication(); //认证：检测是否登录、登录者是谁？并赋值给HttpContext.User
```

认证中间件会将其自动将用户信息保存在`HttpContext.User.Identity`,

登录成功后，可以通过

```c#
     var currUser = HttpContext.User.Identity;
```

获取当前用户的信息，

##### 使用认证

**授权通过`[Authorize]`属性控制，当没有任何参数时，它只检查用户身份通过身份认证（Authentication）**

```C#
//[TypeFilter(typeof(CustomCheckLoginActionFilter))]
[Authorize]
public class NeedLoginController : Controller
{
    public IActionResult Index()
    {
        var currUser = HttpContext.User.Identity.Name;
        return View();
    }
} 
```


##### 注销

注销操作使用的是` HttpContext.SignOutAsync()`方法：

```C#
        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Logout()
        {
            //HttpContext.User.Claims//其他信息
            HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme).Wait();
            return RedirectToAction("Index", "Home"); 
        }
```

其中，第一个参数需要传入认证方案的名称，即：字符串常量`CookieAuthenticationDefaults.AuthenticationScheme`（字符串为：Cookies）



### 5.6.3 基于Session、Cookie认证的局限性

基于Session、Cookie的认证无做跨多个实例进行身份认证，即：无法做分布式认证。

解决方案是：使用Token模式

从一个认证服务器中获取token，再使用token访问站点的多个实例。



## 5.7 EntityFrameworkCore

### 5.7.1 使用方式

#### 常规使用new 

在方法`OnConfiguring`中配置连接字符串

```C#
    public partial class JDDbContext : DbContext
    {
        public JDDbContext()
        {
        }
        
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            var builder = new Microsoft.Extensions.Configuration.ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile("appsettings.json");
            var configuration = builder.Build();
            var conn = configuration.GetConnectionString("JDDbConnection");
            
            optionsBuilder.UseSqlServer(conn);
         }
    }

```

使用

```C#
            using (JDDbContext context = new JDDbContext())
            {
                var user = context.Set<User>().First(u => u.Id > 1);
                base.ViewBag.UserName = user.Name;
            }

```



#### DI容器注入

- 定义

```C#
        public JDDbContext(DbContextOptions options) : base(options)
        {
            Console.WriteLine("This is JDDbContext DbContextOptions");
        }
```

**注意：重点指定DbContextOptions有外部配置**

- 使用

> AddDbContext:
>
> Registers the given context as a service in the Microsoft.Extensions.DependencyInjection.IServiceCollection.
>  You use this method when using dependency injection in your application, such
>   as with ASP.NET. For more information on setting up dependency injection, see
>    http://go.microsoft.com/fwlink/?LinkId=526890.

```C#
        public void ConfigureServices(IServiceCollection services)
        {
              //...
            
              services.AddEntityFrameworkSqlServer()
                  .AddDbContext<JDDbContext>(options =>
                  {
                      //读取配置文件中的链接字符串
                      options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection")
                          );  
                  });
        }
```

或

- 定义

```c #
        public JDDbContext(DbContextOptions<JDDbContext> options) : base(options)
        {
            Console.WriteLine("This is JDDbContext DbContextOptions");
        }
```

注意：参数是泛型参数`DbContextOptions<JDDbContext> options`

- 依赖注入

`AddDbContext()`

```C#
            services.AddDbContext<JDDbContext>(options =>
            {
                options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection"));
            });
```

或者`AddDbContextPool()`提供线程池

```c#
            //提供了数据库连接池（DbContextPool）,推荐使用
            services.AddDbContextPool<JDDbContext>(options =>
            {
                options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection"));
            });
```



- 使用

  ```C#
      public class NeedLoginController : Controller
      {
          private readonly JDDbContext _dbContext ;
          public NeedLoginController(JDDbContext jdDbContext)
          {
              _dbContext = jdDbContext;
          }
  
          public IActionResult Index()
          {
              ...
              var user = _dbContext.Set<User>().First(u => u.Id > 1);
  
              return View();
          }
      }
  ```

  

# 6.微服务架构

## 6.1 单体架构

单体应用时代：应用程序就是一个项目，在一个进程里面运行

### 优点

- 开发简单，集中管理，没有分布式的损耗

### 缺点

- 不好维护，升级困难，无法快捷迭代
- 稳定性差



## 6.2 微服务架构

微服务架构（Microservice Architecture）是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。

概念：把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

定义：围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

本质：用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。



### 与其他架构对比

#### 单体

![1612423180189](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423180189.png)



#### 垂直拆分

![1612423198812](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423198812.png)



#### 分布式服务-微服务

![1612423264050](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423264050.png)



#### SOA

![1612422941408](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612422941408.png)

SOA是为重用，微服务架构是为了重写

SOA更水平，微服务是垂直的

SOA自上而下，微服务自下而上



### 践行微服务

#### 服务通信

![1612423030691](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423030691.png)



![1612423062188](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423062188.png)

![1612423076170](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423076170.png)

   

#### 网关

说到微服务架构，就是网关必须有

![1612423125853](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423125853.png)



## 6.3 跨域

跨域是浏览器的限制行为,后台App直接调用WebApi无跨越问题,即：

跨域问题是前端，后台无跨域一说



### 跨域问题的解决

- UseCors

- 在`Controller`的方法中

  ```C#
     [Route("api/[controller]/[action]")]
      [ApiController]
      public class UsersController : ControllerBase
      {
                   [HttpGet]
  
          public Users GetUserByID(int id)
          {
              c
              //throw new Exception("1234567");
              string idParam = base.HttpContext.Request.Query["id"];
              var user = _userList.FirstOrDefault(users => users.UserID == id);
              if (user == null) 
              {
                  throw new HttpResponseException(HttpStatusCode.NotFound);
              }
              return user;
  
          }
  ```

  在Http请求头添加

  ```C#
  base.HttpContext.Response.Headers.Add("Access-Control-Allow-Origin", "*");//允许跨域
  ```

  

## 6.4 多实例运行

```powershell
dotnet ApsNetCoreWebApi.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet ApsNetCoreWebApi.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet ApsNetCoreWebApi.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```



## 6.5 Consul

课程：[Course 11、12]

多个服务实例运行后，如何管理？服务注册和发现

- Nginx

  可以屏蔽服务实例细节
  单纯是负载均衡
  **被动获取实例，有变化是不知道**

  

- Consul

  负载均衡(屏蔽实例细节)
  **服务注册与发现**
  健康检查

### 下载运行

官网：https://www.consul.io/

命令行启动：

在cmd（powershell不行）

```powershell
consul_1.6.2.exe agent –dev
```

浏览器访问：
http://localhost:8500



### WebAPI进行注册

Nuget安装 Consul 包，然后进行服务注册

```C#
    public void ConfigureServices(IServiceCollection services)
    {
        this.Configuration.ConsulRegist(); //实例启动时执行，且只执行一次
    }
```

`ConsulHelper.cs`

```C#
    /// <summary>
    /// 自己封装的注册类
    /// </summary>
    public static class ConsulHelper
    {
        public static void ConsulRegist(this IConfiguration configuration)
        {
            ConsulClient client = new ConsulClient(c =>
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);//命令行参数必须传入
            //int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
            client.Agent.ServiceRegister(new AgentServiceRegistration()
            {
                ID = $"serive:{port}", //"service" + Guid.NewGuid(),//唯一的
                Name = "ZhaoxiUserService",//组名称-Group
                Address = ip,//其实应该写ip地址
                Port = port,//不同实例
                //Tags = new string[] { weight.ToString() },//标签
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
            });
            Console.WriteLine($"http://{ip}:{port}完成注册");
        }
    }
```

其中，

配置心跳地址：

```C#
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
```



参数`HTTP`设置心跳地址，即会定时访问`HealthController`的`Index`方法:

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class HealthController : ControllerBase
    { 
        private readonly ILogger<HealthController> _logger;
        private readonly IConfiguration _iConfiguration;
        public HealthController(ILogger<HealthController> logger, IConfiguration configuration)
        {
            _logger = logger;
            this._iConfiguration = configuration;
        }

        [HttpGet]
        [Route("Index")]//拼接到控制器上的route
        public IActionResult Index()
        {
            this._logger.LogWarning($"This is HealthController {this._iConfiguration["Port"]}");
            return Ok();//HttpStatusCode--200
        }
    }
```

参数`DeregisterCriticalServiceAfter`是设置无响应后时间后把对应的服务移除



开启多个服务实例：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

http://localhost:8500/ui/dc1/services

![1612513019583](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612513019583.png)



### 客户端发现服务

在客户端web项目中，应用引用`Consual`包。

```C#
    public class TestController : Controller
    {
        public IActionResult Info()
        {
            List<Users> userList = new List<Users>();
            string resultUrl = null;
            
            #region 通过consul去发现这些服务地址
            {
                using (ConsulClient client = new ConsulClient(c =>
                {
                    c.Address = new Uri("http://localhost:8500/");
                    c.Datacenter = "dc1";
                }))
                {
                    var dictionary = client.Agent.Services().Result.Response;
                    string message = "";
                    foreach (var keyValuePair in dictionary)
                    {
                        AgentService agentService = keyValuePair.Value;
                        this._logger.LogWarning($"{agentService.Address}:{agentService.Port} {agentService.ID} {agentService.Service}");//找的是全部服务 全部实例  其实可以通过ServiceName筛选
                        message += $"{agentService.Address}:{agentService.Port};";
                    }
                    //获取当前consul的全部服务
                    base.ViewBag.Message = message;
                }
            }
            #endregion
                  
            base.ViewBag.Users = userList;
            base.ViewBag.Url = resultUrl;
            return View();
    }
```



访问客户端：https://localhost:44360/Test/Info，输出如下：

```html
127.0.0.1:5728;127.0.0.1:5727;127.0.0.1:5726;
```

解决了服务的注册和发现的问题，服务的IP和端口改变了也不会影响到客户端的访问，因为**客户端是通过访问统一的地址**：

```C#
string url = "http://ZhaoxiUserService/api/users/get";
```

来访问API，同时这样也起到的负载均衡的作用:

```C#
        private static int iSeed = 0;//没考虑溢出问题

        public IActionResult Info()
        {
            List<Users> userList = new List<Users>();
            string resultUrl = null;

            #region 调用---负载均衡
            {
                //string url = "http://localhost:5726/api/users/get";
                //string url = "http://localhost:5727/api/users/get";
                //string url = "http://localhost:5728/api/users/get";
                string url = "http://ZhaoxiUserService/api/users/get";
                //consul解决使用服务名字 转换IP:Port----DNS

                Uri uri = new Uri(url);
                string groupName = uri.Host;
                using (ConsulClient client = new ConsulClient(c =>
                {
                    c.Address = new Uri("http://localhost:8500/");
                    c.Datacenter = "dc1";
                }))
                {
                    var dictionary = client.Agent.Services().Result.Response;
                    var list = dictionary.Where(k => k.Value.Service.Equals(groupName, StringComparison.OrdinalIgnoreCase));//获取consul上全部对应服务实例
                    KeyValuePair<string, AgentService> keyValuePair = new KeyValuePair<string, AgentService>();
                    //拿到3个地址，只需要从中选择---可以在这里做负载均衡--
                    //{
                    //    keyValuePair = list.First();//直接拿的第一个
                    //}
                    //{
                    //    var array = list.ToArray();
                    //    //随机策略---平均策略
                    //    keyValuePair = array[new Random(iSeed++).Next(0, array.Length)];
                    //}
                    //{
                    //    var array = list.ToArray();
                    //    //轮询策略---平均策略
                    //    keyValuePair = array[iSeed++ % array.Length];
                    //}
                    {
                        //权重---注册服务时指定权重，分配时获取权重并以此为依据
                        List<KeyValuePair<string, AgentService>> pairsList = new List<KeyValuePair<string, AgentService>>();
                        foreach (var pair in list)
                        {
                            int count = int.Parse(pair.Value.Tags?[0]);
                            for (int i = 0; i < count; i++)
                            {
                                pairsList.Add(pair);
                            }
                        }
                        keyValuePair = pairsList.ToArray()[new Random(iSeed++).Next(0, pairsList.Count())];
                    }
                    resultUrl = $"{uri.Scheme}://{keyValuePair.Value.Address}:{keyValuePair.Value.Port}{uri.PathAndQuery}";
                    string result = WebApiHelperExtend.InvokeApi(resultUrl);
                    userList = Newtonsoft.Json.JsonConvert.DeserializeObject<List<Users>>(result);
                }
            }
            #endregion
            base.ViewBag.Users = userList;
            base.ViewBag.Url = resultUrl;
            return View();
        }
```

访问客户端：https://localhost:44360/Test/Info，

### 权重

API启动时，添加自定义参数 `--weight=8` 增加该服务(端口为：5728）的权重，

```C#
 dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728 --weight=8
```

在**API项目**中，Program.cs，

```C#
        public static void Main(string[] args)
        {
            var config = new ConfigurationBuilder()
             .SetBasePath(Directory.GetCurrentDirectory())
             .AddCommandLine(args)//支持命令行
             .Build();

            CreateHostBuilder(args).Build().Run();
        }
```

添加对命令行的支持，以便在`IConfiguration`能根据

```C#
configuration["weight"]
```

获取参数。

在**注册服务**时：

```C#
    public static class ConsulHelper
    {
        public static void ConsulRegist(this IConfiguration configuration)
        {
            ConsulClient client = new ConsulClient(c =>
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);//命令行参数必须传入
            int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
            client.Agent.ServiceRegister(new AgentServiceRegistration()
            {
                ID = $"serive:{port}", //"service" + Guid.NewGuid(),//唯一的
                Name = "ZhaoxiUserService",//组名称-Group
                Address = ip,//其实应该写ip地址
                Port = port,//不同实例
                Tags = new string[] { weight.ToString() },//标签
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
            });
            Console.WriteLine($"http://{ip}:{port}完成注册");
        }
    }
}
```

获取参数`--weigh`,

```C#
int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
```

**放入`Tags`字段中**

```C#
Tags = new string[] { weight.ToString() },//标签
```



**客户端**调用时，**通过`Tags`获取`--weigh`值**，然后根据该值设置权重策略

```C#
                    //权重---注册服务时指定权重，分配时获取权重并以此为依据
                    List<KeyValuePair<string, AgentService>> pairsList = new List<KeyValuePair<string, AgentService>>();
                    foreach (var pair in list)
                    {
                        int count = int.Parse(pair.Value.Tags?[0]);
                        for (int i = 0; i < count; i++)
                        {
                            pairsList.Add(pair);
                        }
                    }
                    keyValuePair = pairsList.ToArray()[new Random(iSeed++).Next(0, pairsList.Count())];
                    resultUrl = $"{uri.Scheme}://{keyValuePair.Value.Address}:{keyValuePair.Value.Port}{uri.PathAndQuery}";
                    string result = WebApiHelperExtend.InvokeApi(resultUrl);
```

![1612512970399](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612512970399.png)

根据权重, 比如，3个API地址权重分别是：1, 1, 8，生成10个`AgentService`,存放在临时列表`pairsList`中，然后取列表下标的随机数。其中有8个端口是5278的服务API，它的命中概率最大，这样就实现权重策略。



## 6.6 Ocelot

课程：[Course12]

### Gateway(网关)



**为什么需要网关？**
        有了Consul，使用服务名即可访问。但手机、web端等外部访问者仍然需要和N多服务器交互，需要记忆他们的服务器地址、端口号等。一旦内部发生修改，很麻烦，而且有时候内部服务器是不希望外界直接访问的—需要路由功能！

​        网关的最核心功能就是路由

### 网关的功能

- 路由---核心功能
- 集群负载均衡

实现了客户端和服务实例的隔绝—保护—节约IP—提高效率

网关本身也可以做集群（用Nigx）



**好处**：

- 各个业务系统轻松独立维护服务器；
- 复用权限校验；
- 限流、熔断、降级、收费等。



### Ocelot

Ocelot就是一个提供了请求路由、安全验证等功能的API网关微服务



#### 搭建网关

独立进程，完成网关代请求：

1 独立webapi程序(3.1)
2 nuget-ocelot
3 startup配置中间件
4 配置文件

5.运行

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```



**新建一个[WebApi]模板项目，添加以下包**：

```xml
    <PackageReference Include="Ocelot" Version="13.8.0" />
```

 **替换所有的中间件**：

```C#
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddOcelot();
            //services.AddControllers();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            app.UseOcelot();
            //if (env.IsDevelopment())
            //{
            //    app.UseDeveloperExceptionPage();
            //}

            //app.UseHttpsRedirection();

            //app.UseRouting();

            //app.UseAuthorization();

            //app.UseEndpoints(endpoints =>
            //{
            //    endpoints.MapControllers();
            //});
        }
    }
```

**配置Ocelot**,

```json
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                 .ConfigureAppConfiguration(c =>
                 {
                     c.AddJsonFile("configuration.json", optional:  false,  reloadOnChange: true);
                 })
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
    }
```

`configuration.json`

```json
////*****************************单地址********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } //可以多个，自行负载均衡
      ],
      "UpstreamPathTemplate": "/T5726/{url}", //网关地址--url变量   //冲突的还可以加权重Priority
      "UpstreamHttpMethod": [ "Get", "Post" ]
    }
  ]
}
```

- Downstream:下游，API方

- Upstream：上游，，客户端方，调用方

  

上面的配置可以通俗的解读为:

客户端调用`/T5726/{url}`, 网关将访问映射为：`http://locahost:5726/api/{url}`



**运行**：

启动API：

```C#
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
```

这个接口有数据：http://localhost:5726/api/users/get,返回：

```json
[{"userID":1,"userName":"User-01","userEmail":null},{"userID":2,"userName":"User-02","userEmail":null},{"userID":3,"userName":"User-03","userEmail":null},{"userID":4,"userName":"User-04","userEmail":null},{"userID":5,"userName":"User-05","userEmail":null},{"userID":6,"userName":"User-06","userEmail":null}]
```



启动网关：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

访问网关：

```powershell
http://localhost:6299/T5726/users/get
```

返回：

```json
[{"userID":1,"userName":"User-01","userEmail":null},{"userID":2,"userName":"User-02","userEmail":null},{"userID":3,"userName":"User-03","userEmail":null},{"userID":4,"userName":"User-04","userEmail":null},{"userID":5,"userName":"User-05","userEmail":null},{"userID":6,"userName":"User-06","userEmail":null}]
```



#### 配置多个API实例

修改配置文件`configuration.json`

```json
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } //可以多个，自行负载均衡
      ],
      "UpstreamPathTemplate": "/T5726/{url}", //网关地址--url变量   //冲突的还可以加权重Priority
      "UpstreamHttpMethod": [ "Get", "Post" ]
    },
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5727 //服务端口
        }
      ],
      "UpstreamPathTemplate": "/T5727/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ]
    },
   {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5728 //服务端口
        }
      ],
      "UpstreamPathTemplate": "/T5728/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ]
    }
  ]
}
```

新增2个端口：5727和5728两个端口的 API

开启3个API：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

重启网关：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

访问3个地址都有数据：

```powershell
http://localhost:6299/T5726/users/get
http://localhost:6299/T5727/users/get
http://localhost:6299/T5728/users/get
```



#### 单地址访问多API

上一节配置多个API实例的时候，客户端还是的访问多个地址，获取数据：

```powershell
http://localhost:6299/T5726/users/get
http://localhost:6299/T5727/users/get
http://localhost:6299/T5728/users/get
```

那如何实现单地址访问多个API的目标，

修改配置文件`configuration.json`

```json
//*****************************单地址多实例负载均衡********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } //可以多个，自行负载均衡
        ,
        {
          "Host": "localhost",
          "Port": 5727 //服务端口
        },
        {
          "Host": "localhost",
          "Port": 5728 //服务端口
        }
      ],
      "UpstreamPathTemplate": "/T5/{url}", //网关地址--url变量   //冲突的还可以加权重Priority
      "UpstreamHttpMethod": [ "Get", "Post" ],
      "LoadBalancerOptions": {
        "Type": "RoundRobin" //轮询      LeastConnection-最少连接数的服务器   NoLoadBalance不负载均衡
      }
    }
  ]
}
```

重启网关：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

单地址访问多API, 并**实现了负载均衡**

```powershell
http://localhost:6299/T5/users/get
```



#### Ocelot+Consul



整合网关和服务注册发现
调用者只负责调用网关
网关去跟Consul交互
**Consul维护实例，Consul—完成了集群管理，发现—健康检查—下线**



运行Consul：

```powershell
consul_1.6.2.exe agent –dev
```



运行3个API服务：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

访问下http://localhost:5726/api/users/get，检查是否返回数据，有数据，说明服务启动成功



查看Consul中发现的服务:http://localhost:8500

![1612513040343](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612513040343.png)

配置Ocelot:

[*.MicroServiceGateway]项目的配置文件 `configuration.json`修改为：

```Json
////*****************************单地址多实例负载均衡+Consul********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "UpstreamPathTemplate": "/TConsul/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ],
      "ServiceName": "ZhaoxiUserService", //consul服务名称
      "LoadBalancerOptions": {
        "Type": "RoundRobin" //轮询      LeastConnection-最少连接数的服务器   NoLoadBalance不负载均衡
      },
      "UseServiceDiscovery": true
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": "http://127.0.0.1:6299", //网关对外地址
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul" //由Consul提供服务发现
    }
  }
}
```

重点是`"UseServiceDiscovery": true`表明使用服务自动发现，而不是像之前那样写死：

```json
"DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } ,
                ,
        {
          "Host": "localhost",
          "Port": 5727 //服务端口
        },
        {
          "Host": "localhost",
          "Port": 5728 //服务端口
        }
      ]
```



至于如何发现，在配置节点`GlobalConfiguration`进行配置：

```json
"GlobalConfiguration": {
    "BaseUrl": "http://127.0.0.1:6299", //网关对外地址
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul" //由Consul提供服务发现
    }
  }
```

使用`Consul`（其地址：localhost:8500）提供API服务地址，对外的网关地址为：http://127.0.0.1:6299



此时，要Ocelot中使用Consul，需要在网关项目中引用包：

```xml
   <PackageReference Include="Ocelot.Provider.Consul" Version="13.8.0" />
```

并添加Consul支持：

```C#
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddOcelot().AddConsul(); 
        }
```

启动网关项目：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

访问地址：http://localhost:6299/TConsul/users/get，返回数据：

```json
[{"userID":1,"userName":"User-01","userEmail":null},{"userID":2,"userName":"User-02","userEmail":null},{"userID":3,"userName":"User-03","userEmail":null},{"userID":4,"userName":"User-04","userEmail":null},{"userID":5,"userName":"User-05","userEmail":null},{"userID":6,"userName":"User-06","userEmail":null}]
```



至此，我们可得到**OCelot+Consul**的好处：

- **客户端不用管理API地址，仅仅是通过一个网关地址：http://localhost:6299/TConsul/users/get 即可**
- **负载均衡：刷新页面，会发现依次轮询3个API服务**
- **API服务器的健康检查，下线和重新上线**



####   

**Polly**是一种.NET弹性和瞬态故障处理库，允许我们以非常顺畅和线程安全的方式来执诸如行恢复等策略。
重试，断路，超时，故障

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612522693907.png" alt="1612522693907" style="zoom:33%;" />

**缓存**---可以有效提升性能
**限流**---限制了单位时间内的访问量(失败一部分比垮掉强)
**熔断**---保险丝，单位时间错误超过多少就直接停掉，多长时间后再恢复
           合并请求



要Ocelot中使用Polly，需要在网关项目中引用包：

```xml
  <PackageReference Include="Ocelot.Provider.Polly" Version="13.8.0" />
```

并添加Polly支持：

```C#
        public void ConfigureServices(IServiceCollection services)
        {
               services.AddOcelot().AddConsul().AddPolly();
        }
```

添加配置文件：

```json
//*****************************单地址多实例负载均衡+Consul+Polly********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "UpstreamPathTemplate": "/consul/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ],
      "ServiceName": "ZhaoxiUserService", //consul服务名称
      "LoadBalancerOptions": {
        "Type": "RoundRobin" //轮询      LeastConnection-最少连接数的服务器   NoLoadBalance不负载均衡
      },
      "UseServiceDiscovery": true,
      "QoSOptions": {
        "ExceptionsAllowedBeforeBreaking": 3, //允许多少个异常请求
        "DurationOfBreak": 10000, // 熔断的时间，单位为ms
        "TimeoutValue": 10000 //如果下游请求的处理时间超过多少则自如将请求设置为超时 默认90秒
      }
      //"RateLimitOptions": {
      //  "ClientWhitelist": [], //白名单
      //  "EnableRateLimiting": true,
      //  "Period": "5m", //1s, 5m, 1h, 1d  jeffzhang
      //  "PeriodTimespan": 5, //多少秒之后客户端可以重试
      //  "Limit": 5 //统计时间段内允许的最大请求数量
      //},
      //"FileCacheOptions": {
      //  "TtlSeconds": 10
      //} //"缓存"
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": "http://127.0.0.1:6299", //网关对外地址
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul" //由Consul提供服务发现
    },
    //"RateLimitOptions": {
    //  "QuotaExceededMessage": "Too many requests, maybe later? 11", // 当请求过载被截断时返回的消息
    //  "HttpStatusCode": 666 // 当请求过载被截断时返回的http status
    //}
  }
```

启动网关项目：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

**启动后，为了测试各个功能，可以直接修改配置文件，配置能动态生效，不用重启程序**

访问测试数据地址：http://localhost:6299/Consul/users/get，



配置节点说明：

##### 缓存

```C#
      "FileCacheOptions": {
        "TtlSeconds": 10
      } //"缓存"
    }
```

 缓存数据10秒



##### 限流

限制了单位时间内的访问量(失败一部分比垮掉强)

```json
{
  "ReRoutes": [
    {
      //......,
      "RateLimitOptions": {
        "ClientWhitelist": [], //白名单
        "EnableRateLimiting": true,
        "Period": "5m", //1s, 5m, 1h, 1d  jeffzhang
        "PeriodTimespan": 10, //多少秒之后客户端可以重试
        "Limit": 3 //统计时间段内允许的最大请求数量
      },
     //......,
        
    }
  ],
   //......,
    "RateLimitOptions": {
      "QuotaExceededMessage": "Too many requests, maybe later? 11", // 当请求过载被截断时返回的消息
      "HttpStatusCode": 666 // 当请求过载被截断时返回的http status
    }
  }
}
```

> 特别注意：
>
> 为了方便测试，把缓存的配置节点`FileCacheOptions`注释掉。



上面的配置可以解读为：

每5秒内（"Period": "5m"），最多能请求3次（ "Limit": 3），第4次的请求时，返回状态码：666，并有提示信息：“Too many requests, maybe later? 11”，

等待10秒（"PeriodTimespan": 10）后，又可以在5秒内请求3次，依次反复。



一直刷新页面，3次后请求失败，返回自定义的状态码：666

![1612524816784](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612524816784.png)

![1612525179225](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612525179225.png)

等待10秒后，又可以访问3次。



##### 熔断（QoS）

​         保险丝，单位时间错误超过多少就直接停掉，多长时间后再恢复合并请求



为了测试，我们在API项目中定义一个会抛出异常的接口方法：

```C#
    [Route("api/[controller]/[action]")]
    [ApiController]
    public class UsersController : ControllerBase
    {
        [HttpGet]
        public IEnumerable<Users> GetExcetion()
        {
            this._logger.LogWarning($"{DateTime.Now.ToString("HH:mm:ss fff")} {this.GetType()} GetExcetion......");
            throw new Exception();
        }
    }
```



设置配置文件：

```json
      "QoSOptions": {
        "ExceptionsAllowedBeforeBreaking": 3, //允许多少个异常请求
        "DurationOfBreak": 10000, // 熔断的时间，单位为ms
        "TimeoutValue": 10000 //如果下游请求的处理时间超过多少则自动将请求设置为超时 默认90秒
      },
```

> 为了测试不被其它配置干扰，注释掉限流的相关配置节点`RateLimitOptions`



然后访问：http://localhost:6299/Consul/users/GetExcetion

[没效果，待解决]



## 6.7  认证与授权

### 传统用户识别

基于cookie-session
是把用户信息保存在服务器，每次请求带上标识匹配资源

没有分布式架构，无法支持横向扩展。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612595395270.png" alt="1612595395270" style="zoom: 80%;" />

### Token校验

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612595455227.png" alt="1612595455227"  />





### Jwt(Json Web Token)

官网：https://jwt.io/
1 授权：这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，允许用户访问该令牌允许的路由，服务和资源。Single Sign On是一种现在广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。

2 信息交换：JSON Web令牌是在各方之间安全传输信息的好方法。因为JWT可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。



#### jwt结构

```json
Header　头
{  "alg": "HS256",  "typ": "JWT"}

Payload　有效载荷
JWT 默认是不加密的，任何人都可以读到

Signature　签名--防止抵赖-防止篡改
=HMACSHA256( base64UrlEncode(header) + "." +  base64UrlEncode(payload),  secret)
xxxxx.yyyyy.zzzzz
}
```

私钥加密，只有对应的公钥才能解密



### Jwt认证

#### API项目

在【API】项目中引用包：

```xml
 <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="3.1.1" />
```

添加Jwt认证中间件：

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region jwt校验
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,//是否验证Issuer
                    ValidateAudience = true,//是否验证Audience
                    ValidateLifetime = true,//是否验证失效时间
                    ValidateIssuerSigningKey = true,//是否验证SecurityKey
                    ValidAudience = this.Configuration["audience"],//Audience
                    ValidIssuer = this.Configuration["issuer"],//Issuer，这两项和前面签发jwt的设置一致
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(this.Configuration["SecurityKey"])),//拿到SecurityKey
                    //AudienceValidator = (m, n, z) =>
                    //{
                    //    return m != null && m.FirstOrDefault().Equals(this.Configuration["audience"]);
                    //},//自定义校验规则，可以新登录后将之前的无效
                };
            });
            #endregion
     }

   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
            #region jwt
            app.UseAuthentication();//注意添加这一句，启用验证
            #endregion   
   }

```

配置文件`appsettings`,添加如下配置节点：

```json
  "audience": "http://localhost:5726",
  "issuer": "http://localhost:5726",
  "SecurityKey": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDI2a2EJ7m872v0afyoSDJT2o1+SitIeJSWtLJU8/Wz2m7gStexajkeD+Lka6DSTy8gt9UwfgVQo6uKjVLG5Ex7PiGOODVqAEghBuS7JzIYU5RvI543nNDAPfnJsas96mSA7L/mD7RTE2drj6hf3oZjJpMPZUQI/B1Qjb5H3K3PNwIDAQAB"

```

启动API服务

新增一个控制器`UsersNewController.cs`

```C#
    [Route("api/[controller]/[action]")]
    [ApiController]
    [Microsoft.AspNetCore.Authorization.Authorize]
    public class UsersNewController : ControllerBase
    {
        [HttpGet]
        [Microsoft.AspNetCore.Authorization.AllowAnonymous]
        public Users GetUserByID(int id)
        {
           //.....
        }
    }
```

在控制器添加特性`[Authorize]`,但在`GetUserByID`Action添加特性`[AllowAnonymous]`

启动服务：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

http://localhost:5726/api/usersnew/GetUserByID?id=1可以返回数据

http://localhost:5726/api/usersnew/get,返回状态码401，未认证



#### 认证中心项目

新建一个以WebAPI模板的项目【*.AuthenticationCenter】，

配置文件：

````Json
  "audience": "http://localhost:5726",
  "issuer": "http://localhost:5726",
  "SecurityKey": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDI2a2EJ7m872v0afyoSDJT2o1+SitIeJSWtLJU8/Wz2m7gStexajkeD+Lka6DSTy8gt9UwfgVQo6uKjVLG5Ex7PiGOODVqAEghBuS7JzIYU5RvI543nNDAPfnJsas96mSA7L/mD7RTE2drj6hf3oZjJpMPZUQI/B1Qjb5H3K3PNwIDAQAB"

````



`IJWTService.cs`

```C#
    public interface IJWTService
    {
        string GetToken(string UserName);
    }
```



`JWTService.cs`

```C#
    /// <summary>
    /// 备注下：代码演示的是对称加密，所以只有一个key，在返回的信息里面是没有的
    ///         PPT介绍时，说的是非对称的，那样是把解密key公开的，前面是后台用私钥加密的，
    /// 可以保证别人解密后 拿到的数据  跟前面2部分hash后的结果一致 保证没有篡改
    ///  此外，公钥不是在返回结果，那只是个打比方~
    /// </summary>
    public class JWTService : IJWTService
    {
        private readonly IConfiguration _configuration;
        public JWTService(IConfiguration configuration)
        {
            _configuration = configuration;
        }

        public string GetToken(string UserName)
        {
            var claims = new[]
            {
               new Claim(ClaimTypes.Name, UserName),
               new Claim("NickName","Eleven"),
               new Claim("Role","Administrator"),//传递其他信息  
            };
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["SecurityKey"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            /**
             * Claims (Payload)
                Claims 部分包含了一些跟这个 token 有关的重要信息。 JWT 标准规定了一些字段，下面节选一些字段:

                iss: The issuer of the token，token 是给谁的
                sub: The subject of the token，token 主题
                exp: Expiration Time。 token 过期时间，Unix 时间戳格式
                iat: Issued At。 token 创建时间， Unix 时间戳格式
                jti: JWT ID。针对当前 token 的唯一标识
                除了规定的字段外，可以包含其他任何 JSON 兼容的字段。
             * */
            var token = new JwtSecurityToken(
                issuer: _configuration["issuer"],
                audience: _configuration["audience"],
                claims: claims,
                expires: DateTime.Now.AddMinutes(5),//5分钟有效期
                signingCredentials: creds);
            string returnToken = new JwtSecurityTokenHandler().WriteToken(token);
            return returnToken;
        }
    }
```



`Startup.cs`

```C#
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
            services.AddScoped<IJWTService, JWTService>();
        }


        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseHttpsRedirection();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
```



`AuthenticationController.cs`

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class AuthenticationController : ControllerBase
    {
        [Route("Login")]
        [HttpPost]
        public string Login(string name, string password)
        {
            if ("Eleven".Equals(name) && "123456".Equals(password))//应该数据库
            {
                string token = this._iJWTService.GetToken(name);
                return JsonConvert.SerializeObject(new
                {
                    result = true,
                    token
                });
            }
            else
            {
                return JsonConvert.SerializeObject(new
                {
                    result = false,
                    token = ""
                });
            }
        }
    }

```



启动项目:

```C#
dotnet Zhaoxi.AspNetCore31.AuthenticationCenter.dll --urls="http://*:9527" --ip="127.0.0.1" --port=9527
```



登录并获取Token：

POST  http://localhost:9527/api/Authentication/Login?name=Eleven&password=123456 

```json
{"result":true,"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiRWxldmVuIiwiTmlja05hbWUiOiJFbGV2ZW4iLCJSb2xlIjoiQWRtaW5pc3RyYXRvciIsImV4cCI6MTYxMjYwNzYzOCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2IiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2In0.r2La3mYkcJHwEMG1hU-UN7ZcltO6--SQYCgYjciGfr8"}
```

打开[https://jwt.ms/](https://jwt.ms/) 解析Jwt数据结构：

```Json
{
  "alg": "HS256",
  "typ": "JWT"
}.{
  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "Eleven",
  "NickName": "Eleven",
  "Role": "Administrator",
  "exp": 1612607638,
  "iss": "http://localhost:5726",
  "aud": "http://localhost:5726"
}.[Signature]
```



https://jwt.io/中使用私钥来验证token是否有效：

私钥：

```json
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDI2a2EJ7m872v0afyoSDJT2o1+SitIeJSWtLJU8/Wz2m7gStexajkeD+Lka6DSTy8gt9UwfgVQo6uKjVLG5Ex7PiGOODVqAEghBuS7JzIYU5RvI543nNDAPfnJsas96mSA7L/mD7RTE2drj6hf3oZjJpMPZUQI/B1Qjb5H3K3PNwIDAQAB
```

![1612608273926](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612608273926.png)





使用返回的token，添加到访问API的地址的请求头中，

GET  http://localhost:5726/api/usersnew/get 

 Authorization :

```md
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiRWxldmVuIiwiTmlja05hbWUiOiJFbGV2ZW4iLCJSb2xlIjoiQWRtaW5pc3RyYXRvciIsImV4cCI6MTYxMjYwNzYzOCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2IiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2In0.r2La3mYkcJHwEMG1hU-UN7ZcltO6--SQYCgYjciGfr8
```



![1612607558374](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612607558374.png)



## 6.8 分布式

【Course-14】

### CAP

CAP定理---分布式的入门理论

Consistency              一致性
Availability                 可用性
Partition tolerance     分区容错

分布式系统下，网络出错是必然存在的---也就是不可靠的
在分区容错一定出现的情况，C和A是不能同时满足的

**CAP是不能同时满足的！**



### 分布式事务-BASE

**Base理论：**

- Basically Available(基本可用)

- 最终一致性

- Soft state（软状态）

- Eventually consistent

  **微服务架构里面，可用性是最重要的**，因为为了保证一致性，会造成多个微服务节点阻塞，影响性能

  

  思想是最重要，指引方向



### 主要的分布式事务模式

#### 2PC

![1612616121041](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612616121041.png)



#### TCC（Try-Confirm-Cancel）

基于**Base理论** 实现的

![1612617058067](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612617058067.png)



#### 本地消息表

MQ分布式事务--本地消息表--基于消息的一致性

上游投递消息
下游获取消息
上游投递稳定性
下游接受稳定性

![1612735624126](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612735624126.png)

### 分布式跟踪

业务延迟很大，怎么定位问题？

- Butterfly
- **Skywalking**

分布式追踪和APM （应用性能管理） 的Server端，它将包含Collector，Storage，独立的Web UI，并使用Open Tracing规范来设计追踪数据

 SkyWalking 的核心是数据分析和度量结果的存储平台，通过 HTTP 或 gRPC 方式向 SkyWalking Collecter 提交分析和度量数据，SkyWalking Collecter 对数据进行分析和聚合，存储到 Elasticsearch、H2、MySQL、TiDB 等其一即可，最后我们可以通过 SkyWalking UI 的可视化界面对最终的结果进行查看 。



### 分布式日志

Exceptionless：开源的日志收集和分析框架，能为应用程序提供实时错误、特性和日志报告。



### 配置中心

**Apollo**-配置中心

微服务架构环境中，项目中配置文件比较繁杂，而且不同环境的不同配置修改相对频繁，每次发布都需要对应修改配置，如果配置出现错误，需要重新打包发布，时间成本较高，

因此需要做统一的配置中心，能做到自动更新配置文件信息



### Docker

容器部署运维



### Kubernetes

容器编排



## 6.9 架构漫谈

【Course-15-16】



### 大数据高并发（Level 1）

如何应对大数据高并发？
读写分离
负载均衡/集群
消息队列
Redis
分布式
缓存
分库分表

开放性话题，演绎下系统架构的变迁，把其中的核心环节详解下！



#### 单机系统

![1612780355050](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780355050.png)

PV/UV/IP
单机承载能力—硬件资源不够
压力测试—loadrunner

随着时间的推移，用户增多，数据增多，并发量增多了，然后服务器扛不住了，怎么办？

1 垂直扩展：升级硬件
    立竿见影，但是有上限
2 水平扩展：多来几台服务器
    一个人力气不够，多来几个人



#### 独立服务器

![1612780398289](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780398289.png)

第一次分布式：这就是分布式
分布式就是一台服务器做的事儿分成多台服务器协作完成

很轻松的提升承载能力，但是当前的划分粒度是很粗放的

分布式的第一要务就是不要使用分布式



#### 缓存

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780441581.png" alt="1612780441581" style="zoom: 80%;" />



系统性能优化的第一步就是使用缓存，成本低见效快(有弊端)

二八原则：
80%财富集中在20%人手里
80%的活儿是20%的人干了
80%的访问都集中在20%数据上
(性能优化就应该盯着大多数)

随着时间的推移，用户增多，数据增多，并发量增多了，然后服务器扛不住了，怎么办？



缓存一般解决数据库的压力，

弊端是数据延迟



缓存，立竿见影，因为直接重用结果，
降低数据库压力，提升性能
改造也特别简单，成本也低

也要注意缓存的缺点，是可能有数据延迟(过期时间)
再给出解决方案，以场景为例，证明真的用过

----应对大数据高并发，这个是第一阶段答案



#### 集群负载均衡

![1612780589469](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780589469.png)

集群：一台服务器做的事儿，现在由多台服务器共同承载，每台服务器都是独立完成的
---同一个服务有多个实例

分布式：一台服务器做的事儿分成多台服务器协作完成，每台服务器完成其中的一个部分
---微服务里面多个服务串成一个业务逻辑

其实集群也算分布式



在服务压力大，水平扩展，增强承载能力
每台服务器都能完成响应---内容是一样的(部署一台，其他FTP同步的)

**DNS负载均衡-**

可以在DNS配置多个站点响应的，由DNS决定谁来响应
负载均衡：多个选项中，按照一定的策略去选择
就近策略---轮询策略---权重策略



**服务器自己搞定负载均衡**

- 硬件派—软硬结合(服务器内置软件)—F5(解决方案)
- 软件派：
  LVS---基于四层协议---ip+port 但是不知道内容---策略有限性能高---难度大
  HAProxy---基于7层协议---Http内容—策略很丰富—配置比较难(国内少)



**Nginx**

七层协议---url-hash    ip-hash 
用户持久化问题，登录服务器1 保存session，访问服务器2不认识！
共享session：StateServer/SqlServer/Redis
会话粘滞---ip-hash—高可用有问题，分配不均匀

请求携带：

​    cookie（局限性是：客户端必须是浏览器）
​    token：每次请求携带的字符串---无状态

JWT有两种加密方式

- 对称加密(代码演示)---鉴权中心&API都有一个相同的key---加密算法.有效内容.加密前两块儿内容做签名—证明来源+没有篡改

- 非对称加密---鉴权中心是私钥做加密---加密算法.有效内容.加密前两块儿内容做签名—第三方应用首先拿公钥—解密密文+比较---证明来源+没有篡改



### 大数据高并发（Level2）

搭建过环境---知道几种策略---持久化的解决方案

#### 读写分离

![1613110690902](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613110690902.png)

数据库瓶颈：数据库读写分离
木桶理论：决定一个木桶装水能力是由最短的那块儿板
二八原则：80%的业务都是查询，20%是增删改

##### 1主库, N从库

写主库，读从库，从库订阅主库的变化，包括： 数据结构—数据都是一模一样的

**主库只能有一个**

配置经历---当下用的是发布-订阅—写作业和抄作业的区别
使用场景—代码支持—负载均衡---



**延迟，解决不了---只能扬长避短去用—(借助nosql帮忙)**

比如秒杀，先初始化数据到NoSql--增删改查都是先NoSql再到SqlServer



#### 分库分表表分区

​        从设计角度分担压力(让数据库可以水平扩展)

**垂直分库**

按业务分库—不同的服务器—降低—合理划分/通过服务交互/再来个合并库/技术手段

> 做报表肯能需要合并库



**水平分库**

每个库是一样的—数据不同---降低—合理划分/通过服务交互/再来个合并库/技术手段



#### 方向代理&CDN

![1613112683793](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613112683793.png)

继续缓存
CDN加速/缓存：阿里云
南网宿北
CDN其实是DNS提供的
DNS是互联网的第一心跳，CDN就是把数据存在离用户最近的地方
主要解决图片 视频，缓存
加快速度—减少服务器请求
反向代理：屏蔽和保护，也可以缓存一下
本地缓存+CDN+反向代理=--明天上午10点，一起来探讨缓存



#### 分布式文件系统

![1613112779758](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613112779758.png)

分布式文件服务器
图片多  视频多的
TFS  GFS  NFS
就是把多个硬盘管理成本地硬盘
可以直接读写--



#### 专项突破

![1613113404837](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613113404837.png)



专人做专事：这样才能高效！

一些特殊的业务：

比如全文检索、

秒杀：NoSql解决-队列



我就特别抗拒，让我做乱七八糟的事儿

一个系统的崩溃就是源于一个点，所以用专业的技术来解决独特的问题



#### 分布式异步队列

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E6%AD%A5%E9%98%9F%E5%88%97.png" style="zoom:50%;" />

队列是可以无处不在的，效果非常厉害，
但是成本有点高。
1 队列提升响应能力，削峰
2 高可用—服务持续响应
可扩展---业务和UI分离

不能实时反馈结果---业务妥协
还有可能失败---可以重试，人工介入—返回失败

队列还有个重要应用是分布式事务



#### 业务拆分

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/%E4%B8%9A%E5%8A%A1%E6%8B%86%E5%88%86.png)

继续拆分，垂直业务拆分
门户网站—Ask---BBS—Blog—NEW---DB组各种知识库
独立团队 独立维护 独立部署
很有效的提升承载能力

数据共享方式：
数据库---接口---队列—缓存Nosql







### 大数据高并发（Level 3）

怎么设计-怎么管理-分布式事务分布式锁
微服务实践



#### 分布式&微服务

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1.png)

又双叒叕拆，拆成独立服务+数据库，一方面可以增强承载能力，另外也复用

分布式，是有巨大成本的
分布式事务---CAP
分布式的第一要务就是不要分布式



### 总结

再问一次，如何应大数据高并发？
这是个开放问题，是个送分题，
考察技术视野—考察经验—考察思维方式
首先得分析问题所在，然后提一下常规的解决方案，然后着重强调自己的经历

你擅长什么，就移植个什么，
然后使劲儿说，技术+业务



### 大型系统

见【大型系统架构解析.xmind】



## 7 数据结构和算法



## 8 Vue

### Visual Code 插件

- Vue2 Snippets
- Vue Preview
- Vue VsCode Snippets
- Vue-beautify
- Vue-fomat



### 生命周期

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="lib/vue.min.js"></script>
</head>
<body>
    <div id="app">
        {{msg}}
    </div>
    <script>
        //MVVM => M:Model、V:View、VM:ViewModel
        var vm = new Vue({
            el:"#app",
            data:{
                msg:"Hello world"
            },
            //在Vue实例创建前触发——类似于cpu还在图纸上
            beforeCreate() {
                console.log(this.msg);
            },
            //Vue实例被创建，这是最早可以操作data、methods中数据的时候——类似于cpu已被制造
            created() {
                console.log(this.msg);
            },
            //实例挂在前触发——类似于CPU以安装到电脑上，但是电脑未开机
            beforeMount() {
                
            },
            //已被挂载，此时我们的data中的数据可以渲染到页面——类似于电脑一开机，cpu开始工作
            mounted() {

            },
            //在数据被更新时，但是虽然data中的数据被更新了，但是页面中的数据并没有被更新
            beforeUpdate() {
                console.log("beforeUpdate");
            },
            //此时data中的数据以及页面中的数据都被更新了
            updated() {
                console.log("update");
            },
            //在实例被注销时触发
            beforeDestroy() {
                console.log("beforeDestroy");
            },
            //实例已被注销时触发
            destroyed() {
                console.log("destroyed");
            },
        })
    </script>
</body>
</html>
```



### 命令

#### v-cloak

插值表达式在vue实例没有对页面进行渲染时会出现非常恶心的大括号

`v-cloak`可以在页面未渲染前不显示插值表达式的内容，比如下面的例子，在页面未被渲染时不会显示

```html
  {{msg}
```

这个插值表达式的及其内容，

```html
<body>
    <div id="app" v-cloak>
        {{msg}
    </div>
    <script>
    
            var vm = new Vue({
            el: "#app",
            data: {
                msg: "张三"
            }
        })
    </script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</body>
```



#### {{}}插值表达式和v-text

    - 区别1：插值表达式在vue实例没有对页面进行渲染时会出现非常恶心的大括号，而插值表达式不会出现这种情况。
    - 区别2：二者皆可对页面进行数据的渲染，但是差值表达式不会覆盖标签原有的内容，而v-text会替换掉被渲染标签中的内容



#### 示例一

VueCmd.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="lib/vue.min.js"></script>
</head>

<body>
    <div id="app" >
        <p>姓名：{{msg}}</p>
        <p v-text="msg2">姓名</p>
        <p v-html="msg2"></p>
        <input :type="type">
        <button @click="clickMe()">点击我</button>
    </div>
    <script>
            var vm = new Vue({
            el: "#app",
            data: {
                msg: "张三",
                msg2:"<b>李四</b>",
                type:"checkbox"
            },
            methods: {
                clickMe:function(){
                    alert();
                }
            },
        })
    </script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</body>

</html>
```

##### 

##### `{{msg}}`插值表达式

##### v-text="msg2"`

文本绑定



##### `v-html="msg2"`

会解析成html，而不是显示文本`<b>李四</b>`



##### `:type="type"`

类型绑定，界面会显示成 `checkbox `html元素



##### `@click="clickMe()"`

事件绑定，事件方法定义在`     methods:{}`对象中



#### 示例二

CheckAll.html

```html
<body>
    <div id="app">
        <input type="checkbox" @change="checkedAll" v-model="checkAll">全选
        <p v-for="user in users">
            <input type="checkbox" v-model="user.isChecked" @change="check">{{user.userName}}——{{user.isChecked}}
        </p>
    </div>
    <script>
        var vm = new Vue({
            el: "#app",
            data: {
                users: [
                    { userName: "张三", id: 1, isChecked: false },
                    { userName: "李四", id: 2, isChecked: false },
                    { userName: "王五", id: 3, isChecked: false },
                ],
                checkAll: false
            },
            methods: {
                checkedAll() {
                    this.users.forEach(element => {
                        element.isChecked = this.checkAll;
                    });
                },
                check() {
                    // if (this.users.length == this.users.filter(m => m.isChecked).length)
                    //     this.checkAll = true;
                    // else
                    //     this.checkAll = false;
                    this.checkAll = this.users.every(m => m.isChecked)
                }
            },
        })
    </script>
</body>
```



##### `v-model`

实现双向绑定，且绑定的表单html元素的`value`属性



##### `v-for`

###### :key

```html
       <p v-for="(user,index)  in users" :key="user.id">
            <input type="checkbox">{{user.userName}}——{{user.isChecked}}
       </p>
```

`:key`默认取变量`index`，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613316758290.png" alt="1613316758290" style="zoom:50%;" />

勾选`index=0`的张三，点击【AddUser】,新增一个`User`：赵六，此时勾选的是新增的赵六，而不是原来的

张三，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613317074388.png" alt="1613317074388" style="zoom:50%;" />

所以，如果有动态变化（新增或删除）的`User`，最好使用`v-for`的`:key`做好不要使用默认的`index`,而是指定`User`的唯一标识,比如`User.id`,如下代码所示：

```html
        <p v-for="(user,index)  in users" :key="user.id">
            <input type="checkbox">{{user.userName}}——{{user.isChecked}}
        </p>
```



###### 单个变量

```html
    <p v-for="(val,key,i) in user">{{val}}——{{key}}——{{i}}</p>

   user:{ userName: "张三", id: 1, isChecked: false },
```

输出：

```html
张——userName——0
```



#### if&show

```html
<body>
    <div id="app">
        <div v-if="isShow">hahaha</div>
        <div v-else>huhuhu</div>
        <div v-show="isShow">heihei</div>
    </div>
    <script>
         var vm = new Vue({
            el:"#app",
            data:{
                isShow:false
            },
        })
    </script>
</body>
```



### 样式绑定

#### :class

- 单样式绑定

```html
<p :class="'testP1'">我是P标签</p>

        .testP1{
            color:brown;
        }
        .testP2{
            color:blue;
        }
```

`'testP1'`要添加单引号，不加单引号的话会到`Vue.data`对象，显然是不对的。



- 多样式绑定

```html
<p :class="['testP1', 'testP2']">我是P标签</p>
```



- 三元表达式

  ```html
  <p :class="[isShowRed?'testP1':'testP2']">我是P标签</p>
  ```

  三元表达式放在中括号中。

  

#### :style

```html
  <p :style="[style1,style2]">我是P标签</p>
 
         var vm = new Vue({
            el: "#app",
            data:{
                style1:{color:"#fff","font-size":"18px"},
                style2:{"background-color": "brown"}
            }
        })

```

#### 

### 计算属性

​           计算属性会把结果放到缓存中

定义计算属性:

```html
<body>
    <div id="app">
        <p>{{myNum}}</p>
        <button @click="add()">+</button>
    </div>
    <script>
        var vm = new Vue({
            el: "#app",
            data: {
                num: 10
            },
            methods: {
                add: function () {
                    this.num = this.myNum + 1;
                }
            },
            computed: {
                myNum() {
                    return this.num;
                }
            }
        })
    </script>
</body>
```



### 自定义命令

```html
<body>
    <div id="app">
        <p v-ace>{{num}}</p>
    </div>
    <script>
        Vue.directive("ace",{
            bind(el,binding){
               var price = parseInt(el.innerText).toFixed(2);
               el.innerText = price;
            }
        })

        var vm = new Vue({
            el:"#app",
            data:{
                num:10
            }
        })
    </script>
</body>
```

`Vue.directive`定义自定义命令，可以获取到`Dom`对象`el`, 而`binding`包含指令的信息



### 组件

#### 全局组件

```html
<body>
    <div id="app">
        <my-header></my-header>
    </div>
    <script>
        Vue.component("my-header",{
            template:'<h1>{{msg}}</h1>',
            data(){
                return {
                    msg:"hello vue"
                }
            }
        })
        var vm = new Vue({
            el: "#app"
        })
    </script>
</body>
```



#### 局部组件

```html
<body>
    <div id="app">
        <hello></hello>
        <word></word>
    </div>
    <script>
        var vm = new Vue({
            el: "#app",
            components: {
                "hello": {
                    template: '<h2>{{msg}}</h2>',
                    data() {
                        return {
                            msg: "局部组件1"
                        }
                    }

                },
                "word": {
                    template: '<h2>{{msg}}</h2>',
                    data() {
                        return {
                            msg: "局部组件2"
                        }
                    }

                }

            }
            
        })
    </script>
</body>
```

#### 

#### 模板（template）

```html
<body>
    <div id="app">
        <word></word>
    </div>

    <template id="temp">
        <div>
            this is {{msg}}
        </div>
    </template>

    <script>

        var vm = new Vue({
            el: "#app",
            components: {
                "word": {
                    //template: '<h2>{{msg}}</h2>',
                    template:"#temp",
                    data() {
                        return {
                            msg: "局部组件2"
                        }
                    }

                }

            }
            
        })
    </script>
</body>
```



#### 组件传参

```html
<body>
    <div id="app">
        <word :param1="componentParam" param2="组件参数2"></word>
    </div>

    <template id="temp">
        <div>
            this is {{msg}} : {{param1}} , {{param2}}
        </div>
    </template>

    <script>
        Vue.component("my-header",{
            template:'<h1>{{msg}}</h1>',
            data(){
                return {
                    msg:"全局组件"
                }
            }
        })
        var vm = new Vue({
            el: "#app",
            data:{
                "componentParam":"组件参数 From vm 对象"
            },
            components: {
                "word": {
                    template:"#temp",

                    data() {
                        return {
                            msg: "局部组件2"
                        }
                    },
                    props:['param1', 'param2']
                }
            }
            
        })
    </script>
</body>
```

定义组件属性：

```json
props:['param1', 'param2']
```

传参：

```html
 <word :param1="componentParam" param2="组件参数2"></word>
```

其中，

```html
:param1="componentParam"
```

参数名前有`:`,说明参数`param1`是通过数据绑定指定值，即： 指明`param1`绑定`vm.data.componentParam`的值



#### 组件嵌套

```html
<body>
    <div id="app">
        <parent-compt></parent-compt>
    </div>

    <template id="parent-child">
        <div>
            this is {{msg}} 
            <child></child>
        </div>
    </template>

    <script>
        var vm = new Vue({
            el: "#app",
            data: {
              
            },
            components: {
                "parent-compt": {
                    template: "#parent-child",
                    data() {
                        return {
                            msg: "父组件"
                        }
                    },
                    components: {
                        //组件嵌套
                        'child': {
                            template: '<p>{{childMsg}}</p>',
                            data() {
                                return {
                                    childMsg: "组件嵌套:子组件"
                                }
                            }
                        }
                    }
                }

            }

        })
    </script>
</body>
```



#### 组件间传值



### 路由

要使用路由，得引用如下js：

```js
<script src="lib/vue-router.js"></script>
```

简单示例

```html
<body>
    <div id="app">
        <router-link to='/main'>main</router-link>
        <router-link to='/userList'>userList</router-link>
        <router-view></router-view>
    </div>

    <script>
        var main = {
            template: '<b>这是主页</b>'
        };

        var userList = {
            template: '<b>这是用户列表</b>'
        };

        var routes = [
            { path: "/",redirect:main },
            { path: "/main", component: main, name:"main" },
            { path: "/userList", component: userList, name:"userlist"}
        ];

        const router = new VueRouter({
            routes: routes
        })

        var vm = new Vue({
            el: "#app",
            router:router
        })
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    </style>
</body>
```



## 9. AspNet.Core API

[Course:31\32]

### Filter

（与5.5 相同）

### JWT

（与5.6 相同）



### 集群&负载均衡

**分布式**：一个流程线，由多个系统配合完成；
**集群**：多个服务器，每个服务器完成一整套动作

![1613488749872](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613488749872.png)



#### Nginx实操

##### WebApi

在WebApi项目中定义`NgnixController`

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class NginxController : ControllerBase
    {
        private readonly ILogger<FirstController> _logger;

        public NginxController(ILogger<FirstController> logger)
        {
            _logger = logger;
            _logger.LogInformation($"{nameof(FirstController)} 控制器被实例化~~");
        }

        private static int iCount = 0;
        private static string id = Guid.NewGuid().ToString("D");

        [HttpGet]
        [Route("GetString")]
        public string GetString()
        {
            var host = Request.Host.ToString();
            return Newtonsoft.Json.JsonConvert.SerializeObject(new
            {
                应用程序监听端口号 = $"this is {host}, Guid={id}",
                访问次数 = ++iCount
            });
        }

    }
```

然后启动三个服务器实例：

```powershell
dotnet AspNetCore.WebApi.dll --urls="http://*:10001" --ip="127.0.0.1" --port= 10001
dotnet AspNetCore.WebApi.dll --urls="http://*:10002" --ip="127.0.0.1" --port= 10002
dotnet AspNetCore.WebApi.dll --urls="http://*:10003" --ip="127.0.0.1" --port= 10003
```



访问http://localhost:10001/api/Nginx/GetString

输出：

```html
{"应用程序监听端口号":"this is localhost:10001, Guid=f5993ded-7780-4928-9331-6b2f8198d194","访问次数":1}
```



##### 下载安装配置

http://nginx.org/en/download.html

下载后，解压压缩包，比如：`F:\tmp\ngnix\nginx-1.17.8`

***特别注意，解压的路径不要放在有中文的路径中***

- 修改Nginx端口：

  打开文件`conf/nginx.conf`,将端口变成 8989：

  ```xml
      server {
          listen       8989;
          server_name  localhost;
  ```

  如果配置文件有修改，可以使用如下命名重启：

  ```powershell
  nginx -s reload
  ```

  

- 启动Ngin

  在解压的目录中，打开cmd，输入如下命名，启动Nginx.

  ```powershell
  F:\tmp\ngnix\nginx-1.17.8>start nginx.exe
  ```

  访问：http://localhost:8989/

  ![1613491094782](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613491094782.png)

  看到这个页面，表示Nginx启动成功

  

  > 将nginx安装为windows服务
  >
  > https://www.cnblogs.com/ihappycat/p/11823342.html



- 配置Nginx转发：

Location: name
Upstream: Name
Server:port

打开文件`conf/nginx.conf`,

```md
    // ......
    server {
        listen       8989;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }
```

修改为：

```md
#默认是轮询
   upstream AspNetCoreWebApi
   {
	server  localhost:10001 weight=2;
	server  localhost:10002 weight=4;
	server  localhost:10003 weight=4;
   }
 #weight=设置权重策略  但是这里是从比例上来 约等于

    server {
        listen       8989;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
	        proxy_pass  http://AspNetCoreWebApi;
            #root   html;
            #index  index.html index.htm;
        }

```

重启Nginx:

```powershell
nginx -s reload
```

访问http://localhost:8989/api/Nginx/GetString

```powershell
{"应用程序监听端口号":"this is AspNetCoreWebApi, Guid=ed31b1be-5664-46b6-9e5c-ab7f2e407a06","访问次数":2}
```

提醒：

​        注意到，通过Nginx转发后，

```C#
var host = Request.Host.ToString();
```

只不再类似为：

```powershell
localhost:10001
```

而是配置 文件中

```md
 location / {
	   proxy_pass  http://AspNetCoreWebApi;
```

中的字符串`AspNetCoreWebApi`



### 跨域

我们有时候在使用Ajax请求WebApi的时候，会爆出上面这个错误；
Access to XMLHttpRequest at 'http://localhost:64304/api/CrossDomain/GetCrossDomainData' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

产生跨域问题的根源是浏览器的同源策略，是浏览器的行为



#### (浏览器)同源策略

![1613495244563](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613495244563.png)

同源策略（Sameoriginpolicy）是一种约定，它是**浏览器**最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。
部分Html标签可以 Script Iframe img



#### 如何解决跨域问题

1   JSONP 通过浏览器标签去请求Api；避开跨域问题；
	是通过浏览器的一些指定标签<Img src>  <Script src> <frame >
	去跨域请求，获取到数据以后，可以通过一个回调函数来把数据进行	解析，然后使用数据；	
2   通过后台模拟Http请求请求Api Api提供方是一个进程；我通过后台
3   在服务器端指定允许你跨域；
	AspNetCore 内置的有这个支持跨域的程序包；
    组件支持：Microsoft.AspNetCore.Cors



#### AspNetCore解决跨域

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region 支持跨域  所有的Api都支持跨域
                
            services.AddCors(option => option.AddPolicy("AllowCors", 
             _build => _build.AllowAnyOrigin().AllowAnyMethod()));
         
            #endregion
     }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
          app.UseCors("AllowCors");
    }
  
```



## 10 IdentityServer4

参考资料：

- 生成环境秘钥：

  https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html



### 为什么需要授权

送外卖的故事：
美团-饿了么-蜂鸟-跑腿小递
很多快递要进小区(假设能进来)
小区有密码锁—能给密码吗--不行

- 假设每次进来都打电话---确认了---放行---每次都要找我

- 假设弄个临时密码(有效期短点)---假如不再点饿了么—取消密码—大家都失效

- 一人一个临时密码—临时密码找我拿的—声明自己的身份—我确认了—给你个东西(临时密码/Token)---然后你就能进来---下次你还能进来

  这里的token(带点信息)使用过程 就是授权机制



### 什么是OAuth2.0

授权机制，是一种规范/协议，制定了授权流程
解决授权问题
大家都遵守，才好沟通

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/oauth2.0-auth.png)

OAuth 就是一种授权机制。
数据所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。
系统从而产生一个短期的进入令牌（token），用来代替密码，
供第三方应用使用。

规范了下授权的流程



### Token  VS  密码

都能进入系统，丢失后都是有风险的
Token短期的，密码是长期
令牌可以取消，密码只能修改(影响全部)
Token可以控制权限，scope

OAuth，就是Token比密码安全



### OAuth2.0 四种授权

- 客户端凭证（client credentials）

- 密码式（password）

- 隐藏式（implicit）

- 授权码（authorization-code）

  

  混合式（Hybrid）

  

### IdentityServer4

[Course-40]

ASP.NET CORE量身定制
实现了OpenID Connect和OAuth2.0协议
认证授权中间件



#### QuickStart UI

https://github.com/IdentityServer/IdentityServer4.Quickstart.UI

在自己新建的`*.IdentityServer4`的认证授权项目中，引用`IdentityServer4`包后，运行如下命名

```powershell
dotnet new -i identityserver4.templates
dotnet new is4ui
```

项目会自动生成UI的一些代码：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613527284924.png" alt="1613527284924" style="zoom:80%;" />

然后启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```


http://localhost:7200/.well-known/openid-configuration



#### client_credentials(客户端模式)

最简单
Id+Secret
**这种授权方式：一般用于用来给客户端授权，没有用户（参与）**

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613531170007.png" style="zoom: 80%;" />，

##### IdenityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
       
       #region 客户端
           
           services.AddIdentityServer()//怎么处理
              .AddDeveloperSigningCredential()//默认的开发者证书--临时证书--生产环境为了保证token不失效，证书是不变的
              .AddInMemoryClients(ClientInitConfig.GetClients())//InMemory 内存模式
              .AddInMemoryApiResources(ClientInitConfig.GetApiResources());//能访问啥资源
            
       #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
         #region 添加IdentityServer中间件
            app.UseIdentityServer();//拦截部分请求
         #endregion
   }
```

`ClientInitConfig.cs`

```C#
/// <summary>
    /// 客户端模式
    /// </summary>
    public class ClientInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                new ApiResource("UserApi", "用户获取API")
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },//客户端密码，进行了加密
                    AllowedGrantTypes = GrantTypes.ClientCredentials,
                    //授权方式，客户端认证，只要ClientId+ClientSecrets
                    AllowedScopes = new [] { "UserApi" },//允许访问的资源
                    Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }
    }
```

启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Client
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";//ids4的地址
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });

            // 自己加些策略
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "client_eMail")
                    && context.User.Claims.First(c => c.Type.Equals("client_eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

定义给第三方调用的API

`Ids4Controller`

```c#
public class Ids4Controller : Controller
    {
        [Authorize]
        public IActionResult Index()
        {
            Console.WriteLine("************************************************");
            //string id_token = base.HttpContext.Request.Cookies["id_token"];
            //var token_parts = id_token.Split('.');
            //var header = Encoding.UTF8.GetString(Base64Url.Decode(token_parts[0]));
            //var claims = Encoding.UTF8.GetString(Base64Url.Decode(token_parts[1]));
            //var sign = Encoding.UTF8.GetString(Base64Url.Decode(token_parts[2]));
            //Console.WriteLine(header);
            //Console.WriteLine(claims);
            //Console.WriteLine(sign);

            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
            Console.WriteLine("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");
            return View();
        }


        [Authorize(Roles = "Admin")]
        public IActionResult IndexRole()
        {
            return View();
        }


        [Authorize(Policy = "eMailPolicy")]
        public IActionResult IndexPolicy()
        {
            return View();
        }

        [Authorize(Policy = "DoubleEmail")]
        public IActionResult IndexPolicyDouble()
        {
            return View();
        }

        [AllowAnonymous]
        public IActionResult IndexToken()
        {
            return View();
        }

        [AllowAnonymous]
        public IActionResult IndexCodeToken()
        {
            //从url读取code---post请求一下Tencent---token
            return View();
        }

    }
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

获取token的地址： http://localhost:7200/connect/token 

- 获取token

  Post:  http://localhost:7200/connect/token 

  form-data:

  ```json
  grant_type:client_credentials
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  ```

![1613533970909](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613533970909.png)

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1MzM4OTcsImV4cCI6MTYxMzUzNzQ5NywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJjbGllbnRfcm9sZSI6IkFkbWluIiwiY2xpZW50X25pY2tuYW1lIjoiRWxldmVuIiwiY2xpZW50X2VNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdfQ.RCmWr_mM_L8FxsB2kPfdTwwkguaH4S4a1HfoGGuMdUyT6w4zN20gRUgSTNRMRlljTZLK5x2ONuVBxXtAR2HT50kzOo1j5m0enV5YvjGOZVeW70L7WHOP7iMGMvvG1QyW7--TfZKW9U1wZBL_ElZ3ZAzjw3_ttyPnN4lNDewpXBdw6VBjGih4zhCdvtQSZtff2zG2dlSCEstrXdUCawMETlaBloqvg397RDKGyN0hYiyC8qnzpuYSjgg9m-yXJdXTQOZmW9iR0hWlRl31YI61_-0W08bX0gqzC4MiiTHVbF8duYBgPcOJLhoymvIy_VgOTy_GTB99KUW-fjfBt12Hiw
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613533897,
  "exp": 1613537497,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "client_role": "Admin",
  "client_nickname": "Eleven",
  "client_eMail": "57265177@qq.com",
  "scope": [
    "UserApi"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

![1613535970695](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613535970695.png)



#### Password(密码模式) 

携带密码校验，最习惯

密码是从哪里来的，客户端输入给第三方

**安全性：不安全，因为客户端输入账号和密码给第三方，需要充分信任第三方应用**。



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {

            #region 密码模式
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryApiResources(PasswordInitConfig.GetApiResources())//API访问授权资源
               .AddInMemoryClients(PasswordInitConfig.GetClients())  //客户端
               .AddTestUsers(PasswordInitConfig.GetUsers());//添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

`PasswordInitConfig.cs`

```C#
/// <summary>
    /// 密码模式
    /// </summary>
    public class PasswordInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")

                new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),

                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.ResourceOwnerPassword,//密码模式
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    //cliam无效
                }
            };
        }
    }
```



看到代码：

```C#
 .AddTestUsers(PasswordInitConfig.GetUsers());//添加用户
```

显然，这种方式需要用户的参与



启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Password
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "TestApi";
                    options.RequireHttpsMetadata = false;
                });
       
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

获取token的地址： http://localhost:7200/connect/token 

- 获取token

  Post:  http://localhost:7200/connect/token 

  form-data:

  ```json
  grant_type:password
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  scope:TestApi
  username:Eleven
  password:123456
  ```

相较与【客户端模式】，多了两个参数：

```json
username:Eleven
password:123456
```

这是用户的账号和密码。

请求token，如下所示

![1613537528701](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613537528701.png)

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1MzczMTQsImV4cCI6MTYxMzU0MDkxNCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTM3MzE0LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.Q4rioq48LR5lcs9t50jzHuBSJMHEOTnrxz11xowqLC_9hQEULY5Mrd77Lk7K65BOfiXT_PwmWSipEN6BWYBrJjfwApVtsnCh5tCbAshSYhYpLwFMk1N_s30mQhCVy-8YjN-iguoqT8VlSv8frPETTwExe-72zGp_zdUbzYASz-DI-Y1ARZwZv9zCMBy0Sn6jz5EoEU3HFEo6QNK1TOcJ0lK5dgjlout4sRDJhRu9LZ8CG5Hj-aXNRKEbxDn41FAfVMBVESY4GqCnKB0FykxeRSZfwJ7b1UZYnuWsjyjnh4uRQSxsiCREqW5a-GSugvXYvWrZPYGr1xIxlfEQLSS6bA
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613537314,
  "exp": 1613540914,
  "iss": "http://localhost:7200",
  "aud": "TestApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613537314,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

![1613535970695](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613535970695.png)



#### Implicit(隐藏模式) 

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613540163968.png" alt="1613540163968" style="zoom:80%;" />

浏览器模式—允许授权给浏览器

用户访问A—没有token—A提供地址跳转B登录
--输入账号密码—授权---调回A的地址(url带token)
--访问A时带上token

**保护了密码（没有向第三方应用(A.com)提供账号和密码），只是暴露了token**



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region 隐藏模式
            services.AddIdentityServer()
               .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryApiResources(ImplicitInitConfig.GetApiResources()) //API访问授权资源
               .AddInMemoryClients(ImplicitInitConfig.GetClients())//客户端
               .AddTestUsers(ImplicitInitConfig.GetUsers()); //添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

`ImplicitInitConfig.cs`

```C#
   /// <summary>
    /// 隐藏模式：用户---朝夕---腾讯授权中心
    /// http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexToken&response_type=token&scope=UserApi
    /// 用户访问朝夕---需要token---跳转到授权中心---朝夕提供地址---然后用户向腾讯授权中心输入账号密码
    /// 
    /// http://localhost:5726/Ids4/IndexToken#access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE1OTAxNTUwMjUsImV4cCI6MTU5MDE1ODYyNSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNTkwMTU0OTQ3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.WdeNz6A2AxPCU8iO7X6D5ewQD2rVn72CZz7Z_bKUuQU5rdMn3IfIUsKioTzOf5UCrf4oNicu2smYR2VGt7eCFB1_OYAgFWxMDPVu0iVDuTOj8Uhuxwdy9fdPfHCcAa9gAAn2fZg7-IOfY-V4mx3VnhDwoPA_Jzti9E9x-UMcNBzuCs15qRm4CfSiirMe5HaWflrBrBiE4t5QjWR9tJk_ntP5hzjOQCShD8XWj-t1a2oCZzNFIvWP6DF4foppDXwF85FFGDTg-ZE4-dHC3iHY6523KskD9hk4SjHzkn8EVQudnMM5sVQYyp3K9PWAUZ9OQl2n7mDzN8vG5dlbYlCF3w&token_type=Bearer&expires_in=3600&scope=UserApi
    /// 
    /// 到这里获取到token
    /// </summary>
    public class ImplicitInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")
                    new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),//增加cliam
                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }


        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Implicit",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Implicit,//隐藏模式
                    RedirectUris={"http://localhost:5726/Ids4/IndexToken" },//可以多个，根据请求来的转发
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

代码解析：

```C#
RedirectUris={"http://localhost:5726/Ids4/IndexToken" },//可以多个，根据请求来的转发
```

授权后回调的第三方应用的链接，回调时会携带access_token,



启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Implicit
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

认证回到页面：

```C#
    public class Ids4Controller : Controller
    {

        [AllowAnonymous]
        public IActionResult IndexToken()
        {
            return View();
        }
    }
}
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```





##### 第三方应用

###### 用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

认证地址： http://localhost:7200/connect/authorize 

认证回调地址，我们注册为：http://localhost:5726/Ids4/IndexToken,参见如下代码

```C#
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Implicit",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Implicit,//隐藏模式
                    RedirectUris={"http://localhost:5726/Ids4/IndexToken" },//可以多个，根据请求来的转发
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

在Postman,设置如下请求http://localhost:5726/Ids4/Index ，该页面是需要授权才能访问的，所以我们需要在【Authorization】选项卡配置获取token的参数配置，如下图所示：

![1613542182822](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542182822.png)

点击【Get New Access Token】按钮，会弹出如下弹框，其实是跳转到认证中心（IdentityServer4项目）

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542546481.png" alt="1613542546481" style="zoom:80%;" />

输入账号密码：

```C#
        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }
```

```C#
                     Username="Eleven",
                     Password="123456",
```

点击登录后，会弹出如下弹框，询问用户是否授权

![1613542658446](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542658446.png)

点击【Yes,Allow】进行授权。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542811276.png" alt="1613542811276" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542845423.png" alt="1613542845423" style="zoom:80%;" />

获取access_token:

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDI3OTMsImV4cCI6MTYxMzU0NjM5MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjpbIlVzZXJBcGkiLCJUZXN0QXBpIl0sImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQyNjMyLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSIsIlRlc3RBcGkiXSwiYW1yIjpbInB3ZCJdfQ.DIejxN3m1RrNuVm-MyTFCWOmlKly1NP367AXCCiB8DK7KdQqCzlTFnjpHhLh3I2zjbXX1N3WjfTaWTFz8dg5qbHSHT_jTbYKXMHwbn4XxZLwKHFe_NxA8pMXAtcF5w-YNGZFK16JdUU_Ww1i05EIGoB5Os1TV9rusQeqAVXLqpwjvNgepLhtoujMWgMeqtH3zQHO7i_LyB_wa00dktjpp02ep___0Q8S0VmxjyeyYwlBZ2aCyfrWwjat5jmgRmNlSX90eU_Y2gronwMgjCJcmzHdl7JwkEMO6P60ZdCK2TZ-psHJlxAqFcusAcwbBlzTEzR19tva5bIQX7XI3eD3qw
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613542793,
  "exp": 1613546393,
  "iss": "http://localhost:7200",
  "aud": [
    "UserApi",
    "TestApi"
  ],
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613542632,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "UserApi",
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

在上述步骤中获取的access_token, 点击【Use Token】，就可以访问收取页面了

![1613543012648](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613543012648.png)



###### 浏览器模拟第三方应用

访问授权页面http://localhost:5726/Ids4/Index ，返回401，

访问如下地址，获取 access_token

```md
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexToken&response_type=token&scope=UserApi
```

注意, 参数：**response_type=token**，在OAuth2.0协议上表示的是获取access_token



![1613544071226](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613544071226.png)输入账号密码：

 Username="Eleven",
 Password="123456",

点击【Login】后，跳转到【授权确认页面】：

> **【授权确认页面】这个页面只会出现一次，往后就不会在出现**，即使是在浏览器中删除了Cookie，也不会出现，除非重启【IdentityServer4项目】

![1613546699863](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613546699863.png)

点击【Yes,Allow】按钮，跳转回API项目：

```md
http://localhost:5726/Ids4/IndexToken#access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDQxMzMsImV4cCI6MTYxMzU0NzczMywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQ0MTMzLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.bPlbURxEtinlnl842bZS5JG5wKNPtztLtwoxZlncWKTHQrHXZMHjU3FQ93tM6QzUpmV9MWh0ixrCb0Zv6tozCtK7ezDJ8ZVIyLgS_FxrffmVAaJpu_1hvxgaLL5o2T32qo8wP9xWw5NHdxR5iTD9l9aUfizNgcWt-pK9ezJ_FM-lXMnCoOtHmkeI_P-M7w17H4j1mHLloZ2aPRTaeOdZjbxaag-Zk3Mj4gkf9w4Pd71xp93jhRQqTiDRSFlA-XXVnVazesxzr32HQKElsipV-ReT4Zb-rAFzOvVclhpWXyYIZ-jRtlSbnhgte9H-yyA1OKGaC1jY0kVZSuu5P-NCZQ&token_type=Bearer&expires_in=3600&scope=UserApi
```

**我们可以在http://localhost:5726/Ids4/IndexToken 对应的控制器`IndexTokenController`中，获取access_token，并保持在缓存中，以后的每次请求都带上即可。**

下面在`IndexToken.cshtml`中演示了如何从返回的Url中获取access_token:

```html

@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>

<script type="text/javascript">
        var token = null;
        window.onload = function () {
            var url = window.location.href;

            var array = url.split("#");
            if (array.length > 1) {
                token = array[1];
             document.getElementById("token").innerHTML = token;
            }
        }
</script>
```

然后客户端就可以在请求中带入**access_token**即可访问授权页面



#### Code(授权码模式) 

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/oathun-code-model.png" style="zoom:80%;" />

先授权码，通过授权码去获取Token，保护密码-保护token



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region Code模式
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryApiResources(CodeInitConfig.GetApiResources()) //API访问授权资源
               .AddInMemoryClients(CodeInitConfig.GetClients())//客户端
               .AddTestUsers(CodeInitConfig.GetUsers()); //添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

`CodeInitConfig.cs`

```C#
   /// <summary>
    /// 授权码模式：用户---朝夕---腾讯授权中心
    /// http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code&scope=UserApi
    /// 用户访问朝夕---需要token---跳转到授权中心---朝夕提供地址---然后用户向腾讯授权中心输入账号密码
    /// --返回Code--拿着Code+clientpassword通过后端去获取token
    /// 
    /// f9iE2qzai38_dHvA8nef-zN0IH3OrbKY9Ut6Twar2R0
    /// 
    /// </summary>
    public class CodeInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")
                new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),
                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Code",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Code,//授权码
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

代码解析：

```C#
RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" }
```

授权后回调的第三方应用的链接，回调时会携带授权码（author_token）,



启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Code
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

认证回到页面：

```C#
    public class Ids4Controller : Controller
    {

        [AllowAnonymous]
        public IActionResult IndexCodeToken()
        {
            return View();
        }
    }
}
```

```html

@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>

<script type="text/javascript">
        var token = null;
        window.onload = function () {
            var url = window.location.href;

            var array = url.split("#");
            if (array.length > 1) {
                token = array[1];
             document.getElementById("token").innerHTML = token;
            }
        }
</script>
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

###### 前端js

使用 a javascript library named *oidc-client*  

[*oidc-client* ](https://cdnjs.cloudflare.com/ajax/libs/oidc-client/1.6.1/oidc-client.js)



###### 用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

认证地址： http://localhost:7200/connect/authorize 

认证回调地址，我们注册为：http://localhost:5726/Ids4/IndexCodeToken,参见如下代码

```C#
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Code",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Code,//授权码
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

在Postman,设置如下请求http://localhost:5726/Ids4/Index ，该页面是需要授权才能访问的，所以我们需要在【Authorization】选项卡配置获取token的参数配置，如下图所示：

![1613549366777](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549366777.png)

点击【Get New Access Token】按钮，会弹出如下弹框，其实是跳转到认证中心（IdentityServer4项目）

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542546481.png" alt="1613542546481" style="zoom:80%;" />

输入账号密码：

```C#
        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }
```

```C#
                     Username="Eleven",
                     Password="123456",
```

点击登录后，会弹出如下弹框，询问用户是否授权

![1613549447329](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549447329.png)

点击【Yes,Allow】进行授权。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542811276.png" alt="1613542811276" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549498428.png" alt="1613549498428" style="zoom:80%;" />

获取access_token:

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDk0NjAsImV4cCI6MTYxMzU1MzA2MCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQyNjMyLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.V4gNncsNOUxAN16nPMCudVQ5vwArthLH6UGsUh8GjSnEt4dZCLisM7EFqpQ__AJhekpdiKARjemNOKFbvxDd_2DtiFAxfWkhOvjrHPg_KBqD6bdwrL-3w2BzFgclKS4K3dkqGrv7kmYR8iWZ7z8eIoOYRoqLWpffuNHdegOFO5KfQpfykp9Tq79v5JZTSImJnhaIO5rWrFvQhsR4zgz2lhGo7LbUnxpNpXbkKhYBfMfn35i8L3ndrk0Yf67frlJ7S7Vqf7lGIrfP_qaGMQSRtUZGirX_V-4w-alaXkfmkdKtap4h-eIJmECOaOBk2vQDVnjhZhVSxQ2d2zrbjLyh4Q
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613549460,
  "exp": 1613553060,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613542632,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "UserApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

在上述步骤中获取的access_token, 点击【Use Token】，就可以访问收取页面了

![1613549819145](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549819145.png)



###### 浏览器模拟第三方应用

访问授权页面http://localhost:5726/Ids4/Index ，返回401，

访问如下地址，获取 授权码，

```md
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code&scope=UserApi
```

注意, 参数：response_type=code，表示的是获取授权码

![1613547817771](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613547817771.png)

输入账号密码：

 Username="Eleven",
 Password="123456",

点击【Login】后，点击【Login】后，跳转到【授权确认页面】：

![1613547904460](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613547904460.png)

点击【Yess, Allow】按钮后，跳转回API项目：

![1613548237420](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613548237420.png)

```md
http://localhost:5726/Ids4/IndexCodeToken?code=IkAPVJWMfIYvEFqN22SH7ZV6NgNvI2CIhUGuHERo7p8&scope=UserApi
```

，从回调的Url中，我们可以获取到授权码：

```md
IkAPVJWMfIYvEFqN22SH7ZV6NgNvI2CIhUGuHERo7p8
```



然后，第三方应用过通过这个授权码去获取**access_token**,具体的做法是：

发送POST请求（带上授权码）到获取 token（**access_token**）的地址：

Post:  http://localhost:7200/connect/token

form-data:

```json
grant_type:authorization_code
client_id:Zhaoxi.AspNetCore31.AuthDemo
client_secret:eleven123456
scope:UserApi
redirect_uri:http://localhost:5726/Ids4/IndexCodeToken
code:IkAPVJWMfIYvEFqN22SH7ZV6NgNvI2CIhUGuHERo7p8
```

其中，code请求参数放的就是授权码；



下面是2种方式通过授权码码获取accesss_token的方法演示：

- Postman:

  ![1613556067572](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613556067572.png)

  

- 第三方应用项目的页面中获取

​      我们修改下回调页面`IndexCodeToken.cshtml`:

![1613554382692](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613554382692.png) 

这里添加了一个按钮【 获取access_token 】，根据当前获取到的授权码，去获取access_token

```js
        $("#btn_get_access_token").click(function () {
            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType":"json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "UserApi",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
            });
        })
```

![1613558142793](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613558142793.png)

完整代码如下：

```html

@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>


<button id="btn_get_access_token">获取access_token</button>
<h3>access_token：</h3>
<h3 id="access_token"></h3>

<script type="text/javascript">
    var authorization_code = ""; //授权码
    var content = "";
    window.onload = function () {
        var url = window.location.href;

        var array = url.split("#");
        if (array.length > 1) {
            content = array[1];
        }
        var search = window.location.search;
        if (search) {
            search = search.substr(1);
            var paras = search.split("&");
            paras.forEach(element => {
                content += element;
                content += ";"
            });//序列化处理
        }
        document.getElementById("token").innerHTML = content;

        if (search) {
            search = search.substr(1);
            var paras = search.split("&");
            var codeQueryStr = paras[0]; //code = Mm86eRw - iXt8DcZH_0RcIv0 - ruQ7mhZcLFWsbj5tb3w

            var authorization_code = codeQueryStr.split("=")[1];
        }

        $("#btn_get_access_token").click(function () {
            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType":"json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "UserApi",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
            });
        })

    }
</script>
```



**注意，需要在IdentityServer4项目添加如下代码解决跨域问题**

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region 支持跨域  所有的Api都支持跨域
                
            services.AddCors(option => option.AddPolicy("AllowCors", 
             _build => _build.AllowAnyOrigin().AllowAnyMethod()));
         
            #endregion
     }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
          app.UseCors("AllowCors");
    }
  
```



*[Course-41]*

#### OpenID Connect

**OIDC（OpenID Connect）**是在OAuth2上构建了一个身份层，是一个基于OAuth2协议的身份认证标准协议。

**OAuth2** 授权协议---解决了N多个快递员如何进小区的问题Access_Token---门卫不知道快递员是谁---没有用户信息(可以有，但是不关心，因为协议没有规范说这里有用户信息，无规范就无普遍认可)



两者表现出来是一样的，但是出发点不同

OAuth----->Access_Token
OIDC----->Id_Token
一次请求，可以拿到2个token



#### Hybrid(混合模式)



参考资料：

https://chsakell.com/2019/03/11/asp-net-core-identity-series-oauth-2-0-openid-connect-identityserver/

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/author-hybird.png" style="zoom:80%;" />

 在**Code(授权码模式)**或者**Imlplicit(隐藏模式)**的基础上多返回一个`id_token`，这种模式就是**Hybird(混合模式)**



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region Hybrid模式
            services.AddIdentityServer()
               .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryIdentityResources(HybridInitConfig.GetIdentityResources())//身份信息授权资源
               .AddInMemoryApiResources(HybridInitConfig.GetApiResources()) //API访问授权资源
               .AddInMemoryClients(HybridInitConfig.GetClients())//客户端
               .AddTestUsers(HybridInitConfig.GetUsers()); //添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

- 多了个身份信息授权资源

```C#
.AddInMemoryIdentityResources(HybridInitConfig.GetIdentityResources())//身份信息授权资源
```



`HybridInitConfig.cs`

```C#
   /// <summary>
    /// 混合模式:access_token+id_token
    /// http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code%20token%20id_token&scope=UserApi%20openid%20CustomIdentityResource&response_model=fragment&nonce=12345

    /// 
    /// 4种模式：code,code%20token,code%20id_token,code%20token%20id_token
    /// 获取tokenid，scope必须%20openid，其他随意
    /// 必须加入nonce
    /// 自定义claim需要从IdentityResource增加，然后allowscope允许
    /// 
    /// http://localhost:5000/connect/authorize?client_id=apiClientImpl&redirect_uri=https://localhost:5002/auth.html&response_type=token&scope=secretapi
    /// </summary>
    public class HybridInitConfig
    {
        /// <summary>
        /// 用户信息，能返回哪些用户信息
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<IdentityResource> GetIdentityResources()
        {
            return new IdentityResource[]
            {
               new IdentityResources.OpenId(),
               new IdentityResources.Profile(),//一堆默认属性
               new IdentityResource(
                   "CustomIdentityResource",
                   "This is Custom Model",
                    new List<string>(){ "phonemodel","phoneprise", "eMail"})//自定义Id资源，植入claim

            };
        }

        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")
                new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),
                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",

                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim(ClaimTypes.Name,"apiUser"),
                        new Claim("eMail","57265177@qq.com"),
                        new Claim("prog","正式项目"),
                        new Claim("phonemodel","huawei"),
                        new Claim("phoneprise","5000元"),
                    }
                }
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    AlwaysIncludeUserClaimsInIdToken=true,
                    AllowOfflineAccess = true,

                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for HyBrid",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AccessTokenLifetime=3600,//默认1小时
                    AllowedGrantTypes = GrantTypes.Hybrid,//混合模式
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] {
                        "UserApi",
                        "TestApi",//资源范围
                        IdentityServerConstants.StandardScopes.OpenId,//Ids4：获取Id_token，必需加入"openid"
                         IdentityServerConstants.StandardScopes.Profile,//用户信息范围
                       "CustomIdentityResource"},
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

代码解析：

```C#
return new IdentityResource[]
            {
               new IdentityResources.OpenId(),
               new IdentityResources.Profile(),//一堆默认属性
               new IdentityResource(
                   "CustomIdentityResource",
                   "This is Custom Model",
                    new List<string>(){ "phonemodel","phoneprise", "eMail"})//自定义Id资源，植入claim

            };
        }
```

- 多出了`IdentityResource`

- 授权方式为：

  ```C#
    AllowedGrantTypes = GrantTypes.Hybrid,//混合模式
  ```

  

启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {

            #region IdentityServer4--Hybrid
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

认证回到页面：

```C#
    public class Ids4Controller : Controller
    {

        [AllowAnonymous]
        public IActionResult IndexCodeToken()
        {
            return View();
        }
    }
}
```

```html
@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>

<script type="text/javascript">
        var token = null;
        window.onload = function () {
            var url = window.location.href;

            var array = url.split("#");
            if (array.length > 1) {
                token = array[1];
             document.getElementById("token").innerHTML = token;
            }
        }
</script>
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

###### 前端js

使用 a javascript library named *oidc-client*  

[*oidc-client* ](https://cdnjs.cloudflare.com/ajax/libs/oidc-client/1.6.1/oidc-client.js)



###### 用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

认证地址： http://localhost:7200/connect/authorize 

认证回调地址，我们注册为：http://localhost:5726/Ids4/IndexCodeToken,参见如下代码



在Postman,设置如下请求http://localhost:5726/Ids4/Index ，该页面是需要授权才能访问的，所以我们需要在【Authorization】选项卡配置获取token的参数配置，如下图所示：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613641205777.png" alt="1613641205777"  />



往下失败的,因为根据以上配置，查看PostMan的控制台，知道产生的 获取授权码的链接是：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613641248329.png" alt="1613641248329"  />

```html
http://localhost:7200/connect/authorize?response_type=code&state=abc123456&client_id=Zhaoxi.AspNetCore31.AuthDemo&scope=openid UserApi CustomIdentityResource&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken
```

而正确的地址是：

```html
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code token id_token&scope=UserApi openid CustomIdentityResource&response_model=fragment&nonce=12345
```



**------综上以下失败，不出现：待日后再解决----**

点击【Get New Access Token】按钮，会弹出如下弹框，其实是跳转到认证中心（IdentityServer4项目）

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542546481.png" alt="1613542546481" style="zoom:80%;" />

输入账号密码：

```C#
                     Username="Eleven",
                     Password="123456",
```

点击登录后，会弹出如下弹框，询问用户是否授权

![1613549447329](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549447329.png)

点击【Yes,Allow】进行授权。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542811276.png" alt="1613542811276" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549498428.png" alt="1613549498428" style="zoom:80%;" />

获取access_token:

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDk0NjAsImV4cCI6MTYxMzU1MzA2MCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQyNjMyLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.V4gNncsNOUxAN16nPMCudVQ5vwArthLH6UGsUh8GjSnEt4dZCLisM7EFqpQ__AJhekpdiKARjemNOKFbvxDd_2DtiFAxfWkhOvjrHPg_KBqD6bdwrL-3w2BzFgclKS4K3dkqGrv7kmYR8iWZ7z8eIoOYRoqLWpffuNHdegOFO5KfQpfykp9Tq79v5JZTSImJnhaIO5rWrFvQhsR4zgz2lhGo7LbUnxpNpXbkKhYBfMfn35i8L3ndrk0Yf67frlJ7S7Vqf7lGIrfP_qaGMQSRtUZGirX_V-4w-alaXkfmkdKtap4h-eIJmECOaOBk2vQDVnjhZhVSxQ2d2zrbjLyh4Q
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613549460,
  "exp": 1613553060,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613542632,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "UserApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

在上述步骤中获取的access_token, 点击【Use Token】，就可以访问收取页面了

![1613549819145](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549819145.png)



###### 浏览器模拟第三方应用

访问授权页面http://localhost:5726/Ids4/Index ，返回401，



**获取授权码**

访问如下地址，混合模式:access_token+id_token

```md
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code token id_token&scope=UserApi openid CustomIdentityResource&response_model=fragment&nonce=12345
```

注意, 参数：

- response_type=code token id_token，表示的是获取access_token+id_token
- scope=UserApi openid： 请求的授权范围
- response_model=fragment
- nonce=12345



![1613547817771](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613547817771.png)

输入账号密码：

 Username="Eleven",
 Password="123456",

点击【Login】后，点击【Login】后，跳转到【授权确认页面】：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613628920486.png" alt="1613628920486" style="zoom:100%;" />

看到了混合模式，多出一项授权内容，即获取身份信息的授权：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613629006593.png" alt="1613629006593" style="zoom:80%;" />



点击【Yess, Allow】按钮后，跳转回API项目：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613629428376.png" alt="1613629428376" style="zoom:80%;" />

跳转Uri：

```md
http://localhost:5726/Ids4/IndexCodeToken#code=44oIc1DHRFUHVAhOwNBHJ_iyORa0a2J-z-Pq9GViL7c&id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYyOTY4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiWmhhb3hpLkFzcE5ldENvcmUzMS5BdXRoRGVtbyIsIm5vbmNlIjoiMTIzNDUiLCJpYXQiOjE2MTM2MjkzODMsImF0X2hhc2giOiJ4RE1wSmQ0eGh4enBPYkJJZXVMUW9RIiwiY19oYXNoIjoiREJfYWFlMFRMS2R0ZWdFZkg3TnRfUSIsInNpZCI6InFOd2owcTJzdFZIcHFhZjhHQno1SnciLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwicGhvbmVtb2RlbCI6Imh1YXdlaSIsInBob25lcHJpc2UiOiI1MDAw5YWDIiwiYW1yIjpbInB3ZCJdfQ.JNmYxEDq80FxLyd3WWsj3qc1KQf0VIdWu0ss4S9PC-Mv8ZMYjicgBoSaETuooiE-Qt4gA61-bfURk6lwaE1YkO6agP-iQGxSmKpp_MbRUNn03hZ4o5eard-XgqsXS_fLiZj3-9X_idgtT13qELEN0p3nYzRqUe5iWyJSd6wy30A6QhC9qi81qtrKtGAuRZE0MCCJP8xUzbQx7zvDeYS7QvoQtx2TiNtlzGhEA9GqYoFoLrk8OrZa0EymAMX4JWZ2zztfDw9tScO7V1NBST8BFP-S_lMssluDSoRSZUN-ovShd4ediOht1mM6vXJH42MbDRyAozGboN1M1Fhbg8D2fg&access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYzMjk4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsib3BlbmlkIiwiQ3VzdG9tSWRlbnRpdHlSZXNvdXJjZSIsIlVzZXJBcGkiXSwiYW1yIjpbInB3ZCJdfQ.BdlY-g8aDYIrgi2kuMlvla1UF3FI6txlz4EVx1sU_d-C1Mt-ZInt4ZaH1_jVe5eu69malQrYLJKkx41Kfy9LDXdfk4ePWUYBw8p3t1IImWDGL0ro4ngS71Y9x0_-ArxH3c_8PMjx7J8v_ZE_H2qB7CWGPqQQTtQL5adkGbA3fLaSyJdMSSgFOYhgEFirXjnDy5OlsmgYNL4DefIcQMdrGosAJgGot2wlJwyPa18rhTLULb3zfOr36pUoUUp71cmQTsAA-aGNpJC3SXPmyb98N426ka138VPIfQtAGKiEMgr3gXcsvHh8brm6GeDBiy-b8GmU5WCpBrBTSrVci88cnQ&token_type=Bearer&expires_in=3600&scope=openid CustomIdentityResource UserApi&session_state=BK-2C9SZLvA-ktDKrHwbs8DCGRuiKn4zgLhuRm8x-EQ.zMElkwSVzl52uo-eitYHVA
```

，从回调的Url中，我们可以获取到：

- 授权码(authorization code)：

```md
44oIc1DHRFUHVAhOwNBHJ_iyORa0a2J-z-Pq9GViL7c
```

- id_token:

  ```md
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYyOTY4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiWmhhb3hpLkFzcE5ldENvcmUzMS5BdXRoRGVtbyIsIm5vbmNlIjoiMTIzNDUiLCJpYXQiOjE2MTM2MjkzODMsImF0X2hhc2giOiJ4RE1wSmQ0eGh4enBPYkJJZXVMUW9RIiwiY19oYXNoIjoiREJfYWFlMFRMS2R0ZWdFZkg3TnRfUSIsInNpZCI6InFOd2owcTJzdFZIcHFhZjhHQno1SnciLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwicGhvbmVtb2RlbCI6Imh1YXdlaSIsInBob25lcHJpc2UiOiI1MDAw5YWDIiwiYW1yIjpbInB3ZCJdfQ.JNmYxEDq80FxLyd3WWsj3qc1KQf0VIdWu0ss4S9PC-Mv8ZMYjicgBoSaETuooiE-Qt4gA61-bfURk6lwaE1YkO6agP-iQGxSmKpp_MbRUNn03hZ4o5eard-XgqsXS_fLiZj3-9X_idgtT13qELEN0p3nYzRqUe5iWyJSd6wy30A6QhC9qi81qtrKtGAuRZE0MCCJP8xUzbQx7zvDeYS7QvoQtx2TiNtlzGhEA9GqYoFoLrk8OrZa0EymAMX4JWZ2zztfDw9tScO7V1NBST8BFP-S_lMssluDSoRSZUN-ovShd4ediOht1mM6vXJH42MbDRyAozGboN1M1Fhbg8D2fg&access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYzMjk4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsib3BlbmlkIiwiQ3VzdG9tSWRlbnRpdHlSZXNvdXJjZSIsIlVzZXJBcGkiXSwiYW1yIjpbInB3ZCJdfQ.BdlY-g8aDYIrgi2kuMlvla1UF3FI6txlz4EVx1sU_d-C1Mt-ZInt4ZaH1_jVe5eu69malQrYLJKkx41Kfy9LDXdfk4ePWUYBw8p3t1IImWDGL0ro4ngS71Y9x0_-ArxH3c_8PMjx7J8v_ZE_H2qB7CWGPqQQTtQL5adkGbA3fLaSyJdMSSgFOYhgEFirXjnDy5OlsmgYNL4DefIcQMdrGosAJgGot2wlJwyPa18rhTLULb3zfOr36pUoUUp71cmQTsAA-aGNpJC3SXPmyb98N426ka138VPIfQtAGKiEMgr3gXcsvHh8brm6GeDBiy-b8GmU5WCpBrBTSrVci88cnQ
  ```

  特别注意，这里得到的Id_token 不是我们讲到的Id_token

  

**获取access_token和Id_token**

然后，第三方应用过通过这个授权码去获取**access_token**,具体的做法是：

发送POST请求（带上授权码）到获取 **access_toke**和 **Id_token**的地址：

Post:  http://localhost:7200/connect/token

form-data:

```json
grant_type:authorization_code
client_id:Zhaoxi.AspNetCore31.AuthDemo
client_secret:eleven123456
scope:openid UserApi CustomIdentityResource
redirect_uri:http://localhost:5726/Ids4/IndexCodeToken
code:44oIc1DHRFUHVAhOwNBHJ_iyORa0a2J-z-Pq9GViL7c
```

其中，code请求参数放的就是授权码；



下面是2种方式通过授权码码获取accesss_token和Id_token的方法演示：

- Postman:

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613635681387.png" alt="1613635681387"  />


返回值：

```json
{
    "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2MTM2MzU0NzgsImV4cCI6MTYxMzYzNTc3OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiWmhhb3hpLkFzcE5ldENvcmUzMS5BdXRoRGVtbyIsIm5vbmNlIjoiMTIzNDUiLCJpYXQiOjE2MTM2MzU0NzgsImF0X2hhc2giOiIxNlNKcklKcEsxN1lrTkJfTllxU053Iiwic2lkIjoiTHlLT3JrSWVCUlJILXgxNnYxZlNVQSIsInN1YiI6IjAiLCJhdXRoX3RpbWUiOjE2MTM2MzU0NTEsImlkcCI6ImxvY2FsIiwiZU1haWwiOiI1NzI2NTE3N0BxcS5jb20iLCJwaG9uZW1vZGVsIjoiaHVhd2VpIiwicGhvbmVwcmlzZSI6IjUwMDDlhYMiLCJhbXIiOlsicHdkIl19.PD4TMgF8KH6MgTWttmIkTgRlqoEDm_Pu6kL6Ia9GxxWst4Bf3M1xeZhhXCTK2ni8GoQupLq_MvccTv1cMBnc0s-eb6MxqrX9NZ_H4ZPV0vJI3pbTe_Mkyc0rU9ZeXrzYH50GvwGOpxraij9SdSkmr_WG_R6m9-uOvyvQcWSC-KqBj4oaZizisH6536RF0xliEylYLWcNsH839gBulFl6LQaQObmd73douLYLF-GeUOpxkp9BJJYMIw0obElAw0XL6kXCZ0fhdDYvaef631CTFdE0Fs6LWvqDXOvZI5c9RZzn1HnTjWpbbF564kegWFJQEDGvd2N0AHNrsbRG_yDrgA",
    "access_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2MzU0NzgsImV4cCI6MTYxMzYzOTA3OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjM1NDUxLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsib3BlbmlkIiwiQ3VzdG9tSWRlbnRpdHlSZXNvdXJjZSIsIlVzZXJBcGkiXSwiYW1yIjpbInB3ZCJdfQ.OQAwXFub4-ggrpwLkg0TnAF3QYZuC6W7wvt82dqvEz2dloiMUZMdyfUS8ryvckfjQ_0kbeg7jng43lQ4fhziy93UEmVGKjI-bFWJtTUze5PhofgfYtGpK5updONiw2imIwjaA-LWRUebQ3OUEd4KONy2W0MAAui86fpzUMNSB8d6gwyYtkTVYQ3SMnvokP6qy6kEh94XnrELSoP5sHJWczAWcdcbp3dAgorGrwcwvLTbZo5hnqQa5eDSQwxqoTExyuxIeqLEg7HQNDgZ_TWAXo2-cLkW2Tid3rAYQuK8PFfLvwG4b9qlRehQ78r2TC48_t259kEioX4bIu6PW-Kd8A",
    "expires_in": 3600,
    "token_type": "Bearer",
    "scope": "openid CustomIdentityResource UserApi"
}
```



**id_token**:

```md
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "JWT"
}.{
  "nbf": 1613635478,
  "exp": 1613635778,
  "iss": "http://localhost:7200",
  "aud": "Zhaoxi.AspNetCore31.AuthDemo",
  "nonce": "12345",
  "iat": 1613635478,
  "at_hash": "16SJrIJpK17YkNB_NYqSNw",
  "sid": "LyKOrkIeBRRH-x16v1fSUA",
  "sub": "0",
  "auth_time": 1613635451,
  "idp": "local",
  "eMail": "57265177@qq.com",
  "phonemodel": "huawei",
  "phoneprise": "5000元",
  "amr": [
    "pwd"
  ]
}.[Signature]
```



**access_token**

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613635478,
  "exp": 1613639078,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613635451,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "openid",
    "CustomIdentityResource",
    "UserApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```



- 第三方应用项目的页面中获取

​      我们修改下回调页面`IndexCodeToken.cshtml`:

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613638947589.png" alt="1613638947589" style="zoom:80%;" /> 

这里添加了一个按钮【 获取access_token和id_token 】，

根据当前获取到的授权码，去获取access_token和Id_token

```js
                $("#btn_get_access_token").click(function () {
            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType": "json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "openid UserApi CustomIdentityResource",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code,
                   
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
                document.getElementById("id_token").innerHTML = response.id_token;
            });
        })
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613639011605.png" alt="1613639011605" style="zoom:80%;" />

完整代码如下：

```html


@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>

<h3>token:</h3>
<p id="token"></p>


<button id="btn_get_access_token">获取access_token和id_token</button>

<h3>id_token：</h3>
<p id="id_token"></p>

<h3>access_token：</h3>
<p id="access_token"></p>

<script type="text/javascript">
    var authorization_code = ""; //授权码
    var content = "";
    window.onload = function () {
        var url = window.location.href;
        
        var array = url.split("#");
        if (array.length > 1) {
            content = array[1];

            var paras = content.split("&");
            var codeQueryStr = paras[0]; //code = Mm86eRw - iXt8DcZH_0RcIv0 - ruQ7mhZcLFWsbj5tb3w
            console.log("codeQueryStr: " + codeQueryStr)
            authorization_code = codeQueryStr.split("=")[1]; //array[1].split('&')[0].split("=")[1]

        }
        var search = window.location.search;
        if (search) {
            search = search.substr(1);
            var paras = search.split("&");
            paras.forEach(element => {
                content += element;
                content += ";"
            });//序列化处理
        }
        document.getElementById("token").innerHTML = content;


        $("#btn_get_access_token").click(function () {

            console.log("authorization_code：" + authorization_code)

            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType": "json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "openid UserApi CustomIdentityResource",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code,
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
                document.getElementById("id_token").innerHTML = response.id_token;
            });
        })
    }
</script>
```



**注意，需要在IdentityServer4项目添加如下代码解决跨域问题**

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region 支持跨域  所有的Api都支持跨域
                
            services.AddCors(option => option.AddPolicy("AllowCors", 
             _build => _build.AllowAnyOrigin().AllowAnyMethod()));
         
            #endregion
     }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
          app.UseCors("AllowCors");
    }
  
```



*[Course-41]*



#### IdentityServer4-集成数据库

参考资料：

- https://chsakell.com/2019/03/11/asp-net-core-identity-series-oauth-2-0-openid-connect-identityserver/

- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/Docs/IdentityServer%20%E5%AE%9E%E6%88%98.md
- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Startup.cs

##### 2个半DbContext

引用如下包：

```xml
 <PackageReference Include="IdentityServer4.EntityFramework" Version="3.1.3" />
 <PackageReference Include="IdentityServer4.EntityFramework.Storage" Version="3.1.3" />
```



- ConfigurationDbContext

  ```C#
  public class ConfigurationDbContext<TContext> : DbContext, 
  IConfigurationDbContext, 
  IDisposable 
  where TContext : DbContext, IConfigurationDbContext
  {
          public DbSet<Client> Clients { get; set; }
          public DbSet<IdentityResource> IdentityResources { get; set; }
          public DbSet<ApiResource> ApiResources { get; set; }
  }
  ```

  包含：客户端-资源-Identity 相关配置信息

  

- PersistedGrantDbContext

  ```C#
  //
  // 摘要:
  //     DbContext for the IdentityServer operational data.
  public class PersistedGrantDbContext<TContext> : DbContext, IPersistedGrantDbContext, IDisposable 
  where TContext : DbContext, IPersistedGrantDbContext
  {
  
          public PersistedGrantDbContext(DbContextOptions options, OperationalStoreOptions storeOptions);
  
          public DbSet<PersistedGrant> PersistedGrants { get; set; }
          public DbSet<DeviceFlowCodes> DeviceFlowCodes { get; set; }
  }
  ```

  保持 操作数据：grant-type 、token

- 用户信息

  CustomUserDbContext：没有内置，自己添加

  用户账号密码等信息

  一般我们会有基于`AspNetCore.Identity`框架建立的身份认证系统，比如：
  
  见示例：https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Startup.cs
  
  ```C#
              services.AddDbContext<ApplicationDbContext>(options =>
              {
                  if (useInMemoryStores)
                  {
                      options.UseInMemoryDatabase("IdentityServerDb");
                  }
                  else
                  {
                      options.UseSqlServer(connectionString);
                  }
              });        
             services.AddIdentity<IdentityUser, IdentityRole>()
                  .AddEntityFrameworkStores<ApplicationDbContext>()
                  .AddDefaultTokenProviders();
  ```
  
  我们可以使用`IdentityServer4`的扩展方法`AddAspNetIdentity`
  
  ```C#
  
  #region 程序集 IdentityServer4.AspNetIdentity, Version=3.0.1.0, Culture=neutral, PublicKeyToken=f294d0afe402bb2b
  #endregion
  
  namespace Microsoft.Extensions.DependencyInjection
  {
      //
      // 摘要:
      //     Extension methods to add ASP.NET Identity support to IdentityServer.
      public static class IdentityServerBuilderExtensions
      {
          //
          // 摘要:
          //     Configures IdentityServer to use the ASP.NET Identity implementations of IUserClaimsPrincipalFactory,
          //     IResourceOwnerPasswordValidator, and IProfileService. Also configures some of
          //     ASP.NET Identity's options for use with IdentityServer (such as claim types to
          //     use and authenticaiton cookie settings).
          //
          // 参数:
          //   builder:
          //     The builder.
          //
          // 类型参数:
          //   TUser:
          //     The type of the user.
          public static IIdentityServerBuilder AddAspNetIdentity<TUser>(this IIdentityServerBuilder builder) where TUser : class;
      }
  }
  ```
  
  把基于`AspNetCore.Identity`框架建立的身份认证系统集成进去
  
  ```C#
  var builder = services.AddIdentityServer(options =>
       {
       })
      // this adds the config data from DB (clients, resources)
      .AddConfigurationStore(options =>
                             {
  
                             })
      // this adds the operational data from DB (codes, tokens, consents)
      .AddOperationalStore(options =>
                           {
  
                           })
      .AddAspNetIdentity<IdentityUser>();
  ```
  
  

#####  初始化数据库

参考资料：

- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Startup.cs



appsettings.json，添加数据库连接字符串：

```json
  "ConnectionStrings": {
    "DefaultConnection": "Server=.;Database=Ids4-1;User ID=sa;Password=123456;"
  }
```

Startup.cs

```C#
public void ConfigureServices(IServiceCollection services)
{
             var connectionString = this.Configuration.GetConnectionString("DefaultConnection");

            services
                .AddIdentityServer()
                .AddDeveloperSigningCredential()
                .AddConfigurationStore(options =>
                {
                    options.ConfigureDbContext = builder =>
                    {
                        builder.UseSqlServer(connectionString, b => b.MigrationsAssembly("Zhaoxi.AspNetCore31.AuthenticationCenterIds4"));
                    };
                })
                .AddConfigurationStore(options =>
                {
                    options.ConfigureDbContext = builder =>
                    {
                        builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                    };
                })
                .AddOperationalStore(options =>
                {
                    options.ConfigureDbContext = builder =>
                    {
                        builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                    };
                })
               .AddTestUsers(PasswordInitConfig.GetUsers());
               //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
               //.AddProfileService<CustomProfileService>();

            services.InitSeedData(connectionString);//初始原来的那些内存数据
}
```

代码解析：

- 没有用户，所以**我们这里使用密码模式下的内存用户信息**：

  ```C#
  AddTestUsers(PasswordInitConfig.GetUsers())
  ```




在VS程序包管理控制台，通过如下两个命令，执行数据库迁移：

参考资料：

https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Data/instructions.md



**设置启动项目为：Zhaoxi.AspNetCore31.AuthenticationCenterIds4，然后执行：**

```powershell
add-migration InitialIdentityServerConfigurationDbMigration -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb 

add-migration InitialIdentityServerPersistedGrantDbMigration -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb
```

无法迁移：

```md
The EF Core tools version '3.1.0-preview1.19506.2' is older than that of the runtime '3.1.4'. Update the tools for the latest features and bug fixes.
```

The EF Core tools 版本太低，提示升级到`3.1.4`

```powershell
Install-Package Microsoft.EntityFrameworkCore.Tools -Version 3.1.4
```



执行数据库更新：

```powershell
Update-Database -Context ConfigurationDbContext 
Update-Database -Context PersistedGrantDbContext
```

数据库生成如下数据库：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613660629243.png" alt="1613660629243" style="zoom:80%;" />

##### 种子数据

```c#
services.InitSeedData(connectionString);//初始原来的那些内存数据
```

SeedDataInit.cs

参考资料：

- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/DatabaseInitializer.cs

```C#
  public static class SeedDataInit
    {
        /// <summary>
        /// 初始化种子数据
        /// </summary>
        /// <param name="service"></param>
        /// <param name="conncetionString"></param>
        public static void InitSeedData(this IServiceCollection service, string conncetionString)
        {
            var migtationAssembly = typeof(SeedDataInit).GetTypeInfo().Assembly.GetName().Name;
            service.AddConfigurationDbContext(options =>
            {
                options.ConfigureDbContext = db => db.UseSqlServer(conncetionString,
                    sql => sql.MigrationsAssembly(migtationAssembly));
            });
            service.AddOperationalDbContext(options =>
            {
                options.ConfigureDbContext = db => db.UseSqlServer(conncetionString,
                    sql => sql.MigrationsAssembly(migtationAssembly));
            });

            var serviceProvider = service.BuildServiceProvider();

            using (var scope = serviceProvider.GetRequiredService<IServiceScopeFactory>().CreateScope())
            {
                scope.ServiceProvider.GetService<PersistedGrantDbContext>().Database.Migrate();
                var context = scope.ServiceProvider.GetService<ConfigurationDbContext>();
                context.Database.Migrate();
                InitCustomSeedData(context);
            }
        }

        private static void InitCustomSeedData(IConfigurationDbContext context)
        {
            if (!context.Clients.Any())
            {
                foreach (var client in PasswordInitConfig.GetClients())
                {
                    context.Clients.Add(client.ToEntity());
                }
                context.SaveChanges();
            }
            if (!context.ApiResources.Any())
            {
                foreach (var api in PasswordInitConfig.GetApiResources())
                    context.ApiResources.Add(api.ToEntity());
                context.SaveChanges();
            }

            //if (!context.IdentityResources.Any())
            //{
            //    foreach (var id in PasswordInitConfig.GetIdentityResources())
            //        context.IdentityResources.Add(id.ToEntity());
            //    context.SaveChanges();
            //}

            //init User
        }
    }
```

这里我们使用之前的**密码模式时定义的APIResource和Client**

```C#
            if (!context.Clients.Any())
            {
                foreach (var client in PasswordInitConfig.GetClients())
                {
                    context.Clients.Add(client.ToEntity());
                }
                context.SaveChanges();
            }
            if (!context.ApiResources.Any())
            {
                foreach (var api in PasswordInitConfig.GetApiResources())
                    context.ApiResources.Add(api.ToEntity());
                context.SaveChanges();
            }
```



##### 密码模式

至此，我们使用了：

   `SeedDataInit.cs`

```C#
            if (!context.Clients.Any())
            {
                foreach (var client in PasswordInitConfig.GetClients())
                {
                    context.Clients.Add(client.ToEntity());
                }
                context.SaveChanges();
            }
            if (!context.ApiResources.Any())
            {
                foreach (var api in PasswordInitConfig.GetApiResources())
                    context.ApiResources.Add(api.ToEntity());
                context.SaveChanges();
            }
```

- 密码模式时的定义的**Clients**，`PasswordInitConfig.GetClients()`,并保持到 数据库

- 密码模式时的定义的**ApiResources**，`PasswordInitConfig.GetApiResources()`,并保持到 数据库

- 密码模式时的定义的**Users**，`PasswordInitConfig.GetUsers()`,通过如下代码添加到内存中

  `Startup.cs`

  ```C#
  services
      .AddIdentityServer()
      .AddDeveloperSigningCredential()      
      ......
      .AddTestUsers(PasswordInitConfig.GetUsers());
      //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
      //.AddProfileService<CustomProfileService>();
  ```

  

User使用的是内存用户信息,下面使用**密码模式**获取token，

在PostMan中建立请求：

POST： http://localhost:7200/connect/token 

form-data：

```json
grant_type:password
client_id:Zhaoxi.AspNetCore31.AuthDemo
client_secret:eleven123456
scope:TestApi
username:Eleven
password:123456
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613662492160.png" alt="1613662492160"  />

得到的token：

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2NjI1MzcsImV4cCI6MTYxMzY2NjEzNywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjYyNTM3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.IqegoFvnB9BsPWy7JItOJ-egKOja75v5vTf4UPpQ436bn9qgvdd05kJu0pz82eVLcQJPLz_nmUKn0E9GmHf75CkmLhd6uo8EfOi01oTUmPFByVihxh8wJJ0IpGNKWENDgM9EYUFqHpWArk83HGE3wRHcVzYxzHlU0ZhwSUM7Yc_W9v8z82xLI0-W2w40sBlj3neos14DuAqCEHu-s1lmejENAG-7fkKM23zgWfgpIYS_8l8HyfCmTepjCghGOg4tkAijhN77EG_eJPRW5zD9hbM2ttPgohJ_UiuHhDBXJ7THY8rqvBY97NGAS5_kO6EvOcDOPg6cRcWQOMYBiIWscQ
```
在网站https://jwt.ms/https://jwt.ms 解析下
```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613662537,
  "exp": 1613666137,
  "iss": "http://localhost:7200",
  "aud": "TestApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613662537,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```



API 项目也相应的修改下：

在项目【Zhaoxi.AspNetCore31.AuthDemo】，授权模式修改为**Password(密码模式)**对应的代码

`Startup.cs`

```C#
           #region IdentityServer4--Password
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "TestApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



在Postman中创建如下请求，该页面要必须授权才能查看：

POST： http://localhost:5726/Ids4/Index 

Header：

- Authorization:Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2NjI1MzcsImV4cCI6MTYxMzY2NjEzNywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjYyNTM3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.IqegoFvnB9BsPWy7JItOJ-egKOja75v5vTf4UPpQ436bn9qgvdd05kJu0pz82eVLcQJPLz_nmUKn0E9GmHf75CkmLhd6uo8EfOi01oTUmPFByVihxh8wJJ0IpGNKWENDgM9EYUFqHpWArk83HGE3wRHcVzYxzHlU0ZhwSUM7Yc_W9v8z82xLI0-W2w40sBlj3neos14DuAqCEHu-s1lmejENAG-7fkKM23zgWfgpIYS_8l8HyfCmTepjCghGOg4tkAijhN77EG_eJPRW5zD9hbM2ttPgohJ_UiuHhDBXJ7THY8rqvBY97NGAS5_kO6EvOcDOPg6cRcWQOMYBiIWscQ

  

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613664579325.png" alt="1613664579325"  />



##### 添加用户信息`Profile`

```C#
services
    .AddIdentityServer()
    .AddDeveloperSigningCredential()      
    ......
    .AddTestUsers(PasswordInitConfig.GetUsers());
    //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
    .AddProfileService<CustomProfileService>();
```

使用` .AddProfileService<CustomProfileService>();`添加用户信息

`CustomProfileService.cs`

```C#
    public class CustomProfileService: IProfileService
    {
        public Task GetProfileDataAsync(ProfileDataRequestContext context)
        {
            //把用户返回的Claims应用到返回
            context.IssuedClaims = context.Subject.Claims.ToList();
            return Task.CompletedTask;
        }

        /// <summary>
        /// 验证用户是否有效
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public Task IsActiveAsync(IsActiveContext context)
        {
            context.IsActive = true;
            return Task.CompletedTask;
        }
    }
}
```



集成自接口`IProfileService`：

```C#
    //
    // 摘要:
    //     This interface allows IdentityServer to connect to your user and profile store.
    public interface IProfileService
    {
        //
        // 摘要:
        //     This method is called whenever claims about the user are requested (e.g. during
        //     token creation or via the userinfo endpoint)
        //
        // 参数:
        //   context:
        //     The context.
        Task GetProfileDataAsync(ProfileDataRequestContext context);
        //
        // 摘要:
        //     This method gets called whenever identity server needs to determine if the user
        //     is valid or active (e.g. if the user's account has been deactivated since they
        //     logged in). (e.g. during token issuance or validation).
        //
        // 参数:
        //   context:
        //     The context.
        Task IsActiveAsync(IsActiveContext context);
    }
```



使用PostMan工具，使用密码模式获取到token：

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTM3NTcsImV4cCI6MTYxMzcxNzM1NywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNzEzNzU3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsIm5pY2tuYW1lIjoiRWxldmVuIiwiZU1haWwiOiI1NzI2NTE3N0BxcS5jb20iLCJzY29wZSI6WyJUZXN0QXBpIl0sImFtciI6WyJwd2QiXX0.NIw-GIeBYHmHcs82zBWos1D6U71HOAsv1SqQvZuS3r97tXZEF2IP2sy0g-rVF6yrXLoLnCFAmgEyO4HWMGj_8ozZEXAsGIP5WPR2PDW-vmmpQRwR_GUd108eKbljdRbheNmLFaLxt7spMlTFW3WE5n-tGmGxZ7TihIBoBcrtCdwEBTPGSg4G2eJnd57T2xkwk2B2dKagOhJADFQUgyYGYepy_EHfSGH2pqrCfArOIH9HeIPu0_0fELnuYl4mqu-hSN8vsJstViGam-FbvTmgEIZoVgU4YAfaqbEVrkDTrjYQw2heUJom97E2VFbRwao5Q3jNBhDFM5cJD0DJ8MX-Tg
```

解析如下：

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613713757,
  "exp": 1613717357,
  "iss": "http://localhost:7200",
  "aud": "TestApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613713757,
  "idp": "local",
  "role": "Admin",
  "nickname": "Eleven",
  "eMail": "57265177@qq.com",
  "scope": [
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

看到多了以下内容：

```json
"nickname": "Eleven",
```



##### 其它模式

上一节演示了使用密码模式，并不是意味着集成了数据库就不能使用其它模式，我们可以在使用种子数据的时候，多初始化其它模式的**Clients**，比如**Code模式的Clients**:

```C#
        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Code",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Code,//授权码
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
```

**但是注意修改下`ClientId`,不能重复（要与密码模式注册的Client的ClientId不同）**



##### 使用现有用户信息

到目前，我们的示例中我们还是使用的是**内存User**，

```C#
services
    .AddIdentityServer()
    .AddDeveloperSigningCredential()      
    ......
    .AddTestUsers(PasswordInitConfig.GetUsers());
    //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
    //.AddProfileService<CustomProfileService>();
```



但是在实际项目中，我们已经有了自己现成的用户系统信息，那问题是：

**如何把现成的User集成到`IdentityServer4`框架中？**



###### 扩展校验之IResourceOwnerPasswordValidator

- 定义校验扩展

  自定义校验扩展`CustomResourceOwnerPasswordValidator`，继承接口`IResourceOwnerPasswordValidator`

  校验规则是：查询数据库是否存在账号和密码匹配的用户

```C#
    /// <summary>
    /// 自定义用户检测方法---完成数据库校验
    /// </summary>
    public class CustomResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
    {
        private readonly IUserServiceTest _iUsersServices;
        public CustomResourceOwnerPasswordValidator(IUserServiceTest userService)
        {
            _iUsersServices = userService;
        }

        public Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
        {
            Console.WriteLine($"This is CustomResourceOwnerPasswordValidator {context.UserName}--{context.Password}");
            var user = this._iUsersServices.Login(context.UserName, context.UserName);//正常数据库
            if (user == null)
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            else
            {
                context.Result = new GrantValidationResult(
                        user.UId.ToString(),
                        OidcConstants.AuthenticationMethods.Password,
                        DateTime.UtcNow,
                        user.Claims);
            }
            return Task.CompletedTask;
        }
    }
```



这个校验使用数据库的账号和密码校验：

```C#
var user = this._iUsersServices.Login(context.UserName, context.UserName);//正常数据库
```

- 数据库账号和密码校验

  `IUserServiceTest`

  ```C#
      public interface IUserServiceTest
      {
          UserTestDTO Login(string userName, string password);
      }
  ```

  

   `UserServiceTest `

  ```C#
    public class UserServiceTest : IUserServiceTest
      {
          public UserTestDTO Login(string userName, string password)
          {
              return new UserTestDTO()
              {
                  UId = 123,
                  UserName = userName,
                  Password = password,
                  Claims = new List<Claim>(){
                          new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                          new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven-存储于数据库"),
                          new Claim("eMail","57265177_DataBaseUser.com")
                      }
              };
          }
      }
      public class UserTestDTO
      {
          public int UId { get; set; }
          public string UserName { get; set; }
          public string Password { get; set; }
          public List<Claim> Clais { get; set; }
      }
  ```

- 添加扩展校验

  `Startup.cs`

  添加自定义扩展 校验`CustomResourceOwnerPasswordValidator`：

  ```C#
  services.AddIdentityServer()
      //.AddTestUsers(PasswordInitConfig.GetUsers())
      .AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>();
      //.AddProfileService<CustomProfileService>();
  
  services.AddTransient<IUserServiceTest, UserServiceTest>(); 
  ```

  注意，以下代码已经注释掉了

  ```C#
  //.AddTestUsers(PasswordInitConfig.GetUsers())
  ```

  我们已经不在使用内存User了.

  

  截止`IdentityServer4`相关完整代码如下:

  ```C#
  
              var connectionString = this.Configuration.GetConnectionString("DefaultConnection");
              services
                  .AddIdentityServer()
                  .AddDeveloperSigningCredential()
                  .AddConfigurationStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                      };
                  })
                  .AddOperationalStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                      };
                  })
                 //.AddTestUsers(PasswordInitConfig.GetUsers())
                 .AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>();
                 //.AddProfileService<CustomProfileService>();
  
              services.InitSeedData(connectionString);//初始原来的那些内存数据
              services.AddTransient<IUserServiceTest, UserServiceTest>(); 
  ```

  

- 使用**密码模式**获取token，

  启动项目，用PostMan工具进行测试，测试流程与**密码模式**一样：

  在PostMan中建立请求：

  POST： http://localhost:7200/connect/token 

  form-data：

  ```json
  grant_type:password
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  scope:TestApi
  username:Eleven
  password:123456
  ```

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613662492160.png" alt="1613662492160"  />

  得到的token：

  ```md
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTA3OTYsImV4cCI6MTYxMzcxNDM5NiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIxMjMiLCJhdXRoX3RpbWUiOjE2MTM3MTA3OTYsImlkcCI6ImxvY2FsIiwicm9sZSI6IkFkbWluIiwiZU1haWwiOiI1NzI2NTE3N0BxcS5jb20iLCJzY29wZSI6WyJUZXN0QXBpIl0sImFtciI6WyJwd2QiXX0.Cupm4iHB8puv_spr16f71xmXotd2DTy7n5IlJnRYL-bjkxxIWpNPSV10V6FsH1ThXPXZN87eEl2H_vOuhjjUnjWkT2B5EM_PRcX-qUY9k_8zg5OdeRR81ePObwXqCbkHI_wnylXSt5OIihlOkY2UfJzDjHfzYAxU1d1LeBQnE0OQet-KZOfd5FDYoGZKymTbkNWWtwlGIpyat7V9-jRrlk-S1f_ZEWsKUxMq2JsvlLgZLBGDjQmzr4pZB8Cx4-rg6a5pKcUVbgxaxGiMEyOIEaLfadQ7fBpitmAJcighsuBMEkxFgow6ubE7l0IB8Do6i7H0j566mH2MfMooFS2G0g
  ```

  在网站https://jwt.ms/https://jwt.ms 解析下

  ```json
  {
    "alg": "RS256",
    "kid": "g4NXWvoX11IgmrmCRptyhQ",
    "typ": "at+jwt"
  }.{
    "nbf": 1613711876,
    "exp": 1613715476,
    "iss": "http://localhost:7200",
    "aud": "TestApi",
    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
    "sub": "123",
    "auth_time": 1613711876,
    "idp": "local",
    "role": "Admin",
    "eMail": "57265177_DataBaseUser@qq.com",
    "scope": [
      "TestApi"
    ],
    "amr": [
      "pwd"
    ]
  }.[Signature]
  ```

  

- 添加用户信息

  ```C#
   services.AddIdentityServer()
      //.AddTestUsers(PasswordInitConfig.GetUsers())
      .AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>();
      .AddProfileService<CustomProfileService>();
  
  services.AddTransient<IUserServiceTest, UserServiceTest>(); 
  ```

  获取的token为：

  ```C#
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTQzODEsImV4cCI6MTYxMzcxNzk4MSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIxMjMiLCJhdXRoX3RpbWUiOjE2MTM3MTQzODEsImlkcCI6ImxvY2FsIiwicm9sZSI6IkFkbWluIiwibmlja25hbWUiOiJFbGV2ZW4t5a2Y5YKo5LqO5pWw5o2u5bqTIiwiZU1haWwiOiI1NzI2NTE3N19EYXRhQmFzZVVzZXJAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.gSSphUkqbYV8Txli1bzyMVbgpgilM4Q2JG4jY4omBkZlW-PoY9F74nyHMPAzQRxN3j7HfFyJxj_l4CAbH0DTVojrUhKljbgWRQKEQfIOzO-8bjlikEFuAPx_KXWUR4yohcRlwWxsvFkRmSrag1zPgfAsEJewiH4FIBLQM9a8qen_saEWERLJZ-8Ae1mSVLqkuQg3JYXTN9zjpR_ZNnZ3rlcxnjx8Ger5w-CnDaXxkNoHMA_e8LlTJ1Yjk3AVWbmxO9ZIIG34a3Vi4RvT2n-Xp_EW_2NWp_0UYi1g58DbpvPMG3hq7CWvurIp-fI7FTRA4Ve423-9DEOBDFrWNu4WmA
  ```

  ```json
  {
    "alg": "RS256",
    "kid": "g4NXWvoX11IgmrmCRptyhQ",
    "typ": "at+jwt"
  }.{
    "nbf": 1613714381,
    "exp": 1613717981,
    "iss": "http://localhost:7200",
    "aud": "TestApi",
    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
    "sub": "123",
    "auth_time": 1613714381,
    "idp": "local",
    "role": "Admin",
    "nickname": "Eleven-存储于数据库",
    "eMail": "57265177_DataBaseUser@qq.com",
    "scope": [
      "TestApi"
    ],
    "amr": [
      "pwd"
    ]
  }.[Signature]
  ```

  多出以下信息：

  ```json
   "nickname": "Eleven-存储于数据库",
  ```



##### 自定义校验模式：IExtensionGrantValidator

前面5中授权模式：

          -  客户端模式、
          -  密码模式、
          -  授权码模式、
          -  隐藏模式、
          -  混合模式

都是IdentityServer4框架**内置**的授权模式。



**IdentityServer4框架我们可以支持自定义授权模式**，步骤如下：



- 自定义校验器，必须继承接口`IExtensionGrantValidator`：

```C#
    //
    // 摘要:
    //     Handles validation of token requests using custom grant types
    public interface IExtensionGrantValidator
    {
        //
        // 摘要:
        //     Returns the grant type this validator can deal with
        //
        // 值:
        //     The type of the grant.
        string GrantType { get; }

        //
        // 摘要:
        //     Validates the custom grant request.
        //
        // 参数:
        //   context:
        //     The context.
        //
        // 返回结果:
        //     A principal
        Task ValidateAsync(ExtensionGrantValidationContext context);
    }
```

这里我们自定义一个校验器`CustomElevenGrantValidator`:

```C#
    /// <summary>
    /// 扩展-类型-校验器
    /// </summary>
    public class CustomElevenGrantValidator : IExtensionGrantValidator
    {
        public string GrantType => "CustomEleven";

        private readonly IUserServiceTest _iUserServiceTest;

        public CustomElevenGrantValidator(IUserServiceTest userServiceTest)
        {
            this._iUserServiceTest = userServiceTest;
        }

        public Task ValidateAsync(ExtensionGrantValidationContext context)
        {
            var CE_name = context.Request.Raw.Get("CE_name");
            var CE_password = context.Request.Raw.Get("CE_password");
            Console.WriteLine($"This is CustomElevenGrantValidator CE_name={CE_name}--CE_password={CE_password}");

            if (string.IsNullOrEmpty(CE_name) || string.IsNullOrEmpty(CE_password))
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            var result = this._iUserServiceTest.Login(CE_name, CE_password);
            if (result == null)
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            else
            {
                Console.WriteLine($"This is CustomElevenGrantValidator CE_name={CE_name}--CE_password={CE_password}");
                context.Result = new GrantValidationResult(
                             subject: result.UId.ToString(),
                             authenticationMethod: GrantType,
                             claims: result.Claims);
            }
            return Task.CompletedTask;
        }
    }
```

​     这里模拟从数据库查询是否存在给定的账号和密码在数据库中是否存在。

​     存在，校验通过，否则失败。



- 添加自定义校验器

  ```C#
              var connectionString = this.Configuration.GetConnectionString("DefaultConnection");
  
              services
                  .AddIdentityServer()
                  .AddDeveloperSigningCredential()
                  .AddConfigurationStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString);
                      };
                  })
                  .AddOperationalStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString);
                      };
                  })
                  .AddExtensionGrantValidator<CustomElevenGrantValidator>();
  
              services.InitSeedData(connectionString);//初始原来的那些内存数据
              services.AddTransient<IUserServiceTest, UserServiceTest>();
  ```

- 数据库添加GrantType

​       打开数据库表【ClientGrantTypes】，为客户端（ClientId=Zhaoxi.AspNetCore31.AuthDemo）添加名为

​      **CustomEleven**的GrantType类型

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613716944533.png" alt="1613716944533" style="zoom:80%;" />

  其值就是类`CustomElevenGrantValidator`定义的`GrantType`：

```C#
  public class CustomElevenGrantValidator : IExtensionGrantValidator
  {
      public string GrantType => "CustomEleven";
      //........ 
  }
```



> 特别注意: 
>
> 不要忘记这一步哦， 否则返回的结果是：
>
> ```json
> {
>     "error": "unsupported_grant_type"
> }
> ```
>
> 



- 启动项目【IdentityServer4】

  ```powershell
  dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
  ```

  

- PostMan测试

  在PostMan中建立请求：

  POST： http://localhost:7200/connect/token 

  form-data：

  ```json
  grant_type:CustomEleven
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  scope:TestApi
  CE_name:Eleven
CE_password:123456
  ```

   其中：

  - **grant_type**的用于指定授权模式，这里我们取值为：**CustomEleven**，其值就是类`CustomElevenGrantValidator`定义的`GrantType`：
  
  ```C#
    public class CustomElevenGrantValidator : IExtensionGrantValidator
    {
        public string GrantType => "CustomEleven";
        //........   }
```
  
  - 自定义字段
  
    CE_name:Eleven
    CE_password:123456
  
    要与
  
    ```C#
    
            public Task ValidateAsync(ExtensionGrantValidationContext context)
            {
                var CE_name = context.Request.Raw.Get("CE_name");
                var CE_password = context.Request.Raw.Get("CE_password");
    ```
  
    一致。
  
  
  
  发送请求，
  
  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613717158791.png" alt="1613717158791"  />
  
  得到token：
  
  ```md
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTY5NjgsImV4cCI6MTYxMzcyMDU2OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIxMjMiLCJhdXRoX3RpbWUiOjE2MTM3MTY5NjgsImlkcCI6ImxvY2FsIiwicm9sZSI6IkFkbWluIiwiZU1haWwiOiI1NzI2NTE3N19EYXRhQmFzZVVzZXJAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsiQ3VzdG9tRWxldmVuIl19.BmFd7fuCNMzP9TPXCpMKF-lj0pFrYGf3QJ8uF7oDA_LZycb9f_D_ufcysnlFSnQuTzbC5OWI-qZ6iG75plWs1razDEqXSsCGvnUq58kEJwd5ag7-reH51LLU1lHOia-w1n9Ei7diTodP-d9_5xhxV69dgZ7lf5VxP7dBvj57PKzq3HOv3hFwYeRc98h_NH1O64q84O52NuId9RxqwAO9ulnrSXvtW2YGvvXcoO4_l30IA00X9pNBYRmBnFiEzwvhs-VNbW0w43-YNyYtbhLAX1gZXXKst8UmUV57a6aF-iJbqpTKTaHkkocpDSwd5EqFPHod1-P_kvwCGOgAznsVRw
  ```
  
  解析为：
  
  ```C#
  {
    "alg": "RS256",
    "kid": "g4NXWvoX11IgmrmCRptyhQ",
    "typ": "at+jwt"
  }.{
    "nbf": 1613716968,
    "exp": 1613720568,
    "iss": "http://localhost:7200",
    "aud": "TestApi",
    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
    "sub": "123",
    "auth_time": 1613716968,
    "idp": "local",
    "role": "Admin",
    "eMail": "57265177_DataBaseUser@qq.com",
    "scope": [
      "TestApi"
    ],
    "amr": [
      "CustomEleven"
    ]
  }.[Signature]
  ```
  
  得到token就可以访问授权页面（ http://localhost:5726/Ids4/Index ）了
  
  
  
  原理可参看：IdentityServer4 校验流程
  
  

#### IdentityServer4 校验流程

1、校验客户端Client_id和Client_Secret。
2、校验客户端是否有当前的授权方式。
3、校验是否有请求scope权限。
4、如果非客户端验证，校验账号密码或自定义规则是否正确。
5、非客户端验证，校验授权信息是否有效。