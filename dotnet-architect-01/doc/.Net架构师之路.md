[TOC]

# 1.论架构师的思维转变

## 1.1 到底什么是架构师

### 输出价值

架构师就是那个能把十强完整的做出来的人，能真正输出价值的那个人



### 组织业务

优秀的架构的衡量标准是解决业务问题的能力、支撑业务增长的能力



### 组织技术

追逐技术的深度，拓展技术的宽度

跟进最新的技术，从根本上明白技术是解决什么问题的



### 组织人力

团队分工协作、部门协调沟通、需要高情商



### 组织全局、对外输出

最终，是靠架构师去规划、安排、协调，把一件事能从无到有的推动，

从需求、研发、上线、运营全过程的把握。

是真正负责一件事的人。

## 1.2 向前一步，你就是架构师

不要因为是开发人员，就不去关注软件运维，

不要因为是开发人员，就不去关注测试，

不要因为是开发人员，就不去关注运营，

关注越多，越能看清全局的价值目标。

试着转变思维，从架构师的角度思考价值问题，

看看能否将技术贯穿到业务、用户、最终的价值，

做一个真正解决问题的人。

### 发现问题

### 对待问题

### 解决问题



## 1.3 架构师的思维

### 技术的深度

 做到知其所然，知其所以然

### 技术的广度

跳出舒适区去学习新的技术

### 系统思维

不仅是解决宴请的问题，而是解决问题的根源

### 体系思维

一个人是打不赢一场战争的



# 2.CLR核心机制

## 2.1 什么是堆栈

**栈**和**堆**（托管堆）都是存在于进程的虚拟内存中，为程序运行提供存储空间。

- 栈（Stack）是操作系统在建立线程时，为这个线程建立的存储区域。

- 堆（Heap）是应用程序在运行时请求操作系统分配给自己的内存，是申请给予的过程。

  由于从操作系统管理的内存分配，分配和销毁时都占用时间，所以使用堆效率低

### 栈(Stack）

- 栈中存储值类型
- 栈是先进后出
- 栈是自维护，党员数不再被使用会被抛弃
- 栈空间较小，访问速度快

### 堆(Heap）

- 存储引用类型
- 受垃圾处理器GC管理
- 没有访问限制，按地址索引
- 控件较大，访问速度没有栈快

## 2.2 C#堆栈如何分配

- 值类型分配在栈上

- 引用类型分配在堆上

- 值类型里面的引用类型？-->引用类型一定在堆里

- 引用类型里面的值类型？-->值类型会随着对象而存在



## 2.3 引用类型new对象是发生了什么？

1. 调用new的时候 就会去栈上面开辟内存，创建实例
2. 把实例的引用传递给构造函数
3. 执行构造函数
4. 返回引用



## 2.4 IL解析



| **Nop**      | **如果修补操作码，则填充空间。尽管可能消耗处理周期，但未执行任何有意义的操作。** |
| ------------ | ------------------------------------------------------------ |
| **Ret**      | 从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。 |
| **Ldstr**    | 推送对元数据中存储的字符串的新对象引用。                     |
| **Ldloca**   | 将位于特定索引处的局部变量的地址加载到计算堆栈上。           |
| **Ldloca.S** | 将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。 |
| **Ldc.I4.S** | 将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。      |
| **Stfld**    | 用新值替换在对象引用或指针的字段中存储的值。                 |
| **Ldloc.0**  | 将索引 0 处的局部变量加载到计算堆栈上。                      |
| **Ldfld**    | 查找对象中其引用当前位于计算堆栈的字段的值。                 |
| **Ldflda**   | 查找对象中其引用当前位于计算堆栈的字段的地址。               |
| **Stloc**    | 从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。 |

```C#
    public class Student
    {
        public string Name { get; private set; }

        public int Tag;// { get; set; }

        public Student(string name)
        {
            this.Name = name;
        }
        public void Show()
        {
            int iNum = 0;
            Console.WriteLine($"This is {this.Name} {iNum} show!");
        }
    }
```



```C#
    public class StackHeapTest
    {
        ......
        private static void Show2()
        {
            Student student = new Student("晓风灿月");
            //1 先声明  晓风灿月
            //2 计算空间-开辟空间-
            //3 返回引用地址，通过地址就可以操作对象(才有this)
            //4 才是调用构造函数--构造函数只是为了初始化的
            //5 构造函数返回引用
            student.Tag = 2;
            student.Show();
        }
        ......
```

通过反编译工具[ILSpy](https://github.com/icsharpcode/ILSpy)，查看上述的**C#**代码被编译成**IL**语言如下：

```IL
	.method private hidebysig static 
		void Show2 () cil managed 
	{
		// Method begins at RVA 0x21fc
		// Code size 27 (0x1b)
		.maxstack 2
		.locals init (
			[0] class Zhaoxi.ArchitectBattalion.CLRDemo.Student student
		)

		// {
		IL_0000: nop
		// Student student = new Student("晓风灿月");
		IL_0001: ldstr "晓风灿月"
		IL_0006: newobj instance void Zhaoxi.ArchitectBattalion.CLRDemo.Student::.ctor(string)
		IL_000b: stloc.0
		// student.Tag = 2;
		IL_000c: ldloc.0
		IL_000d: ldc.i4.2
		IL_000e: stfld int32 Zhaoxi.ArchitectBattalion.CLRDemo.Student::Tag
		// student.Show();
		IL_0013: ldloc.0
		IL_0014: callvirt instance void Zhaoxi.ArchitectBattalion.CLRDemo.Student::Show()
		// }
		IL_0019: nop
		IL_001a: ret
	} // end of method StackHeapTest::Show2
```



## 2.5 装箱和拆箱

```C#
       private static void Show4()
        {
            int i = 3;
            object k = i;
            int m = (int)k;

            Console.WriteLine($"{i} {k} {m}");
        }
```

IL:

```C#
	.method private hidebysig static 
		void Show4 () cil managed 
	{
		// Method begins at RVA 0x2250
		// Code size 47 (0x2f)
		.maxstack 4
		.locals init (
			[0] int32 i,
			[1] object k,
			[2] int32 m
		)

		// {
		IL_0000: nop
		// int num = 3;
		IL_0001: ldc.i4.3
		IL_0002: stloc.0
		// object obj = num;
		IL_0003: ldloc.0
		IL_0004: box [System.Runtime]System.Int32
		IL_0009: stloc.1
		// int num2 = (int)obj;
		IL_000a: ldloc.1
		IL_000b: unbox.any [System.Runtime]System.Int32
		IL_0010: stloc.2
		// Console.WriteLine($"{num} {obj} {num2}");
		IL_0011: ldstr "{0} {1} {2}"
		IL_0016: ldloc.0
		IL_0017: box [System.Runtime]System.Int32
		IL_001c: ldloc.1
		IL_001d: ldloc.2
		IL_001e: box [System.Runtime]System.Int32
		IL_0023: call string [System.Runtime]System.String::Format(string, object, object, object)
		IL_0028: call void [System.Console]System.Console::WriteLine(string)
		// }
		IL_002d: nop
		IL_002e: ret
	} // end of method StackHeapTest::Show4
```

装箱拆箱消耗性能



## 2.6 字符串

```c#
        private static void Show5()
        {
            string student = "到下个路口";//堆里面
            string studentCopy = student;

            string people = "到下个路口";//堆里面
            Console.WriteLine(object.ReferenceEquals(student, studentCopy));
            Console.WriteLine(object.ReferenceEquals(student, people));
            //2个答案  T/F T/F        TT  C#内存分配的享元模式

            studentCopy = "love佳";
            Console.WriteLine($"{student} {people}");
            //2个答案   路口  佳佳    都是路口  字符串不可变性，不会修改只会新增

            //引用类型在堆上面---堆的空间有限---连续摆放---字符串长短--都会导致大量内存移动--而且要锁定线程---成本太高---OCP---进而就可以享元模式了--节约空间
        }
```

```C#
        private static void Show6()
        {
            string student1 = "雷电法王";
            string student2 = "雷电法王";
            string student3 = "雷电" + "法王";
            string part = "法王";
            string student31 = "雷电" + part;
            string student4 = string.Format("雷电{0}", "法王");
            StringBuilder sb = new StringBuilder();
            sb.Append("雷电");
            sb.Append("法王");
            string student5 = sb.ToString();
            string student6 = $"{"雷电"}{"法王"}";
            string student7 = $"{"雷电"}{part}";
            Console.WriteLine($"{object.ReferenceEquals(student1, student2)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student3)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student31)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student4)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student5)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student6)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student7)}");
            //6个答案   T /F     TTFFFTF
        }
```



## 2.7 垃圾回收GC

内存是有上限的，不可能无止境的分配空间，
因此就产生了GC(Garbage Collector)的需求 .

1. 提高了软件开发的抽象度；
2. 程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；
   可以使模块的接口更加的清晰，减小模块间的偶合；
3. 大大减少了内存人为管理不当所带来的Bug；
4. 使内存管理更加高效。

总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。



### 2.7.1 什么样的对象需要垃圾回收

1 托管资源
2 存在堆里(含值类型+引用类型)

**托管资源**一般是指被CLR控制的内存资源,这些资源的管理可以由CLR来控制,例如程序中分配的对象,作用域内的变量等，大部分对象都是托管资源。

**非托管资源**是CLR不能控制或者管理的部分，这些资源有很多，比如文件流，数据库的连接，系统的窗口句柄，打印机资源，需要调用Dispose方法

### 2.7.2 堆资源是怎么分配的

![image-20201119022100760](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119022100760.png)



###  2.7.3 Mark-Compact 标记压缩算法

**阶段1**: Mark-Sweep 标记清除阶段，先假设堆（heap）中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；

**阶段2:** Compact 压缩阶段，对象回收之后堆（heap）内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。

![image-20201119022153102](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119022153102.png)



### 2.7.4 Timer怪事

只有显示释放计时器，才能活到被释放的那一刻！

```C#
    public class GCTest
    {
        public static void Show()
        {
            System.Threading.Timer timer1 = new System.Threading.Timer(Timer_Elapsed_Thread, null, 0, 2000);
            //System.Timers.Timer timer = new System.Timers.Timer(1000 * 10);
            //timer.Elapsed += Timer_Elapsed;
            //timer.Start();
            Console.WriteLine("输入任意字符结束timer！");
            Console.Read();
        }
        private static void Timer_Elapsed_Thread(object sender)
        {
            Thread.Sleep(100);
            Console.WriteLine($"This is Timer_Thread Invoke....{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff")}");
            GC.Collect(0);//后面大家都研究下，为什么GC时，timer1没有被回收！ 可以在旧版本也试试---大家一起动手
        }

        private static void Timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            Thread.Sleep(100);
            Console.WriteLine($"This is Timer Invoke....{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff")}");
            GC.Collect();
        }
    }
```



### 2.7.5 三个假设

对象越新，生存期越短；
对象越老，生存期越长；
回收部分资源，快过全部回收。



### 2.7.6 分代策略

![image-20201119023836762](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119023836762.png)

第1次，遍历全部对象，找出没有引用的，删除，剩下1代
第2次，遍历0代对象，找出没有引用的，删除，剩下升级1代
             如果还不够空间，才会遍历1代，没有引用的删除，
             还在被使用的，升级为2代。都不够才会检查2代

  

**各代空间大小？**

实际上是没有具体值的，由CLR管理。
初始化时就会给出0代/1代的预算，然后动态调节！
GC后，对象几乎没有留存，那么就会减小预算，
加快回收频率，每次速度快

如果GC后有很多对象留存，那么就会增加预算，
降低回收频率，每次回收内容多

如果空间不够，就会全面回收，再不够就OutOfMemory了



### 2.7.7 什么时候GC

new对象时--临界点
Windows报告内存不够
GC.Collect 强制GC
程序退出或者卸载AppDomain



### 2.7.8 怎么用GC. Collect

大多数情况下，应该让GC自己决定回收时间，以更好的控制各代预算，也避免GC降低响应

如果知道大量对象无效，可以手动GC，尤其是2代



### 2.7.9 大对象策略

85000字节为限
独立的地址空间
不会移动压缩大对象，成本高，但也造成了碎片
大对象总是2代对象



### 2.7.10 垃圾回收模式

- 工作站：单线程回收

- 服务器：多区域并行回收



![image-20201119025151433](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119025151433.png)



# 3.O/RM 探究

## 3.1 什么是O/RM

对象-关系映射（OBJECT/RELATION MAPPING）

对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。



## 3.2 O/RM框架

![image-20201119030935104](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119030935104.png)



## 3.3 O/RM的基本功能

- CRUD的API：通用增删改查
- 自定义查询：表达式目录树
- MAPPING METADATA：自动映射实现机制
- 事务、延迟、缓存等：O/RM进阶特性实现



## 3.4 手写O/RM简易框架

### 通用查询

`SqlHelper.cs`

```c#
        public T Find<T>(int id)
        {
            Type type = typeof(T);

            string columsString = string.Join(",", type.GetProperties().Select(p => $"[{p.Name}]"));
            string sql = $"select {columsString} from [{type.Name}] where id={id}";
            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.Name]);
                    }

                    return t;
                }
            }

            return default(T);
        }
    }
```



### 配置文件管理

`ConfigurationManager.cs`

```c#
using Microsoft.Extensions.Configuration;
using System.IO;

namespace Orm.Common
{
    public class ConfigurationManager
    {
        private static string _sqlConnectionString = null;
        public static string SqlConnectionString
        {
            get
            {
                return _sqlConnectionString;
            }
        }

        static ConfigurationManager()
        {
            var builder = new ConfigurationBuilder()
                       .SetBasePath(Directory.GetCurrentDirectory())
                       .AddJsonFile("appsettings.json");

            IConfigurationRoot configuration = builder.Build();
            _sqlConnectionString = configuration["connectionString"];

        }
    }
}
```



### 用特性(Attribute)作数据库映射

#### 定义映射特性

`MappingAttribute.cs`

```c#
    public class MappingAttribute : Attribute
    {
        private string _Name = null;
        public MappingAttribute(string name)
        {
            this._Name = name;
        }

        public string GetName()
        {
            return this._Name;
        }
    }
```

`TableAttribute.cs`

```C#
    /// <summary>
    /// 做表名称的别名
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class TableAttribute : MappingAttribute
    {
        public TableAttribute(string tableName) : base(tableName)
        {

        }
    }
```



`ColumAttribute.cs`

```C#
    public class ColumnAttribute : MappingAttribute
    {
        public ColumnAttribute(string columnName) : base(columnName)
        {

        }
    }
```



`MappingExtend.cs`

```C#
    public static class MappingExtend
    {
        public static string GetTableName(this Type type)
        {
            if (type.IsDefined(typeof(TableAttribute), true))
            {
                TableAttribute attribute = type.GetCustomAttribute<TableAttribute>();
                return attribute.GetName();
            }
            else
            {
                return type.Name;
            }
        }

        public static string GetMappingName(this MemberInfo member)
        {
            if (member.IsDefined(typeof(MappingAttribute), true))
            {
                MappingAttribute attribute = member.GetCustomAttribute<MappingAttribute>();
                return attribute.GetName();
            }
            else
            {
                return member.Name;
            }
        }

        public static string GetColumnName(this PropertyInfo prop)
        {
            if (prop.IsDefined(typeof(ColumnAttribute), true))
            {
                ColumnAttribute attribute = prop.GetCustomAttribute<ColumnAttribute>();
                return attribute.GetName();
            }
            else
            {
                return prop.Name;
            }
        }
    }
```

#### 使用映射特性

`Company.cs`

```C#
    /// <summary>
    /// 数据库中表名Company  但是程序是CompanyModel
    /// </summary>
    [Table("Company")]
    public class CompanyModel : BaseEntity
    {
        [Column("Name")]
        public string CompanyName { get; set; }

        ......
    }
```



#### 改造查询语句

`SqlHelper.cs`

```C#
    public class SqlHelper
    {
        public T Find<T>(int id)  where T : BaseEntity
        {
            Type type = typeof(T);

            string columsString = string.Join(",", type.GetProperties().Select(p => $"[{p.GetColumnName()}]"));
            string sql = $"select {columsString} from [{type.GetTableName()}] where id={id}";
            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {      ......
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                   ......
            }
           ......
        }
    }
```

- `type.GetTableName()`获取映射的数据库**表名**
- `p.GetColumnName()`获取映射的数据库**列名**

### 查询部分字段

要实现如下查询：

```c#
UserDto userDto = helper.Find<User, UserDto>(1);
```

其中，`UserDto`只包含`User`类的部分字段，并且`User`中的`Name`字段对应`UserDto`中的`UserName`字段

```c#
    public class UserDto
    {
        public int id { get; set; }

        [Column("Name")]
        public string UserName { get; set; }

    }
```

`SqlHelper.cs`

```c#
        /// <summary>
        /// 查询部分字段
        /// </summary>
        /// <typeparam name="E">数据库映射Model类</typeparam>
        /// <typeparam name="D">Dto类型</typeparam>
        /// <param name="id">id</param>
        /// <returns>Dto类型</returns>
        public D Find<E,D>(int id) where E : BaseEntity
        {
            Type modleType = typeof(E);
            Type dtoType = typeof(D);

            string columsString = string.Join(",", dtoType.GetProperties().Select(p => $"[{p.GetColumnName()}]"));
            string sql = $"select {columsString} from [{modleType.GetTableName()}] where id={id}";

            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    D dto = (D)Activator.CreateInstance<D>();
                    foreach (var prop in dtoType.GetProperties())
                    {
                        prop.SetValue(dto, reader[prop.GetColumnName()]);
                    }

                    return dto;
                }
            }

            return default(D);
        }
```



### 插入

实现如下插入操作：

```C#
   CompanyModel company1 = helper.Find<CompanyModel>(1);
   helper.Insert<CompanyModel>(company1);
```

```c#
        public bool Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T);
         /*
            string columnsString = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"[{p.GetMappingName()}]"));
            string valuesString = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"@{p.GetMappingName()}"));
            var insertSql = $"INSERT INTO [{type.GetMappingName()}] ({columnsString}) VALUES({valuesString});";
         */
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectionString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                int iResult = command.ExecuteNonQuery();
                return iResult == 1;
            }
        }
```

```c#
    public static class FilterExtend
    {
        /// <summary>
        /// 过滤掉主键 返回全部属性
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static IEnumerable<PropertyInfo> GetPropertiesWithoutKey(this Type type)
        {
            return type.GetProperties().Where(p => !p.IsDefined(typeof(KeyAttribute), true));
        }
    }
```

### 更新

```c#
        public int Update<T>(T t) where T : BaseModel, new()
        {
            if (!t.Validate<T>())
            {
                throw new Exception("数据校验没有通过");//大家可以再返回点提示信息
            }

            Type type = t.GetType();
            string stringSet = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"{p.GetMappingName()}=@{p.Name}"));
            string sql = $"UPDATE [{type.GetMappingName()}] SET {stringSet} WHERE Id=@Id;";
            //string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(p => new SqlParameter($"@{p.Name}", p.GetValue(t) ?? DBNull.Value)).ToArray();

            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                return command.ExecuteNonQuery();
            }
        }

        //按需更新--界面上只修改了几个字段--大家有什么思路，可以自己动手，然后show出来
        //1 传递一个列表---实体三个属性  字段名称--操作符--值
        //2 改造成json---{"Name":"zzzz","Password":"123245"}
        public int Update<T>(string json, int id) where T : BaseModel, new()
        {
            Type type = typeof(T);
            T t = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(json);//JObject
            string stringSet = string.Join(",", type.GetPropertiesInJson(json).Select(p => $"{p.GetMappingName()}=@{p.Name}"));
            string sql = $"UPDATE {type.GetMappingName()} SET {stringSet} WHERE Id=@Id;";

            var paraArray = type.GetPropertiesInJson(json).Select(p => new SqlParameter($"@{p.Name}", p.GetValue(t) ?? DBNull.Value)).Append(new SqlParameter("@Id", id)).ToArray();
            
            //return type.GetProperties().Where(p => json.Contains($"'{p.Name}':") || json.Contains($"\"{p.Name}\":"));
            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                return command.ExecuteNonQuery();
            }
        }
```

#### 部分更新

```C#
               SqlHelper helper = new SqlHelper();
                string updateJson = Newtonsoft.Json.JsonConvert.SerializeObject(
                        new
                        {
                            CompanyName = "kkk",
                            LastModifyTime = DateTime.Now
                        }
                    ); ;
     
                helper.Update<CompanyModel>(updateJson, 5);
```



#### 数据校验

- 定义数据校验特性，抽象基类`ValidateAttribute : Attribute`：

```C#
    [AttributeUsage(AttributeTargets.Property)]
    public abstract class ValidateAttribute : Attribute
    {
        public abstract bool Validate(object oValue);
    }
```

- int类型值范围

`IntAttribute`.cs

```C#
        private int _Min = 0;
        private int _Max = 0;
        public IntAttribute(int min, int max)
        {
            this._Min = min;
            this._Max = max;
        }

        public override bool Validate(object oValue)
        {
            return oValue != null
                && oValue.ToString().Length >= this._Min
                && oValue.ToString().Length <= this._Max;
        }
    }
```

- 长度

  ```C#
      public class LengthAttribute : ValidateAttribute
      {
          private int _Min = 0;
          private int _Max = 0;
          public LengthAttribute(int min, int max)
          {
              this._Min = min;
              this._Max = max;
          }
  
          public override bool Validate(object oValue)
          {
              return oValue != null
                  && oValue.ToString().Length >= this._Min
                  && oValue.ToString().Length <= this._Max;
          }
      }
  ```

  

- 值不能为Null

  ```C#
      public class RequiredAttribute : ValidateAttribute
      {
          public override bool Validate(object oValue)
          {
              return oValue != null && !string.IsNullOrWhiteSpace(oValue.ToString());
          }
      }
  ```

 

- 数据扩展方法

  ```C#
   public static class ValidateExtend
      {
          public static bool Validate<T>(this T t)
          {
              Type type = t.GetType();
              foreach (var prop in type.GetProperties())
              {
                  if (prop.IsDefined(typeof(ValidateAttribute), true))
                  {
                      object oValue = prop.GetValue(t);
                      var attributeArray = prop.GetCustomAttributes<ValidateAttribute>();
                      foreach (var attribute in attributeArray)
                      {
                          if (attribute.Validate(oValue))
                          {
                              //继续
                          }
                          else
                          {
                              return false;
                          }
                      }
                  }
              }
              return true;
          }
      }
  ```

- 使用校验特性

  ```c#
  using Orm.Framework.SqlDataValidate;
  using Orm.Framework.SqlMapping;
  using System;
  
  namespace Orm.Model
  {
      [Table("Company")]
      public class CompanyModel : BaseEntity
      {
          [Column("Name")]
          [Required, Length(4, 14)]
          public string CompanyName { get; set; }
  
          public DateTime CreateTime { get; set; }
  
          [Int(1, 999999999)]
          public int CreatorId { get; set; }
  
          public Nullable<int> LastModifierId { get; set; }
  
          public DateTime? LastModifyTime { get; set; }
      }
  }
  ```

  

- 在插入或更新时，使用校验

```C#
        public int Update<T>(T t) where T : BaseEntity, new()
        {
            if (!t.Validate<T>())
            {
                throw new Exception("数据校验没有通过");//大家可以再返回点提示信息
            }
            ......
        }
```

- `main.cs`

  ```C#
                  SqlHelper helper = new SqlHelper();
                  CompanyModel company = helper.Find<CompanyModel>(1);
                  company.CompanyName = "";
                  helper.Update<CompanyModel>(company);
  ```

  输出：

  ```md
  "数据校验没有通过"
  ```

  

###  删除

```c#
        public bool Delete<T>(T t) where T : BaseModel, new()
        {
            Type type = t.GetType();
            string sql = $"DELETE FROM [{type.GetMappingName()}] WHERE Id=@Id;";
            var paraArray = new SqlParameter[] { new SqlParameter("@Id", t.Id) };

            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                //var trans = conn.BeginTransaction();
                //trans.Commit();
                //trans.Rollback();
                return 1 == command.ExecuteNonQuery();
            }
        }
```



### 条件查询

实现如下查询：

```c#
     SqlHelper helper = new SqlHelper();
     var companys = helper.FindCondition<CompanyModel>(c => c.Id > 10);
```

使用表达式树解析出`sql`的中`where`语句，做法如下：

```C#
        public IList<T> FindCondition<T>(Expression<Func<T, bool>> func) where T : BaseEntity, new()
        {
            Type type = typeof(T);
            string columnsString = string.Join(",", type.GetProperties().Select(p => $"[{p.GetMappingName()}]"));
            string where = func.ToWhere<T>(out List<SqlParameter> parameters);
            string sql = $"SELECT {columnsString} FROM [{type.GetMappingName()}] WHERE {where}";
            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connString}");
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(parameters.ToArray());
                conn.Open();
                var reader = command.ExecuteReader();
                IList<T> result = new List<T>();
                while (reader.Read())
                {
                    T t = new T();
                    foreach (var prop in type.GetProperties())
                    {
                        string propName = prop.GetMappingName();
                        prop.SetValue(t, reader[propName] is DBNull ? null : reader[propName]);
                    }
                    result.Add(t);
                }
                return result;
            }
        }
```

其中，关键语句如下，

```C#
 string where = func.ToWhere<T>(out List<SqlParameter> parameters);
```

将`Larmda`表达式解析为`wher`语句并获取参数列表



`ExpressionHelper.cs`

```c
    public static class ExpressionHelper
    {
        public static string ToWhere<T>(this Expression<Func<T, bool>> expression, out List<SqlParameter> sqlParameters)
        {
            CustomExpressionVisitor visitor = new CustomExpressionVisitor();
            visitor.Visit(expression);
            string where = visitor.GetWhere(out sqlParameters);
            return where;
        }
    }
```

`CustomExpressionVisitor.cs`

```c#
public class CustomExpressionVisitor : ExpressionVisitor
    {
        private Stack<string> ConditionStack = new Stack<string>();
        //id>10    id>@Id    sqlparameter(@id,10)
        private List<SqlParameter> _SqlParameterList = new List<SqlParameter>();
        private object _TempValue = null;


        public string GetWhere(out List<SqlParameter> sqlParameters)
        {
            string where = string.Concat(this.ConditionStack.ToArray());
            this.ConditionStack.Clear();
            sqlParameters = _SqlParameterList;
            return where;
        }


        public override Expression Visit(Expression node)
        {
            Console.WriteLine($"Visit入口：{node.NodeType} {node.Type} {node.ToString()}");
            return base.Visit(node);
        }

        protected override Expression VisitBinary(BinaryExpression node)
        {
            Console.WriteLine($"VisitBinary：{node.NodeType} {node.Type} {node.ToString()}");
            this.ConditionStack.Push(" ) ");
            base.Visit(node.Right);
            this.ConditionStack.Push(node.NodeType.ToSqlOperator());
            base.Visit(node.Left);
            this.ConditionStack.Push(" ( ");
            return node;
        }

        protected override Expression VisitConstant(ConstantExpression node)
        {
            Console.WriteLine($"VisitConstant：{node.NodeType} {node.Type} {node.ToString()}");
            //this.ConditionStack.Push($"'{node.Value.ToString()}'");
            this._TempValue = node.Value;
            //栈里面不要值，要的是@PropertyName,但是从后往前，先有值再有属性--但是二者是连续的
            return node;
        }

        protected override Expression VisitMember(MemberExpression node)
        {
            Console.WriteLine($"VisitMember：{node.NodeType} {node.Type} {node.ToString()}");
            //this.ConditionStack.Push($"{node.Member.GetMappingName()}");
            if (node.Expression is ConstantExpression)
            {
                var value1 = this.InvokeValue(node);
                var value2 = this.ReflectionValue(node);
                //this.ConditionStack.Push($"'{value1}'");
                this._TempValue = value1;
            }
            else
            {
                //this.ConditionStack.Push($"{node.Member.Name}");
                //this.ConditionStack.Push($"{node.Member.GetMappingName()}");//映射数据
                if (this._TempValue != null)
                {
                    string name = node.Member.GetMappingName();
                    string paraName = $"@{name}{this._SqlParameterList.Count}";
                    string sOperator = this.ConditionStack.Pop();
                    this.ConditionStack.Push(paraName);
                    this.ConditionStack.Push(sOperator);
                    this.ConditionStack.Push(name);

                    var tempValue = this._TempValue;
                    this._SqlParameterList.Add(new SqlParameter(paraName, tempValue));
                    this._TempValue = null;
                }
            }
            return node;
        }

        private object InvokeValue(MemberExpression member)
        {
            var objExp = Expression.Convert(member, typeof(object));//struct需要
            return Expression.Lambda<Func<object>>(objExp).Compile().Invoke();
        }

        private object ReflectionValue(MemberExpression member)
        {
            var obj = (member.Expression as ConstantExpression).Value;
            return (member.Member as FieldInfo).GetValue(obj);
        }

        protected override Expression VisitMethodCall(MethodCallExpression m)
        {
            if (m == null) throw new ArgumentNullException("MethodCallExpression");

            this.Visit(m.Arguments[0]);
            string format;
            switch (m.Method.Name)
            {
                case "StartsWith":
                    format = "({0} LIKE {1}+'%')";
                    break;

                case "Contains":
                    format = "({0} LIKE '%'+{1}+'%')";
                    break;

                case "EndsWith":
                    format = "({0} LIKE '%'+{1})";
                    break;

                default:
                    throw new NotSupportedException(m.NodeType + " is not supported!");
            }
            this.ConditionStack.Push(format);
            this.Visit(m.Object);
            string left = this.ConditionStack.Pop();
            format = this.ConditionStack.Pop();
            string right = this.ConditionStack.Pop();
            this.ConditionStack.Push(String.Format(format, left, right));

            return m;
        }
    }
```

#### 表达式树

[表达式树 (C#)](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/)

[修改表达式树](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-modify-expression-trees)

[如何使用表达式树来生成动态查询 (C#)](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-use-expression-trees-to-build-dynamic-queries)

https://www.cnblogs.com/wolf-sun/p/4234747.html#t1

https://www.cnblogs.com/snailblog/p/11521043.html

#### ExpressionVisitor抽象类源码

此类继承自`ExpressionVisitor`类，此类是`expression`表达式的工具类，可对`expression`表达式内部的成员进行替换

[修改表达式树](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-modify-expression-trees)

```C#

//http://blogs.msdn.com/b/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx
public abstract class ExpressionVisitor
    {
        protected virtual Expression Visit(Expression exp)
        {
            if (exp == null)
                return exp;
            switch (exp.NodeType)
            {
                case ExpressionType.Negate:
                case ExpressionType.NegateChecked:
                case ExpressionType.Not:
                case ExpressionType.Convert:
                case ExpressionType.ConvertChecked:
                case ExpressionType.ArrayLength:
                case ExpressionType.Quote:
                case ExpressionType.TypeAs:
                    return this.VisitUnary((UnaryExpression)exp);
                case ExpressionType.Add:
                case ExpressionType.AddChecked:
                case ExpressionType.Subtract:
                case ExpressionType.SubtractChecked:
                case ExpressionType.Multiply:
                case ExpressionType.MultiplyChecked:
                case ExpressionType.Divide:
                case ExpressionType.Modulo:
                case ExpressionType.And:
                case ExpressionType.AndAlso:
                case ExpressionType.Or:
                case ExpressionType.OrElse:
                case ExpressionType.LessThan:
                case ExpressionType.LessThanOrEqual:
                case ExpressionType.GreaterThan:
                case ExpressionType.GreaterThanOrEqual:
                case ExpressionType.Equal:
                case ExpressionType.NotEqual:
                case ExpressionType.Coalesce:
                case ExpressionType.ArrayIndex:
                case ExpressionType.RightShift:
                case ExpressionType.LeftShift:
                case ExpressionType.ExclusiveOr:
                    return this.VisitBinary((BinaryExpression)exp);
                case ExpressionType.TypeIs:
                    return this.VisitTypeIs((TypeBinaryExpression)exp);
                case ExpressionType.Conditional:
                    return this.VisitConditional((ConditionalExpression)exp);
                case ExpressionType.Constant:
                    return this.VisitConstant((ConstantExpression)exp);
                case ExpressionType.Parameter:
                    return this.VisitParameter((ParameterExpression)exp);
                case ExpressionType.MemberAccess:
                    return this.VisitMemberAccess((MemberExpression)exp);
                case ExpressionType.Call:
                    return this.VisitMethodCall((MethodCallExpression)exp);
                case ExpressionType.Lambda:
                    return this.VisitLambda((LambdaExpression)exp);
                case ExpressionType.New:
                    return this.VisitNew((NewExpression)exp);
                case ExpressionType.NewArrayInit:
                case ExpressionType.NewArrayBounds:
                    return this.VisitNewArray((NewArrayExpression)exp);
                case ExpressionType.Invoke:
                    return this.VisitInvocation((InvocationExpression)exp);
                case ExpressionType.MemberInit:
                    return this.VisitMemberInit((MemberInitExpression)exp);
                case ExpressionType.ListInit:
                    return this.VisitListInit((ListInitExpression)exp);
                default:
                    throw new Exception(string.Format("Unhandled expression type: '{0}'", exp.NodeType));
            }
        }

        protected virtual MemberBinding VisitBinding(MemberBinding binding)
        {
            switch (binding.BindingType)
            {
                case MemberBindingType.Assignment:
                    return this.VisitMemberAssignment((MemberAssignment)binding);
                case MemberBindingType.MemberBinding:
                    return this.VisitMemberMemberBinding((MemberMemberBinding)binding);
                case MemberBindingType.ListBinding:
                    return this.VisitMemberListBinding((MemberListBinding)binding);
                default:
                    throw new Exception(string.Format("Unhandled binding type '{0}'", binding.BindingType));
            }
        }

        protected virtual ElementInit VisitElementInitializer(ElementInit initializer)
        {
            ReadOnlyCollection<Expression> arguments = this.VisitExpressionList(initializer.Arguments);
            if (arguments != initializer.Arguments)
            {
                return Expression.ElementInit(initializer.AddMethod, arguments);
            }
            return initializer;
        }

        protected virtual Expression VisitUnary(UnaryExpression u)
        {
            Expression operand = this.Visit(u.Operand);
            if (operand != u.Operand)
            {
                return Expression.MakeUnary(u.NodeType, operand, u.Type, u.Method);
            }
            return u;
        }

        protected virtual Expression VisitBinary(BinaryExpression b)
        {
            Expression left = this.Visit(b.Left);
            Expression right = this.Visit(b.Right);
            Expression conversion = this.Visit(b.Conversion);
            if (left != b.Left || right != b.Right || conversion != b.Conversion)
            {
                if (b.NodeType == ExpressionType.Coalesce && b.Conversion != null)
                    return Expression.Coalesce(left, right, conversion as LambdaExpression);
                else
                    return Expression.MakeBinary(b.NodeType, left, right, b.IsLiftedToNull, b.Method);
            }
            return b;
        }

        protected virtual Expression VisitTypeIs(TypeBinaryExpression b)
        {
            Expression expr = this.Visit(b.Expression);
            if (expr != b.Expression)
            {
                return Expression.TypeIs(expr, b.TypeOperand);
            }
            return b;
        }

        protected virtual Expression VisitConstant(ConstantExpression c)
        {
            return c;
        }

        protected virtual Expression VisitConditional(ConditionalExpression c)
        {
            Expression test = this.Visit(c.Test);
            Expression ifTrue = this.Visit(c.IfTrue);
            Expression ifFalse = this.Visit(c.IfFalse);
            if (test != c.Test || ifTrue != c.IfTrue || ifFalse != c.IfFalse)
            {
                return Expression.Condition(test, ifTrue, ifFalse);
            }
            return c;
        }

        protected virtual Expression VisitParameter(ParameterExpression p)
        {
            return p;
        }

        protected virtual Expression VisitMemberAccess(MemberExpression m)
        {
            Expression exp = this.Visit(m.Expression);
            if (exp != m.Expression)
            {
                return Expression.MakeMemberAccess(exp, m.Member);
            }
            return m;
        }

        protected virtual Expression VisitMethodCall(MethodCallExpression m)
        {
            Expression obj = this.Visit(m.Object);
            IEnumerable<Expression> args = this.VisitExpressionList(m.Arguments);
            if (obj != m.Object || args != m.Arguments)
            {
                return Expression.Call(obj, m.Method, args);
            }
            return m;
        }

        protected virtual ReadOnlyCollection<Expression> VisitExpressionList(ReadOnlyCollection<Expression> original)
        {
            List<Expression> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                Expression p = this.Visit(original[i]);
                if (list != null)
                {
                    list.Add(p);
                }
                else if (p != original[i])
                {
                    list = new List<Expression>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(p);
                }
            }
            if (list != null)
            {
                return list.AsReadOnly();
            }
            return original;
        }

        protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
        {
            Expression e = this.Visit(assignment.Expression);
            if (e != assignment.Expression)
            {
                return Expression.Bind(assignment.Member, e);
            }
            return assignment;
        }

        protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
        {
            IEnumerable<MemberBinding> bindings = this.VisitBindingList(binding.Bindings);
            if (bindings != binding.Bindings)
            {
                return Expression.MemberBind(binding.Member, bindings);
            }
            return binding;
        }

        protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding)
        {
            IEnumerable<ElementInit> initializers = this.VisitElementInitializerList(binding.Initializers);
            if (initializers != binding.Initializers)
            {
                return Expression.ListBind(binding.Member, initializers);
            }
            return binding;
        }

        protected virtual IEnumerable<MemberBinding> VisitBindingList(ReadOnlyCollection<MemberBinding> original)
        {
            List<MemberBinding> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                MemberBinding b = this.VisitBinding(original[i]);
                if (list != null)
                {
                    list.Add(b);
                }
                else if (b != original[i])
                {
                    list = new List<MemberBinding>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(b);
                }
            }
            if (list != null)
                return list;
            return original;
        }

        protected virtual IEnumerable<ElementInit> VisitElementInitializerList(ReadOnlyCollection<ElementInit> original)
        {
            List<ElementInit> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                ElementInit init = this.VisitElementInitializer(original[i]);
                if (list != null)
                {
                    list.Add(init);
                }
                else if (init != original[i])
                {
                    list = new List<ElementInit>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(init);
                }
            }
            if (list != null)
                return list;
            return original;
        }

        protected virtual Expression VisitLambda(LambdaExpression lambda)
        {
            Expression body = this.Visit(lambda.Body);
            if (body != lambda.Body)
            {
                return Expression.Lambda(lambda.Type, body, lambda.Parameters);
            }
            return lambda;
        }

        protected virtual NewExpression VisitNew(NewExpression nex)
        {
            IEnumerable<Expression> args = this.VisitExpressionList(nex.Arguments);
            if (args != nex.Arguments)
            {
                if (nex.Members != null)
                    return Expression.New(nex.Constructor, args, nex.Members);
                else
                    return Expression.New(nex.Constructor, args);
            }
            return nex;
        }

        protected virtual Expression VisitMemberInit(MemberInitExpression init)
        {
            NewExpression n = this.VisitNew(init.NewExpression);
            IEnumerable<MemberBinding> bindings = this.VisitBindingList(init.Bindings);
            if (n != init.NewExpression || bindings != init.Bindings)
            {
                return Expression.MemberInit(n, bindings);
            }
            return init;
        }

        protected virtual Expression VisitListInit(ListInitExpression init)
        {
            NewExpression n = this.VisitNew(init.NewExpression);
            IEnumerable<ElementInit> initializers = this.VisitElementInitializerList(init.Initializers);
            if (n != init.NewExpression || initializers != init.Initializers)
            {
                return Expression.ListInit(n, initializers);
            }
            return init;
        }

        protected virtual Expression VisitNewArray(NewArrayExpression na)
        {
            IEnumerable<Expression> exprs = this.VisitExpressionList(na.Expressions);
            if (exprs != na.Expressions)
            {
                if (na.NodeType == ExpressionType.NewArrayInit)
                {
                    return Expression.NewArrayInit(na.Type.GetElementType(), exprs);
                }
                else
                {
                    return Expression.NewArrayBounds(na.Type.GetElementType(), exprs);
                }
            }
            return na;
        }

        protected virtual Expression VisitInvocation(InvocationExpression iv)
        {
            IEnumerable<Expression> args = this.VisitExpressionList(iv.Arguments);
            Expression expr = this.Visit(iv.Expression);
            if (args != iv.Arguments || expr != iv.Expression)
            {
                return Expression.Invoke(expr, args);
            }
            return iv;
        }
    }
```





## 3.6 数据库事务

### 3.6.1 ACID

**A**  原子性--要么都成功 要么 都是失败，不会出现中间情况
		
**C**  一致性--数据在执行前后得满足一致性状态，数据得都是有效合法
	
**I**   隔离性--多个事务直接是互不影响的，看不到中间状态
		
**D**  持久性--只要成功了，就一定会固化下来



### 3.6.2 事务实现

- `SqlHelperDelay.cs`

```c#
    /// <summary>
    /// 实现延迟提交，模拟DbConte
    /// </summary>
    public class SqlHelperDelay : IDisposable
    {
        private IList<SqlCommand> _sqlCommandLIist = new List<SqlCommand>();
        
        public void Insert<T>(T entity) where T : BaseEntity
        {
            Type type = typeof(T);
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ).ToArray();

            SqlCommand command = new SqlCommand(sql);
            command.Parameters.AddRange(paraArray);

            _sqlCommandLIist.Add(command);
        }
        
        public void SaveChange()
        {
            string connectString = GetConnectionString(SqlConnectionType.Write);

            if (_sqlCommandLIist.Any())
            {
                using (SqlConnection conn = new SqlConnection(connectString))
                {
                    conn.Open();

                    using (SqlTransaction trans = conn.BeginTransaction())
                    {
                        try
                        {
                            foreach (var command in _sqlCommandLIist)
                            {
                                command.Connection = conn;
                                command.Transaction = trans;
                                command.ExecuteNonQuery();
                            }

                            trans.Commit();
                        }
                        catch (Exception)
                        {
                            trans.Rollback();
                            throw;
                        }
                        finally
                        {
                            _sqlCommandLIist.Clear();
                        }
                    }
                }
            }
        }
        
        public void Dispose()
        {
            _sqlCommandLIist.Clear();
        }
    }
```



1. 使用`private IList<SqlCommand> _sqlCommandLIist = new List<SqlCommand>();`存储的所有command`;

2. 然后在`SaveChange()`中使用同一个连接`conn`的同一个事务里面统一提交;

   

- 测试用例：

```c#
        [TestMethod]
        public void TestSaveChange_Transations_Exception()
        {
            try
            {
                using (SqlHelperDelay sqlHelperDelay = new SqlHelperDelay())
                {
                    var company1 = sqlHelperDelay.Find<CompanyModel>(1);
                    var company2 = sqlHelperDelay.Find<CompanyModel>(2);
                    
                    //字符串超过数据库字段长度，抛出异常
                    company2.CompanyName += "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);";

                    sqlHelperDelay.Insert(company1);
                    sqlHelperDelay.Insert(company2);
                    sqlHelperDelay.SaveChange();
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

        }
```

- 局限性

  该示例的局限性是只能在同一个`SqlHelperDelay`实例对象（同一个连接）中才能确保事务的统一性



## 3.7 Uow（工作单元）

**3.6.2 事务实现**中的示例的局限性是只能在同一个`SqlHelperDelay`实例对象中（多个连接）才能确保事务，

如果要实现**多个实例的事务**，就要使用Uow实现



### 3.7.1 单数据库多个数据库连接对象事务

如下示例，使用**Uow** 实现了，**单数据库多个数据库连接对象（connection）**的事务

- `IUnitOfWork`

  ```C#
      public interface IUnitOfWork : IDisposable
      {
          void Invoke(Action action);
      }
  ```

  

- `UnitOfWork`

  ```C#
          /// <summary>
          /// 提供事务
          /// </summary>
          /// <param name="action">多个数据操作</param>
          public void Invoke(Action action)
          {
              using(var trans = new TransactionScope())
              {
                  action.Invoke();
                  trans.Complete();
              }
  
          }
  
          public void Dispose()
          {
          }
  ```

  

- 测试用例

  ```c#
          [TestMethod]
          public void TestUnitOfWork_Exception()
          {
              using (var uow = new UnitOfWork())
              {
                  SqlHelper sqlHelper = new SqlHelper();
                  var company1 = sqlHelper.Find<CompanyModel>(1);
                  var company2 = sqlHelper.Find<CompanyModel>(2);
  
                  uow.Invoke(() => {
                      sqlHelper.Insert(company1);
                      sqlHelper.Insert(company2);
                      throw new Exception("Exception in Uow!!!");
                  });
              }
          }
  
          [TestMethod]
          public void TestUnitOfWork_Ok()
          {
              using (var uow = new UnitOfWork())
              {
                  SqlHelper sqlHelper = new SqlHelper();
                  var company1 = sqlHelper.Find<CompanyModel>(1);
                  var company2 = sqlHelper.Find<CompanyModel>(2);
  
                  uow.Invoke(() => {
                      sqlHelper.Insert(company1);
                      sqlHelper.Insert(company2);
                  });
              }
          }
  ```

  

## 3.8 分布式事务：多数据库事务

### 3.8.1 MSDTC

为了实现该示例，需要从数据`Architect_Customers`复制出一个新的数据库`Architect_Customers_Other`

在配置文件中新增新的数据库连接`Other`：

```json
{
  "ConnectionStrings": {
    "Write": "...",
    "Read": [ ...
    ],
    "Other": "Data Source=.; Database=Architect_Customers_Other; User ID=sa; Password=123456; MultipleActiveResultSets=True"
  }
}

```

新建一个对应新数据库的查询帮助类`SqlHelperOther `,与`SqlHelper`一样，只是替换了连接字符串的获取方法`GetOtherDbConnectionString()`

```c#
 public class SqlHelperOther
    {
        public T Find<T>(int id) where T : BaseEntity
        {
            Type type = typeof(T);

            string sql = $"{SqlBuilder<T>.GetFindSql()}{id}";
            string connectString = GetOtherDbConnectionString(SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connectString}");
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                    }

                    return t;
                }
            }

            return default(T);
        }


        public int Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T);

            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            string connectString = GetOtherDbConnectionString(SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                object id = command.ExecuteScalar();
                return Convert.ToInt32(id);
            }
        }

```



执行如下可是代码：

```C#
            using (var uow = new UnitOfWork())
            {
                SqlHelper sqlHelper = new SqlHelper();
                var company1 = sqlHelper.Find<CompanyModel>(1);
                company1.CompanyName += "多数据事务";

                SqlHelperOther sqlHelperOther = new SqlHelperOther();
                var company2 = sqlHelperOther.Find<CompanyModel>(1);
                company2.CompanyName += "多数据事务";

                uow.Invoke(() => {
                    sqlHelper.Insert(company1);
                    sqlHelperOther.Insert(company2);
                });
            }
```



```md
System.Data.SqlClient.SqlException:“服务器 'DESKTOP-LDDT7JH' 上的 MSDTC 不可用。”
```

要解决该问题，需要打开windows系统的**DTC**（Distributed Transaction Coordinator）服务，将其设置为**启动**

> MSDTC:
>
> 协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。



启动`MS DTC`服务后，还是会抛出异常：

```md
System.PlatformNotSupportedException:“This platform does not support distributed transactions.”
```

这是在**`.net core 2.1`后就不支持`MSDTC`**了

**同样的代码，`.net framework`中，MSDTC确实可以保证多个数据库间完成事务操作**

#### 3.8.1.1 拓展：局域网MSDTC配置

![image-20201123172107878](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172107878.png)

![image-20201123172136720](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172136720.png)



### 3.8.3 CAP

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172544672.png" alt="image-20201123172544672" style="zoom:80%;" />



P:是一定会发生的，

CAP定理：CAP是不可能同时满足的

目前的分布式往AP方向走 ，C(一致性)延缓，最终一致性



### 3.8.4 DTC-2PC

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123175936640.png" alt="image-20201123175936640" style="zoom:80%;" />



**DTC-2PC** 追求可用性，放弃了可用性



### 3.8.5 数据库事务解决

- .Net Core目前暂未提供简单易用的2PC分布式事务

- Try Confirm Cancel
- 本地消息表



## 3.9 条件查询





# 4. 读写分离



读写分离，主库做增删改，从库只读。

大部分的数据库压力，都是由查询引起的，读写分离可以减轻数据库的压力。

1、在(主)数据库上对需要同步的数据进行发布（创建发布服务）。

2、在(从)数据库上对(主)数据库的发布进行订阅。

![image-20201119193930302](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119193930302.png)



**注意事项**

- 查询服务器的名称和实际计算机的名称，如果两者不一致，就需要修改。

     ```sql
use master
 go
 select @@servername;
 select serverproperty('servername')
     ```



- 将"服务器名", 修改为正确的计算机名

  ```sql
  EXEC sp_dropserver 'aaaaa';      -- 原服务器名
  GO
  EXEC sp_addserver 'aaaaa', 'local'; -- 新服务器名
  ```



**参考**

https://blog.csdn.net/qq_32343577/article/details/82423393



## 4.1 设置发布服务器

- 在设置发布服务器前，先确保服务【SQL Server代理（MSSQL SEVER）】是启动，并且启动模式必须是“自动”

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081423600.png" alt="image-20201122081423600" style="zoom:33%;" />

- 打开【SqlSever管理器】

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122075520349.png" alt="image-20201122075520349" style="zoom:40%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122075538469.png" alt="image-20201122075538469" style="zoom:50%;" />

​    

  实测中直接使用物理路径`E:\ProgramData\SqlServerDatas\snapshot`

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080642440.png" alt="image-20201122080642440" style="zoom:50%;" />





<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080815062.png" alt="image-20201122080815062" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080855479.png" alt="image-20201122080855479" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080945839.png" alt="image-20201122080945839" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081147364.png" alt="image-20201122081147364" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081229813.png" alt="image-20201122081229813" style="zoom:50%;" />

生成的脚本的`ConfigureDistribution-server.sql`：

```sql
/****** 正在编写复制配置的脚本。脚本日期: 2020/11/22 8:12:19 ******/
/****** 请注意: 出于安全原因，所有密码参数均使用 NULL 或空字符串代替。******/

/****** 正在将服务器作为分发服务器安装。脚本日期: 2020/11/22 8:12:19 ******/
use master
exec sp_adddistributor @distributor = N'DESKTOP-LDDT7JH', @password = N''
GO
exec sp_adddistributiondb @database = N'distribution-server', @data_folder = N'E:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\Data', @log_folder = N'E:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\Data', @log_file_size = 2, @min_distretention = 0, @max_distretention = 72, @history_retention = 48, @security_mode = 1
GO

use [distribution-server] 
if (not exists (select * from sysobjects where name = 'UIProperties' and type = 'U ')) 
	create table UIProperties(id int) 
if (exists (select * from ::fn_listextendedproperty('SnapshotFolder', 'user', 'dbo', 'table', 'UIProperties', null, null))) 
	EXEC sp_updateextendedproperty N'SnapshotFolder', N'\\DESKTOP-LDDT7JH\snapshot', 'user', dbo, 'table', 'UIProperties' 
else 
	EXEC sp_addextendedproperty N'SnapshotFolder', N'\\DESKTOP-LDDT7JH\snapshot', 'user', dbo, 'table', 'UIProperties'
GO

exec sp_adddistpublisher @publisher = N'DESKTOP-LDDT7JH', @distribution_db = N'distribution-server', @security_mode = 0, @login = N'sa', @password = N'', @working_directory = N'\\DESKTOP-LDDT7JH\snapshot', @trusted = N'false', @thirdparty_flag = 0, @publisher_type = N'MSSQLSERVER'
GO

```



## 4.2 设置发布

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082141699.png" alt="image-20201122082141699" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082216245.png" alt="image-20201122082216245" style="zoom:50%;" />

选择“事件发布”

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082257246.png" alt="image-20201122082257246" style="zoom:50%;" />

1. 快照复制：变化频率低，变化数据大
2. 事务复制：同步效率高，变化频繁，每个步骤都包含
3. 合并复制：通常用于服务器到客户端的环境中，会冲突



选择要发布的表，如果实际过程中有新增表，得重新设置

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082435803.png" alt="image-20201122082435803" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082537091.png" alt="image-20201122082537091" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082630428.png" alt="image-20201122082630428" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082816786.png" alt="image-20201122082816786" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082846659.png" alt="image-20201122082846659" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083024014.png" alt="image-20201122083024014" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083037511.png" alt="image-20201122083037511" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083244203.png" alt="image-20201122083244203" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083319892.png" alt="image-20201122083319892" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083614013.png" alt="image-20201122083614013" style="zoom:50%;" />



生成的脚本`CreatePublication.sql`：

```sql
use [Architect_Customers]
exec sp_replicationdboption @dbname = N'Architect_Customers', @optname = N'publish', @value = N'true'
GO
-- 添加事务发布
use [Architect_Customers]
exec sp_addpublication @publication = N'Architect_Customers', @description = N'来自发布服务器“DESKTOP-LDDT7JH”的数据库“Architect_Customers”的事务发布。', @sync_method = N'concurrent', @retention = 0, @allow_push = N'true', @allow_pull = N'true', @allow_anonymous = N'true', @enabled_for_internet = N'false', @snapshot_in_defaultfolder = N'true', @compress_snapshot = N'false', @ftp_port = 21, @ftp_login = N'anonymous', @allow_subscription_copy = N'false', @add_to_active_directory = N'false', @repl_freq = N'continuous', @status = N'active', @independent_agent = N'true', @immediate_sync = N'true', @allow_sync_tran = N'false', @autogen_sync_procs = N'false', @allow_queued_tran = N'false', @allow_dts = N'false', @replicate_ddl = 1, @allow_initialize_from_backup = N'false', @enabled_for_p2p = N'false', @enabled_for_het_sub = N'false'
GO

exec sp_addpublication_snapshot @publication = N'Architect_Customers', @frequency_type = 1, @frequency_interval = 0, @frequency_relative_interval = 0, @frequency_recurrence_factor = 0, @frequency_subday = 0, @frequency_subday_interval = 0, @active_start_time_of_day = 0, @active_end_time_of_day = 235959, @active_start_date = 0, @active_end_date = 0, @job_login = null, @job_password = null, @publisher_security_mode = 0, @publisher_login = N'sa', @publisher_password = N''

use [Architect_Customers]
exec sp_addarticle @publication = N'Architect_Customers', @article = N'Company', @source_owner = N'dbo', @source_object = N'Company', @type = N'logbased', @description = null, @creation_script = null, @pre_creation_cmd = N'drop', @schema_option = 0x000000000803509F, @identityrangemanagementoption = N'manual', @destination_table = N'Company', @destination_owner = N'dbo', @vertical_partition = N'false', @ins_cmd = N'CALL sp_MSins_dboCompany', @del_cmd = N'CALL sp_MSdel_dboCompany', @upd_cmd = N'SCALL sp_MSupd_dboCompany'
GO

use [Architect_Customers]
exec sp_addarticle @publication = N'Architect_Customers', @article = N'User', @source_owner = N'dbo', @source_object = N'User', @type = N'logbased', @description = null, @creation_script = null, @pre_creation_cmd = N'drop', @schema_option = 0x000000000803509F, @identityrangemanagementoption = N'manual', @destination_table = N'User', @destination_owner = N'dbo', @vertical_partition = N'false', @ins_cmd = N'CALL sp_MSins_dboUser', @del_cmd = N'CALL sp_MSdel_dboUser', @upd_cmd = N'SCALL sp_MSupd_dboUser'
GO

```

## 4.3 设置订阅

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083855378.png" alt="image-20201122083855378" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084015688.png" alt="image-20201122084015688" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084034540.png" alt="image-20201122084034540" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084140790.png" alt="image-20201122084140790" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084250306.png" alt="image-20201122084250306" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084308266.png" alt="image-20201122084308266" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084445213.png" alt="image-20201122084445213" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084502836.png" alt="image-20201122084502836" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084521236.png" alt="image-20201122084521236" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084549029.png" alt="image-20201122084549029" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084604953.png" alt="image-20201122084604953" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084633245.png" alt="image-20201122084633245" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084642516.png" alt="image-20201122084642516" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084658900.png" alt="image-20201122084658900" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084825532.png" alt="image-20201122084825532" style="zoom:50%;" />

生成的订阅脚本`NewSubscription.sql`:

```sql
-----------------开始: 要在发布服务器“DESKTOP-LDDT7JH”上运行的脚本-----------------
use [Architect_Customers]
exec sp_addsubscription @publication = N'Architect_Customers', @subscriber = N'DESKTOP-LDDT7JH', @destination_db = N'Architect_Customers_01', @subscription_type = N'Push', @sync_type = N'automatic', @article = N'all', @update_mode = N'read only', @subscriber_type = 0
exec sp_addpushsubscription_agent @publication = N'Architect_Customers', @subscriber = N'DESKTOP-LDDT7JH', @subscriber_db = N'Architect_Customers_01', @job_login = null, @job_password = null, @subscriber_security_mode = 0, @subscriber_login = N'sa', @subscriber_password = null, @frequency_type = 64, @frequency_interval = 0, @frequency_relative_interval = 0, @frequency_recurrence_factor = 0, @frequency_subday = 0, @frequency_subday_interval = 0, @active_start_time_of_day = 0, @active_end_time_of_day = 235959, @active_start_date = 20201122, @active_end_date = 99991231, @enabled_for_syncmgr = N'False', @dts_package_location = N'Distributor'
GO
-----------------结束: 要在发布服务器“DESKTOP-LDDT7JH”上运行的脚本-----------------
```

重复上述步骤，再创建一个从库`Architect_Customers_02`



## 4.4 验证是否同步

修改主库`Architect_Customers`都某个字段，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122095423352.png" alt="image-20201122095423352" style="zoom:50%;" />



## 4.5 应用程序读写分离

### 修改获取配置连接字符串的方式

`appsettings.json`

```json
{
  "ConnectionStrings": {
    "Write": "Data Source=.; Database=Architect_Customers; User ID=sa; Password=123456; MultipleActiveResultSets=True",
    "Read": [
      "Data Source=.; Database=Architect_Customers_01; User ID=sa; Password=123456; MultipleActiveResultSets=True",
      "Data Source=.; Database=Architect_Customers_02; User ID=sa; Password=123456; MultipleActiveResultSets=True",
      "Data Source=.; Database=Architect_Customers_03; User ID=sa; Password=123456; MultipleActiveResultSets=True"
    ]
  }
}
```

`SqlConnectionPool.cs`

```c#
public class SqlConnectionPool
    {
        public static string GetConnectionString(SqlConnectionType sqlConnectionType)
        {
            string conn = null;
            switch (sqlConnectionType)
            {
                case SqlConnectionType.Read:
                    conn = Dispatcher(ConfigurationManager.SqlConnectionStringRead);
                    break;
                case SqlConnectionType.Write:
                    conn = ConfigurationManager.SqlConnectionStringWrite;
                    break;
                default:
                    throw new Exception("wrong sqlConnectionType");
            }
            return conn;
        }
        private static int _Seed = 0;
        /// <summary>
        /// 调度分配--随机就是平均
        /// </summary>
        /// <param name="connectionStrings"></param>
        /// <returns></returns>
        private static string Dispatcher(string[] connectionStrings)
        {
            //string conn = connectionStrings[new Random(_Seed++).Next(0, connectionStrings.Length)];//平均策略
            string conn = connectionStrings[_Seed++ % connectionStrings.Length];//轮询--seed需要线程安全
            //能不能根据数据库的状况
            //权重--就是配置文件加点料  
            //2  3  4     9次请求  [1,1,2,2,2,3,3,3,3] 去平均
            return conn;
        }

        public enum SqlConnectionType
        {
            Read,
            Write
        }
    }
```

### 修改读写操作

`SqlHelper.cs`

使用` string connectString = GetConnectionString(SqlConnectionType.Read);`来获取连接字符串

```c#
   public class SqlHelper
    {
        public T Find<T>(int id) where T : BaseEntity
        {
            Type type = typeof(T);
            string sql = $"{SqlBuilder<T>.GetFindSql()}{id}";
            string connectString = GetConnectionString(SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connectString}");
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                    }

                    return t;
                }
            }

            return default(T);
        }
       
        public int Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T)
            //返回Id的insert语句
            //  _InsertSql = $"INSERT INTO [{type.GetMappingName()}] ({columnsString})                   VALUES({valuesString}) Select @@Identity ;";
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            string connectString = GetConnectionString(SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                object id = command.ExecuteScalar();
                return Convert.ToInt32(id);
            }
        }
    }
```



### 检验同步所用时间

`main.js`

```c#
        static void Main(string[] args)
        {
            try
            {
                SqlHelper helper = new SqlHelper();
                CompanyModel company1 = helper.Find<CompanyModel>(1);
                company1.CreateTime = DateTime.Now;
                company1.CompanyName += "-Administrator";
                int id = helper.Insert<CompanyModel>(company1);
                Console.WriteLine($"新增的CompanyId={id}");
                for (int i = 0; i < 100; i++)
                {
                    Console.WriteLine($"------------------开始查询------------------");
                    CompanyModel companyNew = helper.Find<CompanyModel>(id);
                    if (companyNew == null)
                    {
                        Console.WriteLine($"未同步到读库，继续{i}");
                    }
                    else
                    {
                        Console.WriteLine($"第{i}*500ms = {i*500/1000}s 同步到从库成功");
                        break;
                    }
                    Console.WriteLine(" ");

                    Thread.Sleep(500);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            Console.ReadLine();
        }
    }
```

输出：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122133936096.png" alt="image-20201122133936096" style="zoom:50%;" />



# 5. Asp.NetCore（3.1,5.0）

[Asp.Net Core 源码地址](https://github.com/aspnet/AspNetCore)

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-5.0)

## 5.1 扩展

扩展的两种方式：

1. Program
2. Startup

## 5.2 日志

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0)



### 第三方日志

[适用于 ASP.NET Core 的第三方日志记录框架](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#third-party-logging-providers)



### 5.2.1 log4Net

#### 使用步骤：

1. 安装包`Microsoft.Extensions.Logging.Log4Net.AspNetCore`

2. 添加`log4Net`日志组件

   - 方式一：在`Program`类中添加

   ```c#
           public static IHostBuilder CreateHostBuilder(string[] args) =>
               Host.CreateDefaultBuilder(args)
                   .ConfigureLogging(loggingBuilder => 
                   {
                       loggingBuilder.AddLog4Net();
                   })
                   .ConfigureWebHostDefaults(webBuilder =>
                   {
                       webBuilder.UseStartup<Startup>();
                   });
   ```

   其中， 方法`loggingBuilder.AddLog4Net()`默认读取项目更目录的配置文件`log4net.Config`

   - 方式二：在`Startup`类中添加

     ```C#
             public void Configure(......, ILoggerFactory loggerFactory)
             {
                 loggerFactory.AddLog4Net();
                 ......
             }
     ```

     

3. 添加`log4Net`组件的配置文件

   在项目的的根目录下，添加配置文件`log4net.Config`

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <log4net>
   	<!-- Define some output appenders -->
   	<appender name="rollingAppender" type="log4net.Appender.RollingFileAppender">
   		<file value="log\log.txt" />
   		<!--追加日志内容-->
   		<appendToFile value="true" />
   
   		<!--防止多线程时不能写Log,官方说线程非安全-->
   		<lockingModel type="log4net.Appender.FileAppender+MinimalLock" />
   
   		<!--可以为:Once|Size|Date|Composite-->
   		<!--Composite为Size和Date的组合-->
   		<rollingStyle value="Composite" />
   
   		<!--当备份文件时,为文件名加的后缀-->
   		<datePattern value="yyyyMMdd.TXT" />
   
   		<!--日志最大个数,都是最新的-->
   		<!--rollingStyle节点为Size时,只能有value个日志-->
   		<!--rollingStyle节点为Composite时,每天有value个日志-->
   		<maxSizeRollBackups value="20" />
   
   		<!--可用的单位:KB|MB|GB-->
   		<maximumFileSize value="3MB" />
   
   		<!--置为true,当前最新日志文件名永远为file节中的名字-->
   		<staticLogFileName value="true" />
   
   		<!--输出级别在INFO和ERROR之间的日志-->
   		<filter type="log4net.Filter.LevelRangeFilter">
   			<param name="LevelMin" value="ALL" />
   			<param name="LevelMax" value="FATAL" />
   		</filter>
   		<layout type="log4net.Layout.PatternLayout">
   			<conversionPattern value="%date [%thread] %-5level %logger - %message%newline"/>
   		</layout>
   	</appender>
   	<root>
   		<priority value="ALL"/>
   		<level value="ALL"/>
   		<appender-ref ref="rollingAppender" />
   	</root>
   </log4net>
   
   ```

   

4. 使用日志组件，比如在控制器中使用

   ```C#
       public class FirstController : Controller
       {
           private ILogger<FirstController> _logger;
           public FirstController(ILogger<FirstController> logger)
           {
               _logger = logger;
           }
   
           public IActionResult Index()
           {
               _logger.LogInformation("log in FirstController");
               return View();
           }
       }
   ```

5. 在`bin\log`文件夹中生成日志文件`log.txt`：

访问页面`https://localhost:5001/First`,日志文件追加输入如下日志

```md
2020-11-28 18:10:56,034 [4] INFO  AspNetCore31.Jumpstart.Controllers.FirstController - log in FirstController
```



#### ILoggerFactory： 日志的另一种使用方式

1. 依赖注入

   ```C#
       public class FirstController : Controller
       {
           private ILoggerFactory _loggerFactory;
   
           public FirstController(ILoggerFactory loggerFactory)
           {
               _loggerFactory = loggerFactory;
           }
       }
   ```

   

2. 使用：

   ```C#
           public IActionResult Index()
           {
               _loggerFactory.CreateLogger<FirstController>().LogInformation("log in FirstController");
               
               return View();
           }
   ```

   

## 5.3 部署项目

### 5.3.1 部署项目--命令行篇

可以用一个cmd—控制台进程—托管了网站

```md
dotnet AspNetCore31.Jumpstart.dll --urls="http://*:5177" --ip="127.0.0.1" --port=5177
```

需要copy 静态资源(wwwroot文件夹等)
控制台调试



### 5.3.2 部署项目--IIS篇

1. 该发布项目方式，相较于命令行发布，多生成了一个`web.config文件`

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <configuration>
     <location path="." inheritInChildApplications="false">
       <system.webServer>
         <handlers>
           <add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModuleV2" resourceType="Unspecified" />
         </handlers>
         <aspNetCore processPath="dotnet" arguments=".\AspNetCore31.Jumpstart.dll" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout" hostingModel="inprocess" />
       </system.webServer>
     </location>
   </configuration>
   <!--ProjectGuid: 30ba1a71-73cf-43a5-a764-a7052a609a84-->
   ```

   

2. 安装**AspNetCoreModuleV2**

   NetCore + ASP.NET Core Module支持进程内托管模型

3. IIS只是起到反向代理的作用

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201128201809683.png" alt="image-20201128201809683" style="zoom:80%;" />



IIS部署时，其实是把请求交给ModuleV2处理—转给dotnet—启动命令行那一套(IIS没有处理，只是一个代理)



### 5.3.3 理解Kestrel

- Kestrel就是一个简化版IIS web服务器：负责监听请求—转发到代码---完成响应
- Asp.NetCore本质是个控制台：运行起来是个网站---内置了一个Kestral（IIS服务器---所以来能脱离对IIS的依赖，所以才能做到跨平台）
- 有了kestrel，Asp.NetCore才能真正做到跨平台！

## 5.4 依赖注入

[ASP.NET Core 依赖注入](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0)



### 理解IOC&DI

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201129053949370.png" alt="image-20201129053949370" style="zoom:80%;" />



- 控制反转(Inversion of Control，IOC)是一种目标，让程序解耦，可以屏蔽细节
- 依赖倒置（Dependence Inversion Principle，DI），
- DI依赖注入是实现IOC的手段，

### 生命周期

```C#
  services.AddTransient<ITestServiceA, TestServiceA>();//瞬时,每次使用都创建一个实例
  services.AddSingleton<ITestServiceB, TestServiceB>();//单例
  services.AddScoped<ITestServiceC, TestServiceC>();//作用域单例,一次请求只创建一个实例
```



### Autofac

[github](https://github.com/autofac/Autofac)

[英文文档](https://autofaccn.readthedocs.io/en/latest/)

[中文文档](https://autofaccn.readthedocs.io/zh/latest/integration/aspnetcore.html)



[AspNetCore集成示例](https://github.com/autofac/Examples/tree/master/src/AspNetCoreExample)

#### 使用入门

- 安装

  在nuget中安装依赖包：`Autofac.Extensions.DependencyInjection`

  

- 添加`Autoface`组件

  每个版本的添加方式不同：

  - ASP.NET Core 1.1-2.2使用：

  ```C#
    public static void Main(string[] args)
    {
      // ASP.NET Core 1.1 - 2.2:
      // The ConfigureServices call here allows for
      // ConfigureContainer to be supported in Startup with
      // a strongly-typed ContainerBuilder.
      // AddAutofac() is a convenience method for
      // services.AddSingleton<IServiceProviderFactory<ContainerBuilder>>(new AutofacServiceProviderFactory())
      var host = new WebHostBuilder()
          .UseKestrel()
          .ConfigureServices(services => services.AddAutofac())
          .UseContentRoot(Directory.GetCurrentDirectory())
          .UseIISIntegration()
          .UseStartup<Startup>()
          .Build();
  
      host.Run();
    }
  ```

  - 下面是**ASP.NET Core 3+** 和 .NET Core 3+ generic hosting support的集成方式:

  ```C#
   .UseServiceProviderFactory(new AutofacServiceProviderFactory())//设置工厂来替换实例
  ```

  ```C#
          public static IHostBuilder CreateHostBuilder(string[] args) =>
              Host.CreateDefaultBuilder(args)
                  .ConfigureLogging(loggingBuilder => 
                  {
                      loggingBuilder.AddLog4Net();
                  })
                  .UseServiceProviderFactory(new AutofacServiceProviderFactory())//设置工厂来替换实例
                  .ConfigureWebHostDefaults(webBuilder =>
                  {
                      webBuilder.UseStartup<Startup>();
                  });
  ```

  

- 依赖注入

  `Startup类`

  在你的`Startup`类中 (各版本ASP.NET Core基本一致) 你可以使用 `ConfigureContainer` 访问 Autofac container builder 并且直接使用Autofac注册东西.

  ```C#
     public class Startup
      {
          //Asp.Net框架自身会调用该方法
          public void ConfigureContainer(ContainerBuilder containerBuilder)
          {
              // Add any Autofac modules or registrations.
              // This is called AFTER ConfigureServices so things you
              // register here OVERRIDE things registered in ConfigureServices.
              //
              // You must have the call to AddAutofac in the Program.Main
              // method or this won't be called.
              containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
          }
         ......
     }
  ```

   

#### 实例分析

`Startup.cs`

```C#
    public class Startup
    {
        //......
        public void ConfigureServices(IServiceCollection services)
        {
            //......
            services.AddTransient<ITestServiceA, TestServiceA>();//瞬时
            services.AddSingleton<ITestServiceB, TestServiceB>();//单例
            services.AddScoped<ITestServiceC, TestServiceC>();//作用域单例--一次请求一个实例
        }

        public void ConfigureContainer(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterType<TestServiceE>().As<ITestServiceE>().SingleInstance();
        }

```

`FirstController.cs`

```C#
    public class FirstController : Controller
    {
        //.....
        private readonly ITestServiceA _iTestServiceA;
        private readonly ITestServiceB _iTestServiceB;
        private readonly ITestServiceC _iTestServiceC;

        public FirstController(ILogger<FirstController> logger, ILoggerFactory loggerFactory, 
            ITestServiceA iTestServiceA,
            ITestServiceB iTestServiceB,
            ITestServiceC iTestServiceC)
        {
            // ....
            _iTestServiceA = iTestServiceA;
            _iTestServiceB = iTestServiceB;
            _iTestServiceC = iTestServiceC;

        }

        public IActionResult Index()
        {
            Console.WriteLine($"A:{_iTestServiceA.GetHashCode()}");
            Console.WriteLine($"B:{_iTestServiceB.GetHashCode()}");
            
            Console.WriteLine($"C:{_iTestServiceC.GetHashCode()}");
            Console.WriteLine($"C:{_iTestServiceC.GetHashCode()}");
            
            return View();
        }
    }
```

第一次访问`https://localhost:5001/First`输出：

```md
A:65718035
B:37901460
C:57733168
C:57733168
```

第二次访问`https://localhost:5001/First`输出：

```md
A:65718035
B:37901460
C:41149443
C:41149443
```

呈现的结果表明：

​    `ITestServiceA`--单例，被`Autoface`注册为单例覆盖了

​    `ITestServiceB`--单例，使用`IServiceCollection`注册为单例

   `ITestServiceC`--Scoped ,`IServiceCollection`注册为Scoped ,一个请求，共用一个实例

说明：

1. **Autoface与内置的`IServiceCollection`可共存**

2. **在`Autoface`的注册将覆盖在`IServiceCollection`的注册**

   因为使用Autoface的方法`ConfigureContainer()`

   ```c#
           public void ConfigureContainer(ContainerBuilder containerBuilder)
           {
               // Add any Autofac modules or registrations.
               // This is called AFTER ConfigureServices so things you
               // register here OVERRIDE things registered in ConfigureServices.
               //
               // You must have the call to AddAutofac in the Program.Main
               // method or this won't be called.
               containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
           }
   ```

   是在`ConfigureServices`方法之后调用的

   

#### Autofac.Module

`Startup.cs`

```c#
    public class Startup
    {
        //......
        
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllersWithViews();
        }

        //Asp.Net框架自身会调用该方法
        public void ConfigureContainer(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterModule<CustomAutofacModule>();
        }
```

自定一个类`CustomAutofacModule`,继承自`Autofac.Module`

```c#
public class CustomAutofacModule : Autofac.Module
    {
        protected override void Load(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
            containerBuilder.RegisterType<TestServiceC>().As<ITestServiceC>();
            containerBuilder.RegisterType<TestServiceB>().As<ITestServiceB>();
            containerBuilder.RegisterType<TestServiceD>().As<ITestServiceD>();
            containerBuilder.RegisterType<TestServiceE>().As<ITestServiceE>();
        }

    }
```





## 5.4 中间件

[ASP.NET Core 中间件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#create-a-middleware-pipeline-with-iapplicationbuilder)



### 什么是中间件

中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件：

- 选择是否将请求传递到管道中的下一个组件。
- 可在管道中的下一个组件前后执行工作。

请求委托用于生成请求管道。 请求委托处理每个 HTTP 请求。

使用 [Run](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.runextensions.run)[Map](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map) 和 [Use](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use) 扩展方法来配置请求委托。 可将一个单独的请求委托并行指定为匿名方法（称为并行中间件），或在可重用的类中对其进行定义。 这些可重用的类和并行匿名方法即为中间件，也叫中间件组件。



### 使用 IApplicationBuilder 创建中间件管道

ASP.NET Core 请求管道包含一系列请求委托，依次调用。 下图演示了这一概念。 沿黑色箭头执行。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/request-delegate-pipeline.png" alt="request-delegate-pipeline" style="zoom:100%;" />

#### Use

用 [Use](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use) 将多个请求委托链接在一起，

```c#
            app.Use(next =>
            {
                Console.WriteLine("This is middleware 1");
                return new RequestDelegate(
                    async context =>
                    {
                        await next.Invoke(context);
                    });
            });

            app.Use(next =>
            {
                Console.WriteLine("This is middleware 2");
                return new RequestDelegate(
                    async context =>
                    {
                        await next.Invoke(context);
                    });
            });
```

输出：

```md
This is middleware 2
This is middleware 1
```

注意，执行上述的代码后发现，中间件**执行顺序与加入管道的顺序相反**，原因，看源码[ApplicationBuilder](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Http/src/Builder/ApplicationBuilder.cs)：

```C#

namespace Microsoft.AspNetCore.Builder
{
    public class ApplicationBuilder : IApplicationBuilder
    {
        
        private readonly IList<Func<RequestDelegate, RequestDelegate>> _components = new List<Func<RequestDelegate, RequestDelegate>>();
        
        //......
       
       public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
        {
            _components.Add(middleware);
            return this;
        }

        public RequestDelegate Build()
        {  
            //声明一个RequestDelegate，默认处理步骤
            //默认最起始的委托（404中间件）
            RequestDelegate app = context =>
            {
                ......
                context.Response.StatusCode = StatusCodes.Status404NotFound;
                return Task.CompletedTask;    
            }; 

            foreach (var component in _components.Reverse())//集合反转 123进来  321执行--
            {
                //Func<RequestDelegate,RequestDelegate> 是321的顺序
                app = component(app);
                //404--->middleware3-->middleware2-->middleware1  最终的结果Application其实就是middleware1
            }

            return app;
        }
    }
}
```

其中，

```C#

            foreach (var component in _components.Reverse())//集合反转 123进来  321执行--
            {
                //Func<RequestDelegate,RequestDelegate> 是321的顺序
                app = component(app);
                //404--->middleware3-->middleware2-->middleware1  最终的结果Application其实就是middleware1
            }
```

反转中间件集合，反向执行，



##### UseExtensions

`IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware);`使用有点复杂

故，有一个扩展方法，[UseExtensions](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Http.Abstractions/src/Extensions/UseExtensions.cs) 如下：

```c#
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;

namespace Microsoft.AspNetCore.Builder
{
    /// <summary>
    /// Extension methods for adding middleware.
    /// </summary>
    public static class UseExtensions
    {
        /// <summary>
        /// Adds a middleware delegate defined in-line to the application's request pipeline.
        /// </summary>
        /// <param name="app">The <see cref="IApplicationBuilder"/> instance.</param>
        /// <param name="middleware">A function that handles the request or calls the given next function.</param>
        /// <returns>The <see cref="IApplicationBuilder"/> instance.</returns>
        public static IApplicationBuilder Use(this IApplicationBuilder app, Func<HttpContext, Func<Task>, Task> middleware)
        {
            return app.Use(next =>
            {
                return context =>
                {
                    Func<Task> simpleNext = () => next(context);
                    return middleware(context, simpleNext);
                };
            });
        }
    }
}
```

使用如下，

```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
            app.Use(async (context, next) =>
            {
                Console.WriteLine("app.Use(async (context, next) => This is middleware 1--start");
                await next.Invoke();
                Console.WriteLine("app.Use(async (context, next) => This is middleware 1--end");
            });

            app.Use(async (context, next) =>
            {
                Console.WriteLine("app.Use(async (context, next) => This is middleware 2--start");
                await next.Invoke();
                Console.WriteLine("app.Use(async (context, next) => This is middleware 2--end");
            });
    }
}
```

,其中`next` 参数表示管道中的下一个委托。 可通过不调用 next 参数使管道短路

执行上述代码，输出：

```md
app.Use(async (context, next) => This is middleware 1--start
app.Use(async (context, next) => This is middleware 2--start
app.Use(async (context, next) => This is middleware 2--end
app.Use(async (context, next) => This is middleware 1--end
```

这个执行顺序和加入顺序一致，从这个角度看，比使用`app.Use(next =>{})`好理解多了



#### Run

[Run](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.runextensions.run) 委托不会收到 `next` 参数，

第一个 `Run` 委托**始终为终端**，**用于终止管道**。 **`Run` 是一种约定**。

```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.Use(async (context, next) =>
        {
            // Do work that doesn't write to the Response.
            await next.Invoke();
            // Do logging or other work that doesn't write to the Response.
        });

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from 2nd delegate.");
        });
    }
}
```



### 中间件顺序

下图显示了 ASP.NET Core MVC 和 Razor Pages 应用的完整请求处理管道。 你可以在典型应用中了解现有中间件的顺序，以及在哪里添加自定义中间件。 你可以完全控制如何重新排列现有中间件，或根据场景需要注入新的自定义中间件。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/middleware-pipeline.svg" alt="middleware-pipeline" style="zoom:80%;" />

上图中的“终结点”中间件为相应的应用类型（MVC 或 Razor Pages）执行筛选器管道。 



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/mvc-endpoint.svg" alt="mvc-endpoint" style="zoom:80%;" />

下面的 `Startup.Configure` 方法按照建议的顺序增加与安全相关的中间件组件：

```C#
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseDatabaseErrorPage();
    }
    else
    {
        app.UseExceptionHandler("/Error");
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();
    // app.UseCookiePolicy();

    app.UseRouting();
    // app.UseRequestLocalization();
    // app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();
    // app.UseSession();
    // app.UseResponseCaching();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
```



### 对中间件管道进行分支

#### Map扩展

[Map](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map) 扩展用作约定来创建管道分支。 `Map` 基于给定请求路径的匹配项来创建请求管道分支。 如果请求路径以给定路径开头，则执行分支。

```c#
public class Startup
{
    private static void HandleMapTest1(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            await context.Response.WriteAsync("Map Test 1");
        });
    }

    private static void HandleMapTest2(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            await context.Response.WriteAsync("Map Test 2");
        });
    }

    public void Configure(IApplicationBuilder app)
    {
        app.Map("/map1", HandleMapTest1);

        app.Map("/map2", HandleMapTest2);

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from non-Map delegate. <p>");
        });
    }
}
```

#### MapWhen

 [MapWhen](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapwhenextensions.mapwhen) 基于给定谓词的结果创建请求管道分支。

`Func<HttpContext, bool>` 类型的任何谓词均可用于将请求映射到管道的新分支。

```C#
public class Startup
{
    private static void HandleBranch(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            var branchVer = context.Request.Query["branch"];
            await context.Response.WriteAsync($"Branch used = {branchVer}");
        });
    }

    public void Configure(IApplicationBuilder app)
    {
        app.MapWhen(context => context.Request.Query.ContainsKey("branch"),
                               HandleBranch);

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from non-Map delegate. <p>");
        });
    }
}
```

| 请求                          | 响应                         |
| :---------------------------- | :--------------------------- |
| localhost:1234                | Hello from non-Map delegate. |
| localhost:1234/?branch=master | Branch used = master         |



#### UseWhen

[UseWhen](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.usewhenextensions.usewhen) 也基于给定谓词的结果创建请求管道分支。 与 `MapWhen` 不同的是，如果这个分支不发生短路或包含终端中间件，则会重新加入主管道：

```C#
public class Startup
{
    private void HandleBranchAndRejoin(IApplicationBuilder app, ILogger<Startup> logger)
    {
        app.Use(async (context, next) =>
        {
            var branchVer = context.Request.Query["branch"];
            logger.LogInformation("Branch used = {branchVer}", branchVer);

            // Do work that doesn't write to the Response.
            await next();
            // Do other work that doesn't write to the Response.
        });
    }

    public void Configure(IApplicationBuilder app, ILogger<Startup> logger)
    {
        app.UseWhen(context => context.Request.Query.ContainsKey("branch"),
                               appBuilder => HandleBranchAndRejoin(appBuilder, logger));

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from main pipeline.");
        });
    }
}
```

在前面的示例中，响应 "Hello from main pipeline." 是为所有请求编写的。 如果请求中包含查询字符串变量 `branch`，则在重新加入主管道之前会记录其值。



###  内置中间件

ASP.NET Core 附带以下中间件组件。 “顺序”列提供备注，以说明中间件在请求处理管道中的放置，以及中间件可能会终止请求处理的条件。 如果中间件让请求处理管道短路，并阻止下游中间件进一步处理请求，它被称为“终端中间件”。 若要详细了解短路，请参阅[使用 IApplicationBuilder 创建中间件管道](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#create-a-middleware-pipeline-with-iapplicationbuilder)部分。

| 中间件                                                       | 描述                                                         | 顺序                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| [身份验证](https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/identity?view=aspnetcore-5.0) | 提供身份验证支持。                                           | 在需要 `HttpContext.User` 之前。 OAuth 回叫的终端。          |
| [授权](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.authorizationappbuilderextensions.useauthorization) | 提供身份验证支持。                                           | 紧接在身份验证中间件之后。                                   |
| [Cookie 策略](https://docs.microsoft.com/zh-cn/aspnet/core/security/gdpr?view=aspnetcore-5.0) | 跟踪用户是否同意存储个人信息，并强制实施 cookie 字段（如 `secure` 和 `SameSite`）的最低标准。 | 在发出 cookie 的中间件之前。 示例：身份验证、会话、MVC (TempData)。 |
| [CORS](https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0) | 配置跨域资源共享。                                           | 在使用 CORS 的组件之前。 由于[此错误](https://github.com/dotnet/aspnetcore/issues/23218)，`UseCors` 当前必须在 `UseResponseCaching` 之前运行。 |
| [诊断](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/error-handling?view=aspnetcore-5.0) | 提供新应用的开发人员异常页、异常处理、状态代码页和默认网页的几个单独的中间件。 | 在生成错误的组件之前。 异常终端或为新应用提供默认网页的终端。 |
| [转接头](https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-5.0) | 将代理标头转发到当前请求。                                   | 在使用已更新字段的组件之前。 示例：方案、主机、客户端 IP、方法。 |
| [运行状况检查](https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-5.0) | 检查 ASP.NET Core 应用及其依赖项的运行状况，如检查数据库可用性。 | 如果请求与运行状况检查终结点匹配，则为终端。                 |
| [标头传播](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-5.0#header-propagation-middleware) | 将 HTTP 标头从传入的请求传播到传出的 HTTP 客户端请求中。     |                                                              |
| [HTTP 方法重写](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.httpmethodoverrideextensions) | 允许传入 POST 请求重写方法。                                 | 在使用已更新方法的组件之前。                                 |
| [HTTPS 重定向](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0#require-https) | 将所有 HTTP 请求重定向到 HTTPS。                             | 在使用 URL 的组件之前。                                      |
| [HTTP 严格传输安全性 (HSTS)](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0#http-strict-transport-security-protocol-hsts) | 添加特殊响应标头的安全增强中间件。                           | 在发送响应之前，修改请求的组件之后。 示例：转接头、URL 重写。 |
| [MVC](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/overview?view=aspnetcore-5.0) | 用 MVC/Razor Pages 处理请求。                                | 如果请求与路由匹配，则为终端。                               |
| [OWIN](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/owin?view=aspnetcore-5.0) | 与基于 OWIN 的应用、服务器和中间件进行互操作。               | 如果 OWIN 中间件处理完请求，则为终端。                       |
| [响应缓存](https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware?view=aspnetcore-5.0) | 提供对缓存响应的支持。                                       | 在需要缓存的组件之前。 `UseCORS` 必须在 `UseResponseCaching` 之前。 |
| [响应压缩](https://docs.microsoft.com/zh-cn/aspnet/core/performance/response-compression?view=aspnetcore-5.0) | 提供对压缩响应的支持。                                       | 在需要压缩的组件之前。                                       |
| [请求本地化](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/localization?view=aspnetcore-5.0) | 提供本地化支持。                                             | 在对本地化敏感的组件之前。                                   |
| [终结点路由](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-5.0) | 定义和约束请求路由。                                         | 用于匹配路由的终端。                                         |
| [SPA](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.spaapplicationbuilderextensions.usespa) | 通过返回单页应用程序 (SPA) 的默认页面，在中间件链中处理来自这个点的所有请求 | 在链中处于靠后位置，因此其他服务于静态文件、MVC 操作等内容的中间件占据优先位置。 |
| [会话](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/app-state?view=aspnetcore-5.0) | 提供对管理用户会话的支持。                                   | 在需要会话的组件之前。                                       |
| [静态文件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-5.0) | 为提供静态文件和目录浏览提供支持。                           | 如果请求与文件匹配，则为终端。                               |
| [URL 重写](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/url-rewriting?view=aspnetcore-5.0) | 提供对重写 URL 和重定向请求的支持。                          | 在使用 URL 的组件之前。                                      |
| [WebSockets](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-5.0) | 启用 WebSockets 协议。                                       | 在接受 WebSocket 请求所需的组件之前。                        |



### 自定义中间件

[编写中间件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/write?view=aspnetcore-5.0)



编写一个中间件：通过传入区域性测试中间件。 例如，请求 `https://localhost:5001/?culture=no`。

#### 定义中间件类

```C#
using Microsoft.AspNetCore.Http;
using System.Globalization;
using System.Threading.Tasks;

namespace Culture
{
    public class RequestCultureMiddleware
    {
        private readonly RequestDelegate _next;

        public RequestCultureMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var cultureQuery = context.Request.Query["culture"];
            if (!string.IsNullOrWhiteSpace(cultureQuery))
            {
                var culture = new CultureInfo(cultureQuery);

                CultureInfo.CurrentCulture = culture;
                CultureInfo.CurrentUICulture = culture;

            }

            // Call the next delegate/middleware in the pipeline
            await _next(context);
        }
    }
}

```

中间件类必须包括：

- 具有类型为 [RequestDelegate](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.requestdelegate) 的参数的公共构造函数。

- 名为 `Invoke` 或 `InvokeAsync` 的公共方法。

  此方法必须：

  - 返回 `Task`。
  - 接受类型 [HttpContext](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.httpcontext) 的第一个参数。



#### 中间件扩展方法

以下通过 [IApplicationBuilder](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder)的扩展方法 公开中间件：

定义一个扩展方法，封装`builder.UseMiddleware<RequestCultureMiddleware>()`，

```C#
using Microsoft.AspNetCore.Builder;

namespace Culture
{
    public static class RequestCultureMiddlewareExtensions
    {
        public static IApplicationBuilder UseRequestCulture(
            this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestCultureMiddleware>();
        }
    }
}
```

#### 使用中间件

以下代码通过 `Startup.Configure` 调用中间件：


```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.UseRequestCulture();

        app.Run(async (context) =>
        {
            await context.Response.WriteAsync(
                $"Hello {CultureInfo.CurrentCulture.DisplayName}");
        });
    }
}
```



## 5.5 筛选器(Filter)

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#dependency-injection)



### 筛选器类型

每种筛选器类型都在筛选器管道中的不同阶段执行：

- [授权筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#authorization-filters)最先运行，用于确定是否已针对请求为用户授权。 如果请求未获授权，授权筛选器可以让管道短路。
- [资源筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#resource-filters)：
  - 授权后运行。
  - [OnResourceExecuting](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iresourcefilter.onresourceexecuting) 在筛选器管道的其余阶段之前运行代码。 例如，`OnResourceExecuting` 在模型绑定之前运行代码。
  - [OnResourceExecuted](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iresourcefilter.onresourceexecuted) 在管道的其余阶段完成之后运行代码。
- [操作筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#action-filters)：
  - 在调用操作方法之前和之后立即运行代码。
  - 可以更改传递到操作中的参数。
  - 可以更改从操作返回的结果。
  - 页面 **不** 支持 Razor 。
- [异常筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#exception-filters)在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。
- [结果筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#result-filters)在执行操作结果之前和之后立即运行代码。 仅当操作方法成功执行时，它们才会运行。 对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。

下图展示了筛选器类型在筛选器管道中的交互方式。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/filter-pipeline-2.png" alt="filter-pipeline-2" style="zoom:75%;" />

多种筛选器接口具有相应属性，这些属性可用作自定义实现的基类。

筛选器属性：

- [ActionFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute)
- [ExceptionFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.exceptionfilterattribute)
- [ResultFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resultfilterattribute)
- [FormatFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.formatfilterattribute)
- [ServiceFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.servicefilterattribute)
- [TypeFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.typefilterattribute)



### Filter的示例

通过这个示例，串讲`Filte`的相关知识点。

自定义一个`Filter`,名为`CustomExceptionFilterAttribute`，继承自` ExceptionFilterAttribute`

`CustomEceptionFilterAttribute.cs`完整代码：

```C#
    public class CustomExceptionFilterAttribute : ExceptionFilterAttribute
    {
        private readonly ILogger<CustomExceptionFilterAttribute> _logger;
        private readonly IModelMetadataProvider _modelMetadataProvider;
        public CustomExceptionFilterAttribute(ILogger<CustomExceptionFilterAttribute> logger
            , IModelMetadataProvider modelMetadataProvider)
        {
            this._modelMetadataProvider = modelMetadataProvider;
            this._logger = logger;
        }

        /// <summary>
        /// 异常发生，但是没有处理时
        /// 异常之后得写日志
        /// </summary>
        /// <param name="context"></param>
        public override void OnException(ExceptionContext context)
        {
            if (!context.ExceptionHandled)
            {
                this._logger.LogError($"{context.HttpContext.Request.RouteValues["controller"]} is Error");
                if (this.IsAjaxRequest(context.HttpContext.Request))//header看看是不是XMLHttpRequest
                {
                    context.Result = new JsonResult(new
                    {
                        Result = false,
                        Msg = context.Exception.Message
                    });//中断式---请求到这里结束了，不再继续Action
                }
                else
                {
                    var result = new ViewResult { ViewName = "~/Views/Shared/Error.cshtml" };
                    result.ViewData = new ViewDataDictionary(_modelMetadataProvider, context.ModelState);
                    result.ViewData.Add("Exception", context.Exception);
                    context.Result = result;
                }
                context.ExceptionHandled = true;
            }
        }

        private bool IsAjaxRequest(HttpRequest request)
        {
            string header = request.Headers["X-Requested-With"];
            return "XMLHttpRequest".Equals(header);
        }
    }
```



#### 取消和设置短路

通过设置提供给筛选器方法的 [ResourceExecutingContext](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resourceexecutingcontext) 参数上的 [Result](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resourceexecutingcontext.result#Microsoft_AspNetCore_Mvc_Filters_ResourceExecutingContext_Result) 属性，可以使筛选器管道短路。 例如，以下资源筛选器将阻止执行管道的其余阶段：

```C#
                if (this.IsAjaxRequest(context.HttpContext.Request))//header看看是不是XMLHttpRequest
                {
                    context.Result = new JsonResult(new
                    {
                        Result = false,
                        Msg = context.Exception.Message
                    });//中断式---请求到这里结束了，不再继续Action
                }
```



#### 错误页

如何在错误页面提供异常信息呢？

```c#
        var result = new ViewResult { ViewName = "~/Views/Shared/Error.cshtml" };
        result.ViewData = new ViewDataDictionary(_modelMetadataProvider, context.ModelState);
        result.ViewData.Add("Exception", context.Exception);
        context.Result = result;
```

关键代码：

```c#
       result.ViewData.Add("Exception", context.Exception);
```

在`Error.cshtml`显示异常信息：

```C#
//.......

@{
    Exception exception = base.ViewData["Exception"] as Exception;
}
//.....

<h2>@exception.Message</h2>
```



#### 依赖注入

我们注意到，`CustomExceptionFilterAttribute`需要某些服务，

```C#
    public class CustomExceptionFilterAttribute : ExceptionFilterAttribute
    {
        private readonly ILogger<CustomExceptionFilterAttribute> _logger;
        private readonly IModelMetadataProvider _modelMetadataProvider;
        
        public CustomExceptionFilterAttribute(ILogger<CustomExceptionFilterAttribute> logger
            , IModelMetadataProvider modelMetadataProvider)
        {
            this._modelMetadataProvider = modelMetadataProvider;
            this._logger = logger;
        }
       
        // ......
    }
```

如果在控制器或及其方法中使用：

```C#
    [CustomExceptionFilterAttribute]//语法错误，无法编译
    public IActionResult Exce()
    {
        throw new Exception("my Exce");
        return View();
    }
```

上述代码直接使用`[CustomExceptionFilterAttribute]`是无法编译通过的，



官方解释：

>  如果将筛选器作为属性实现并直接添加到控制器类或操作方法中，则该筛选器不能由[依赖关系注入](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0) (DI) 提供构造函数依赖项。 无法由 DI 提供构造函数依赖项，因为：
>
> - 属性在应用时必须提供自己的构造函数参数。
> - 这是属性工作原理上的限制。
>
> **以下筛选器支持从 DI 提供的构造函数依赖项：**
>
> - **[ServiceFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.servicefilterattribute)**
> - **[TypeFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.typefilterattribute)**
> - **在属性上实现 [IFilterFactory](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory)。**



如何为`CustomExceptionFilterAttribute`实现依赖注入呢？，请看下一节【Filter的依赖注入】

### Filter的依赖注入

`Filter`需要某个服务，怎么去获取呢？全程是依赖注入的，怎么为Filte进行依赖注入呢？

##### Filter特性的四种注入方式

###### 全局注册

全局的注册不需要添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
         services.AddControllersWithViews(options => { //定义全局的Filters， 所有的控制器、操作都使用
                options.Filters.Add(typeof(CustomExceptionFilterAttribute));
            });
```



###### ServiceFilter

第一步：添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Add service filters.
    services.AddScoped<CustomExceptionFilterAttribute>();
}
```

第二步：`ServiceFilter` 属性将从 DI 中检索 `CustomExceptionFilterAttribute` 的实例

```c#
        [ServiceFilter(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



###### TypeFilter

使用`TypeFilter`,不需要添加`CustomExceptionFilterAttribute`到 DI 容器中，只是使用`TypeFilter(typeof())`即可

```C#
        [TypeFilter(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



###### IFilterFactory

 就是Filter的工厂，任何环节都可以用工厂代替Filter，`IFilterFactory`里面有ServiceProvider,所以可以IOC了

第一步：

定义一个名为`CustomIOCFilterFactoryAttribute`的特性，继承接口`IFilterFactory`

```C#
    /// <summary>
    /// 基于完成Filter的依赖注入
    /// </summary>
    public class CustomIOCFilterFactoryAttribute : Attribute, IFilterFactory
    {
        private readonly Type _FilterType = null;

        public CustomIOCFilterFactoryAttribute(Type type)
        {
            this._FilterType = type;
        }
        public bool IsReusable => true;

        public IFilterMetadata CreateInstance(IServiceProvider serviceProvider)
        {
            return (IFilterMetadata)serviceProvider.GetService(this._FilterType);
        }
    }
```

第二步：

添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Add service filters.
    services.AddScoped<CustomExceptionFilterAttribute>();
}
```

第三步：

使用`[CustomIOCFilterFactory(typeof())]`特性

```C#
        [CustomIOCFilterFactory(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



### 筛选器作用域

可以将筛选器添加到管道中的以下三个 *范围* 之一：

- 在控制器操作上使用属性。 筛选器属性不能应用于 Razor 页面处理程序方法。

  如以下代码所示， 控制器`FilterController`的`Exce()`操作使用了使用筛选器`CustomExceptionFilterAttribute`

  ```C#
      public class FilterController : Controller
      {
          //[CustomExceptionFilterAttribute]//语法错误，无法编译
          [ServiceFilter(typeof(CustomExceptionFilterAttribute))]
          public IActionResult Exce()
          {
              throw new Exception("my Exce");
              return View();
          }
      }
  ```

  

- 在控制器或页上使用特性 Razor 。

- 针对所有控制器、操作和页面全局 Razor 显示，

  如以下代码所示， 所有的控制器、操作都将使用筛选器`CustomExceptionFilterAttribute`

  ```C#
  public void ConfigureServices(IServiceCollection services)
  {
      services.AddControllersWithViews(options => //定义全局的Filters， 所有的控制器、操作都使用
     {
          options.Filters.Add(typeof(CustomExceptionFilterAttribute));
      });
  }
  ```





### 筛选器执行顺序

当管道的某个特定阶段有多个筛选器时，作用域可确定筛选器执行的默认顺序。 全局筛选器涵盖类筛选器，类筛选器又涵盖方法筛选器。



在筛选器嵌套模式下，筛选器的 after 代码会按照与 before 代码相反的顺序运行。 筛选器序列：

- 全局筛选器的 before 代码。
  - 控制器 *before* 和 Razor 页面筛选器的前代码。
    - 操作方法筛选器的 before 代码。
    - 操作方法筛选器的 after 代码。
  - 控制器 *after* 和 Razor 页面筛选器后的代码。
- 全局筛选器的 after 代码。



执行顺序还跟筛选器的类型有关

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/filter-pipeline-2.png" alt="filter-pipeline-2" style="zoom:75%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201129153951272.png" alt="image-20201129153951272" style="zoom:75%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/mvc-endpoint.svg" alt="mvc-endpoint" style="zoom:80%;" />

#### 示例代码

##### Action级Filter

定义一个`CustomActionFilterAttribute` , 继承自`CustomActionFilterAttribute`

```C#
    public class CustomActionFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnActionExecuted->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
    }
```

抽象类`ActionFilterAttribute`实现的接口如下：

```C#
public abstract class ActionFilterAttribute : Attribute, IActionFilter, IFilterMetadata, IAsyncActionFilter, IAsyncResultFilter, IOrderedFilter, IResultFilter
```

在控制器的方法中是使用该`Filter`:

```c#
  public class FilterController : Controller
    {
        //......
      
        [CustomActionFilterAttribute]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
    }
```

`ExcOrder.cshtml`

```cshtml
@{
    ViewData["Title"] = "Filter执行顺序";
    Console.WriteLine($"This is FilterController View Info");
}
<h4>Filter执行顺序</h4>
```

访问页面:`https://localhost:5001/filter/excorder`, 控制台输出：

```md
//......
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
//......
```



##### Contronller级Filter

再定义一个`Filter`:`CustomControllerFilterAttribute`, 将其使用在`Controller`上

```
    public class CustomControllerFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnActionExecuted ->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
```

```C#
    [CustomControllerFilter]
    public class FilterController : Controller
    {
         //......
        [CustomActionFilterAttribute]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
        //......
    }
```

控制台输出：

```md
//......
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
This CustomControllerFilterAttribute OnResultExecuted->Order:0
//......
```



##### 全局Filter

再定义一个`Filter`:CustomGlobalFilterAttribute, 将其注册为全局Filter

````C#
   public class CustomGlobalFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnActionExecuted->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
````

```C#
        public void ConfigureServices(IServiceCollection services)
        {
             //......
            services.AddControllersWithViews(options => { //定义全局的Filters， 所有的控制器、操作都使用
                options.Filters.Add(typeof(CustomGlobalFilterAttribute));
            });
            //......
        }
```

控制台输出：

```md
//......
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
//......
```

修饰下输出，方便对调用顺序查看：

```C#
//......
//以下为ActionFilter
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
	This CustomControllerFilterAttribute OnActionExecuting->Order:0
		This CustomActionFilterAttribute OnActionExecuting->Order:0
			This is FilterController aciton： ExcOrder
		This CustomActionFilterAttribute OnActionExecuted->Order:0
	This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
    
    
//以下为OnResultFilter
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
	This CustomControllerFilterAttribute OnResultExecuting->Order:0
		This CustomActionFilterAttribute OnResultExecuting->Order:0
			This is FilterController View ExcOrder
		This CustomActionFilterAttribute OnResultExecuted->Order:0
	This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
//......
```



### 重写默认顺序

可以通过实现 [IOrderedFilter](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter) 来重写默认执行序列。 `IOrderedFilter` 公开了 [Order](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter.order#Microsoft_AspNetCore_Mvc_Filters_IOrderedFilter_Order) 属性来确定执行顺序，该属性优先于作用域。 具有较低的 `Order` 值的筛选器：

- 在具有较高的 `Order` 值的筛选器之前运行 before 代码。
- 在具有较高的 `Order` 值的筛选器之后运行 after 代码。

使用构造函数参数设置了 `Order` 属性,



通俗来讲，就是

- **`Order`属性值默认值为：0；**
- **`Order`属性值越小的`filter`，越先执行。**

用上一讲的示例，来验证下，把`CustomActionFilterAttribute `的属性值变成`-1`,

    [CustomControllerFilter]
    public class FilterController : Controller
    {
         //......
        [CustomActionFilterAttribute(Order = -1)]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
        //......
    }
控制台输出：

```c#
//......
This CustomActionFilterAttribute OnActionExecuting->Order:-1
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnActionExecuted->Order:-1
This CustomActionFilterAttribute OnResultExecuting->Order:-1
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuted->Order:-1
//......
```

美化后的输出格式：

```md
//......
//以下为ActionFilter
This CustomActionFilterAttribute OnActionExecuting->Order:-1
	This CustomGlobalFilterAttribute OnActionExecuting->Order:0
		This CustomControllerFilterAttribute OnActionExecuting->Order:0
			This is FilterController aciton： ExcOrder
		This CustomControllerFilterAttribute OnActionExecuted ->Order:0
	This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnActionExecuted->Order:-1

//以下为OnResultFilter
This CustomActionFilterAttribute OnResultExecuting->Order:-1
	This CustomGlobalFilterAttribute OnResultExecuting->Order:0
		This CustomControllerFilterAttribute OnResultExecuting->Order:0
			This is FilterController View ExcOrder
		This CustomControllerFilterAttribute OnResultExecuted->Order:0
	This CustomGlobalFilterAttribute OnResultExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuted->Order:-1
//......
```



### Q&A

- **Q:那什么时候用中间件？什么时候用Filter？**

  **A**：粒度不同的

  ​       Filter是MVC的，中间件能知道action controller，中间件是全部请求都要通过的，Filter可以针对方法/controller，合适选择



## 5.6 认证

[Asp.net MVC中使用Cookie认证](https://www.cnblogs.com/iampkm/p/4699788.html)

[cookie不使用身份验证ASP.NET Core Identity](https://docs.microsoft.com/zh-CN/aspnet/core/security/authentication/cookie?view=aspnetcore-5.0)

### 5.6.1 基于Session传统的认证

#### 登录

`AccountController.cs`

```C#
    /// <summary>
    /// 登录---常规登录靠的是Cookie/Session
    /// </summary>
    public class AccountController : Controller
    {
        private readonly ILogger<AccountController> _logger;
        public AccountController(ILogger<AccountController> logger)
        {
            _logger = logger; ;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpGet]//响应get请求
        public ViewResult Login()
        {
            return View();
        }

        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Login(string name, string password, string verify)
        {
            string verifyCode = base.HttpContext.Session.GetString("CheckCode");
            if (verifyCode != null && verifyCode.Equals(verify, StringComparison.CurrentCultureIgnoreCase))
            {
                if ("KKK".Equals(name) && "123456".Equals(password))
                {
                    CurrentUser currentUser = new CurrentUser()
                    {
                        Id = 123,
                        Name = "KKK",
                        Account = "Administrator",
                        Email = "57265177",
                        Password = "123456",
                        LoginTime = DateTime.Now
                    };

                    base.HttpContext.Session.SetString("CurrentUser", Newtonsoft.Json.JsonConvert.SerializeObject(currentUser));
             
                    return base.Redirect("/Home/Index");
                }
                else
                {
                    base.ViewBag.Msg = "账号密码错误";
                }
            }
            else
            {
                base.ViewBag.Msg = "验证码错误";
            }
            return View();
        }

        public ActionResult VerifyCode()
        {
            string code = "";
            Bitmap bitmap = VerifyCodeHelper.CreateVerifyCode(out code);
            base.HttpContext.Session.SetString("CheckCode", code);
            MemoryStream stream = new MemoryStream();
            bitmap.Save(stream, ImageFormat.Gif);
            return File(stream.ToArray(), "image/gif");
        }

        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Logout()
        {
            #region Cookie
            base.HttpContext.Response.Cookies.Delete("CurrentUser");
            #endregion Cookie

            #region Session
            CurrentUser sessionUser = base.HttpContext.GetCurrentUserBySession();
            if (sessionUser != null)
            {
                this._logger.LogDebug(string.Format("用户id={0} Name={1}退出系统", sessionUser.Id, sessionUser.Name));
            }
            base.HttpContext.Session.Remove("CurrentUser");
            base.HttpContext.Session.Clear();
            #endregion Session

            #region MyRegion
            //HttpContext.User.Claims//其他信息
            HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme).Wait();
            #endregion
            return RedirectToAction("Index", "Home"); ;
        }
    }
```

`CookieSessionHelper`

```c#
 public static class CookieSessionHelper
    {
        public static void SetCookies(this HttpContext httpContext, string key, string value, int minutes = 30)
        {
            httpContext.Response.Cookies.Append(key, value, new CookieOptions
            {
                Expires = DateTime.Now.AddMinutes(minutes)
            });
        }
        public static void DeleteCookies(this HttpContext httpContext, string key)
        {
            httpContext.Response.Cookies.Delete(key);
        }

        public static string GetCookiesValue(this HttpContext httpContext, string key)
        {
            httpContext.Request.Cookies.TryGetValue(key, out string value);
            return value;
        }

        public static CurrentUser GetCurrentUserBySession(this HttpContext context)
        {
            string sUser = context.Session.GetString("CurrentUser");
            if (sUser == null)
            {
                return null;
            }
            else
            {
                CurrentUser currentUser = Newtonsoft.Json.JsonConvert.DeserializeObject<CurrentUser>(sUser);
                return currentUser;
            }
        }
    }
```

`VerifyCodeHelper.cs`

```c#
public class VerifyCodeHelper
    {
        public static Bitmap CreateVerifyCode(out string code)
        {
            //建立Bitmap对象，绘图
            Bitmap bitmap = new Bitmap(200, 60);
            Graphics graph = Graphics.FromImage(bitmap);
            graph.FillRectangle(new SolidBrush(Color.White), 0, 0, 200, 60);
            Font font = new Font(FontFamily.GenericSerif, 48, FontStyle.Bold, GraphicsUnit.Pixel);
            Random r = new Random();
            string letters = "ABCDEFGHIJKLMNPQRSTUVWXYZ0123456789";

            StringBuilder sb = new StringBuilder();

            //添加随机的五个字母
            for (int x = 0; x < 5; x++)
            {
                string letter = letters.Substring(r.Next(0, letters.Length - 1), 1);
                sb.Append(letter);
                graph.DrawString(letter, font, new SolidBrush(Color.Black), x * 38, r.Next(0, 15));
            }
            code = sb.ToString();

            //混淆背景
            Pen linePen = new Pen(new SolidBrush(Color.Black), 2);
            for (int x = 0; x < 6; x++)
                graph.DrawLine(linePen, new Point(r.Next(0, 199), r.Next(0, 59)), new Point(r.Next(0, 199), r.Next(0, 59)));
            return bitmap;
        }
    }
```

`Login.cshtml`

```cshtml
@model AspNetCore31.Jumpstart.Models.CurrentUser
@{
    ViewBag.Title = "登录";
}

<h2>@ViewBag.Title。</h2>
<div class="row">
    <div class="col-md-8">
        <section id="loginForm">
            @using (Html.BeginForm("Login", "Account", new { sid = "123", Account = "Eleven" },
               FormMethod.Post, true, new { @class = "form-horizontal", role = "form" }))
            {
                @Html.AntiForgeryToken()
                <h4>使用本地帐户登录。</h4>
                <hr />
                @Html.ValidationSummary(true)
                <div class="form-group">
                    @Html.LabelFor(m => m.Name, new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.TextBoxFor(m => m.Name, new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    @Html.LabelFor(m => m.Password, new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.PasswordFor(m => m.Password, new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    @Html.Label("VerifyCode", "VerifyCode", new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.TextBox("verify", "", new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    <div class="col-md-10">
                        <img id="img_code" alt="验证码图片" class="img"  src="/Account/VerifyCode" title="点击刷新">
                    </div>
                </div>
                <div class="form-group">
                    <div class="col-md-offset-2 col-md-10">
                        <input type="submit" value="登录" class="btn btn-default" />
                        @base.ViewBag.Msg
                    </div>
                </div>
            }
        </section>
    </div>
</div>
```

`_LoginPartial.cshtml`

```cshtml
@using AspNetCore31.Jumpstart.Models;
@using AspNetCore31.Jumpstart.Utility;
@{
    CurrentUser currentUser = base.Context.GetCurrentUserBySession();
    /*var currentUser = base.Context.User.Identity.Name == null ? null : new CurrentUser()
    {
        Name = base.Context.User.Identity.Name
    };*/
}
@if (currentUser != null)
{
    using (Html.BeginForm("Logout", "Account", FormMethod.Post, new { id = "logoutForm", @class = "navbar-right" }))
    {
        @Html.AntiForgeryToken()

        <ul class="nav navbar-nav navbar-right">
            <li>
                @Html.ActionLink("你好 " + currentUser.Name + "!", "Index", "Home", routeValues: null, htmlAttributes: new { title = currentUser.Name })
            </li>
            <li><a href="javascript:document.getElementById('logoutForm').submit()">注销</a></li>
        </ul>
    }
}
else
{
    <ul class="nav navbar-nav navbar-right">
        <li>@Html.ActionLink("登录", "Login", "Account", routeValues: null, htmlAttributes: new { id = "loginLink" })</li>
    </ul>
}

```



#### 校验

传统的登录校验的方式是：

- 在登录成功后，把当前用户信息存储在`Cookie`或`Session`中

  本例是放在`Session`中

  ```C#
  public ActionResult Login(string name, string password, string verify){
   
      //校验用户名和密码正确后，把用户信息存储在Cookie或Session中 
      CurrentUser currentUser = new CurrentUser()
                  {
                      Id = 123,
                      Name = "KKK",
                      Account = "Administrator",
                      Email = "57265177",
                      Password = "123456",
                      LoginTime = DateTime.Now
                  };
                   base.HttpContext.Session.SetString("CurrentUser"
                     ,JsonConvert.SerializeObject(currentUser));
                  }
  ```

  

- 创建一个Filter（本例为：`CustomCheckLoginActionFilter`），用于检测是否登录，如果未登录，跳转至登录页

  ```C#
      public class CustomCheckLoginActionFilter : ActionFilterAttribute
      {
          #region Identity
          private readonly ILogger<CustomCheckLoginActionFilter> _logger;
          private readonly IModelMetadataProvider _modelMetadataProvider;
          public CustomCheckLoginActionFilter(Microsoft.Extensions.Logging.ILogger<CustomCheckLoginActionFilter> logger
              )
          {
              this._logger = logger;
          }
          #endregion
  
          public override void OnActionExecuting(ActionExecutingContext context)
          {
              CurrentUser currentUser = context.HttpContext.GetCurrentUserBySession();
              if (currentUser == null)
              {
                  //if (this.IsAjaxRequest(context.HttpContext.Request))
                  //{ }
                  context.Result = new RedirectResult("~/Account/Login");
              }
              else
              {
                  this._logger.LogDebug($"{currentUser.Name} 访问系统");
              }
          }
          private bool IsAjaxRequest(HttpRequest request)
          {
              string header = request.Headers["X-Requested-With"];
              return "XMLHttpRequest".Equals(header);
          }
      }
  ```

- 在需要登录才能访问的`Controller`或`Action`放置`CustomCheckLoginActionFilter`

  ```C#
      [TypeFilter(typeof(CustomCheckLoginActionFilter))]
      public class NeedLoginController : Controller
      {
          public IActionResult Index()
          {
              return View();
          }
      }
  ```

   

### 5.6.2 Asp.Net Core的认证模型

《Asp.Net Core 3 框架揭秘》第19章

> 认证是一个旨在确认请求访问这真实身份的过程，与认证相关的还有其它两个基本的操作--登录和注销。要真正理解认证、登录和注销这个3个核心的操作本，就需要对Asp.Net Core 采用的基本“票据”的认证机制有基本的了解。
>
> Asp.Net Core应用的认证实现在一个名为`AuthenticationMiddleware`的中间件中，该中间件在处理分发给它的请求时，会按照指定的认证方案(Authentication Scheme）从请求中提取能够验证用户真实身份的数据，我们一般将该数据成为安全令牌（Security Token）。Asp.Net Core 应用下的安全令牌被称为认证票据（Authentiaction Ticket），所以Asp.Net Core应用采取的是基于票据的认证方式



#### 基于Cookie的认证

##### 启用认证中间件`AddAuthentication`

下面我们采用Asp.Net Core提供的基于Cookie的认证方案。顾名思义，该认证方案采用Cookie来携带认证票据。

添加`AddAuthentication`认证中间件

并且通过` AuthenticationBuilder`的扩展放`AddCookie`使用`Cookie`认证方案

```C#
 public class Startup
 {
         public void ConfigureServices(IServiceCollection services)
        {
            //........
             
            //添加认证中间件
            services.AddAuthentication(options =>
            {
                //设置默认的认证方案
                options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme; //"返回Cookes，Cookie认证方案的默认方案名称"
            }).AddCookie(options => //使用Cookie认证方案
            {
                options.LoginPath = new PathString("/Account/Login"); // 登录地址
                options.AccessDeniedPath = new PathString("/Home/Privacy"); //没有授权跳转页面
            });
             
            //......
```

使用认证中间件

```C#
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
        {
            //......
            app.UseRouting();
            app.UseAuthentication(); //认证：检测是否登录、登录者是谁？并赋值给HttpContext.User
            //......
```

##### 登录

检测用户和和密码都正确后，使用`HttpContext.SignInAsync()`方法进行登录操作

```C#
    public class AccountController : Controller
    {        public ActionResult Login(string name, string password, string verify)
        {
            string verifyCode = base.HttpContext.Session.GetString("CheckCode");
            if (verifyCode != null && verifyCode.Equals(verify, StringComparison.CurrentCultureIgnoreCase))
            {
                if ("KKK".Equals(name) && "123456".Equals(password))
                {
                    var claims = new List<Claim>()
                                        {
                                            new Claim(ClaimTypes.Name,name),
                                            new Claim("password",password),//可以写入任意数据
                                            new Claim("Account","Administrator")
                                        };
                    var userPrincipal = new ClaimsPrincipal(new ClaimsIdentity(claims, "Customer"));

                    //cookie认证方案:CookieAuthenticationDefaults.AuthenticationScheme
                    //--用户信息:userPrincipal
                    //---过期时间:ExpiresUtc
                    HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, userPrincipal, new AuthenticationProperties
                    {
                        ExpiresUtc = DateTime.UtcNow.AddMinutes(30),
                    }).Wait();//没用await

                    return base.Redirect("/Home/Index");
                }
                else
                {
                    base.ViewBag.Msg = "账号密码错误";
                }
            }
            else
            {
                base.ViewBag.Msg = "验证码错误";
            }
            return View();
        }
```

上述代码，创建一个类型为`ClaimsPrincipal`的对象，用于存储基于声明（Claim）的用户信息，

```C#
               var claims = new List<Claim>()
                                        {
                                            new Claim(ClaimTypes.Name,name),
                                            new Claim("password",password),//可以写入任意数据
                                            new Claim("Account","Administrator")
                                        };
                var userPrincipal = new ClaimsPrincipal(new ClaimsIdentity(claims, "Customer"));
```

在登录时，在`HttpContext.SignInAsync()`方法中传入,因为在之前使用了认证中间

```C#
app.UseAuthentication(); //认证：检测是否登录、登录者是谁？并赋值给HttpContext.User
```

认证中间件会将其自动将用户信息保存在`HttpContext.User.Identity`,

登录成功后，可以通过

```c#
     var currUser = HttpContext.User.Identity;
```

获取当前用户的信息，

##### 使用认证

**授权通过`[Authorize]`属性控制，当没有任何参数时，它只检查用户身份通过身份认证（Authentication）**

```C#
//[TypeFilter(typeof(CustomCheckLoginActionFilter))]
[Authorize]
public class NeedLoginController : Controller
{
    public IActionResult Index()
    {
        var currUser = HttpContext.User.Identity.Name;
        return View();
    }
} 
```


##### 注销

注销操作使用的是` HttpContext.SignOutAsync()`方法：

```C#
        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Logout()
        {
            //HttpContext.User.Claims//其他信息
            HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme).Wait();
            return RedirectToAction("Index", "Home"); 
        }
```

其中，第一个参数需要传入认证方案的名称，即：字符串常量`CookieAuthenticationDefaults.AuthenticationScheme`（字符串为：Cookies）



### 5.6.3 基于Session、Cookie认证的局限性

基于Session、Cookie的认证无做跨多个实例进行身份认证，即：无法做分布式认证。

解决方案是：使用Token模式

从一个认证服务器中获取token，再使用token访问站点的多个实例。



## 5.7 EntityFrameworkCore

### 5.7.1 使用方式

#### 常规使用new 

在方法`OnConfiguring`中配置连接字符串

```C#
    public partial class JDDbContext : DbContext
    {
        public JDDbContext()
        {
        }
        
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            var builder = new Microsoft.Extensions.Configuration.ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile("appsettings.json");
            var configuration = builder.Build();
            var conn = configuration.GetConnectionString("JDDbConnection");
            
            optionsBuilder.UseSqlServer(conn);
         }
    }

```

使用

```C#
            using (JDDbContext context = new JDDbContext())
            {
                var user = context.Set<User>().First(u => u.Id > 1);
                base.ViewBag.UserName = user.Name;
            }

```



#### DI容器注入

- 定义

```C#
        public JDDbContext(DbContextOptions options) : base(options)
        {
            Console.WriteLine("This is JDDbContext DbContextOptions");
        }
```

**注意：重点指定DbContextOptions有外部配置**

- 使用

> AddDbContext:
>
> Registers the given context as a service in the Microsoft.Extensions.DependencyInjection.IServiceCollection.
>  You use this method when using dependency injection in your application, such
>   as with ASP.NET. For more information on setting up dependency injection, see
>    http://go.microsoft.com/fwlink/?LinkId=526890.

```C#
        public void ConfigureServices(IServiceCollection services)
        {
              //...
            
              services.AddEntityFrameworkSqlServer()
                  .AddDbContext<JDDbContext>(options =>
                  {
                      //读取配置文件中的链接字符串
                      options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection")
                          );  
                  });
        }
```

或

- 定义

```c #
        public JDDbContext(DbContextOptions<JDDbContext> options) : base(options)
        {
            Console.WriteLine("This is JDDbContext DbContextOptions");
        }
```

注意：参数是泛型参数`DbContextOptions<JDDbContext> options`

- 依赖注入

`AddDbContext()`

```C#
            services.AddDbContext<JDDbContext>(options =>
            {
                options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection"));
            });
```

或者`AddDbContextPool()`提供线程池

```c#
            //提供了数据库连接池（DbContextPool）,推荐使用
            services.AddDbContextPool<JDDbContext>(options =>
            {
                options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection"));
            });
```



- 使用

  ```C#
      public class NeedLoginController : Controller
      {
          private readonly JDDbContext _dbContext ;
          public NeedLoginController(JDDbContext jdDbContext)
          {
              _dbContext = jdDbContext;
          }
  
          public IActionResult Index()
          {
              ...
              var user = _dbContext.Set<User>().First(u => u.Id > 1);
  
              return View();
          }
      }
  ```

  

# 6.微服务架构

## 6.1 单体架构

单体应用时代：应用程序就是一个项目，在一个进程里面运行

### 优点

- 开发简单，集中管理，没有分布式的损耗

### 缺点

- 不好维护，升级困难，无法快捷迭代
- 稳定性差



## 6.2 微服务架构

微服务架构（Microservice Architecture）是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。

概念：把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

定义：围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

本质：用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。



### 与其他架构对比

#### 单体

![1612423180189](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423180189.png)



#### 垂直拆分

![1612423198812](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423198812.png)



#### 分布式服务-微服务

![1612423264050](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423264050.png)



#### SOA

![1612422941408](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612422941408.png)

SOA是为重用，微服务架构是为了重写

SOA更水平，微服务是垂直的

SOA自上而下，微服务自下而上



### 践行微服务

#### 服务通信

![1612423030691](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423030691.png)



![1612423062188](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423062188.png)

![1612423076170](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423076170.png)

   

#### 网关

说到微服务架构，就是网关必须有

![1612423125853](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612423125853.png)



## 6.3 跨域

跨域是浏览器的限制行为,后台App直接调用WebApi无跨越问题,即：

跨域问题是前端，后台无跨域一说



### 跨域问题的解决

- UseCors

- 在`Controller`的方法中

  ```C#
     [Route("api/[controller]/[action]")]
      [ApiController]
      public class UsersController : ControllerBase
      {
                   [HttpGet]
  
          public Users GetUserByID(int id)
          {
              c
              //throw new Exception("1234567");
              string idParam = base.HttpContext.Request.Query["id"];
              var user = _userList.FirstOrDefault(users => users.UserID == id);
              if (user == null) 
              {
                  throw new HttpResponseException(HttpStatusCode.NotFound);
              }
              return user;
  
          }
  ```

  在Http请求头添加

  ```C#
  base.HttpContext.Response.Headers.Add("Access-Control-Allow-Origin", "*");//允许跨域
  ```

  

## 6.4 多实例运行

```powershell
dotnet ApsNetCoreWebApi.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet ApsNetCoreWebApi.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet ApsNetCoreWebApi.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```



## 6.5 Consul

课程：[Course 11、12]

多个服务实例运行后，如何管理？服务注册和发现

- Nginx

  可以屏蔽服务实例细节
  单纯是负载均衡
  **被动获取实例，有变化是不知道** ，**即需要人工配置服务，而不是自动发现服务**

  请求和响应均通过Nginx

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1618469213278.png" alt="1618469213278" style="zoom:67%;" />



- Consul

  负载均衡(屏蔽实例细节)
  **服务注册与发现**，即服务在启动时，自己要在Consulz注册（登记）服务
  健康检查
  
  请求和响应均通过不经过Consul，消费者直接与具体的服务进行通信
  
  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1618469221770.png" alt="1618469221770" style="zoom:80%;" />

 使用流程图

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1618477810362.png" alt="1618477810362" style="zoom:80%;" />



### 下载运行

官网：https://www.consul.io/

命令行启动：

在cmd（powershell不行）

```powershell
consul_1.6.2.exe agent –dev
```

浏览器访问：
http://localhost:8500



### WebAPI进行注册

Nuget安装 Consul 包，然后进行服务注册

```C#
    public void ConfigureServices(IServiceCollection services)
    {
        this.Configuration.ConsulRegist(); //实例启动时执行，且只执行一次
    }
```

`ConsulHelper.cs`

```C#
    /// <summary>
    /// 自己封装的注册类
    /// </summary>
    public static class ConsulHelper
    {
        public static void ConsulRegist(this IConfiguration configuration)
        {
            ConsulClient client = new ConsulClient(c =>
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);//命令行参数必须传入
            //int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
            client.Agent.ServiceRegister(new AgentServiceRegistration()
            {
                ID = $"serive:{port}", //"service" + Guid.NewGuid(),//唯一的
                Name = "ZhaoxiUserService",//组名称-Group
                Address = ip,//其实应该写ip地址
                Port = port,//不同实例
                //Tags = new string[] { weight.ToString() },//标签
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
            });
            Console.WriteLine($"http://{ip}:{port}完成注册");
        }
    }
```

其中，

配置心跳地址：

```C#
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
```



参数`HTTP`设置心跳地址，即会定时访问`HealthController`的`Index`方法:

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class HealthController : ControllerBase
    { 
        private readonly ILogger<HealthController> _logger;
        private readonly IConfiguration _iConfiguration;
        public HealthController(ILogger<HealthController> logger, IConfiguration configuration)
        {
            _logger = logger;
            this._iConfiguration = configuration;
        }

        [HttpGet]
        [Route("Index")]//拼接到控制器上的route
        public IActionResult Index()
        {
            this._logger.LogWarning($"This is HealthController {this._iConfiguration["Port"]}");
            return Ok();//HttpStatusCode--200
        }
    }
```

参数`DeregisterCriticalServiceAfter`是设置无响应后时间后把对应的服务移除



开启多个服务实例：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

http://localhost:8500/ui/dc1/services

![1612513019583](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612513019583.png)



### 客户端发现服务

在客户端web项目中，应用引用`Consual`包。

```C#
    public class TestController : Controller
    {
        public IActionResult Info()
        {
            List<Users> userList = new List<Users>();
            string resultUrl = null;
            
            #region 通过consul去发现这些服务地址
            {
                using (ConsulClient client = new ConsulClient(c =>
                {
                    c.Address = new Uri("http://localhost:8500/");
                    c.Datacenter = "dc1";
                }))
                {
                    var dictionary = client.Agent.Services().Result.Response;
                    string message = "";
                    foreach (var keyValuePair in dictionary)
                    {
                        AgentService agentService = keyValuePair.Value;
                        this._logger.LogWarning($"{agentService.Address}:{agentService.Port} {agentService.ID} {agentService.Service}");//找的是全部服务 全部实例  其实可以通过ServiceName筛选
                        message += $"{agentService.Address}:{agentService.Port};";
                    }
                    //获取当前consul的全部服务
                    base.ViewBag.Message = message;
                }
            }
            #endregion
                  
            base.ViewBag.Users = userList;
            base.ViewBag.Url = resultUrl;
            return View();
    }
```



访问客户端：https://localhost:44360/Test/Info，输出如下：

```html
127.0.0.1:5728;127.0.0.1:5727;127.0.0.1:5726;
```

解决了服务的注册和发现的问题，服务的IP和端口改变了也不会影响到客户端的访问，因为**客户端是通过访问统一的地址**：

```C#
string url = "http://ZhaoxiUserService/api/users/get";
```

来访问API，同时这样也起到的负载均衡的作用:

```C#
        private static int iSeed = 0;//没考虑溢出问题

        public IActionResult Info()
        {
            List<Users> userList = new List<Users>();
            string resultUrl = null;

            #region 调用---负载均衡
            {
                //string url = "http://localhost:5726/api/users/get";
                //string url = "http://localhost:5727/api/users/get";
                //string url = "http://localhost:5728/api/users/get";
                string url = "http://ZhaoxiUserService/api/users/get";
                //consul解决使用服务名字 转换IP:Port----DNS

                Uri uri = new Uri(url);
                string groupName = uri.Host;
                using (ConsulClient client = new ConsulClient(c =>
                {
                    c.Address = new Uri("http://localhost:8500/");
                    c.Datacenter = "dc1";
                }))
                {
                    var dictionary = client.Agent.Services().Result.Response;
                    var list = dictionary.Where(k => k.Value.Service.Equals(groupName, StringComparison.OrdinalIgnoreCase));//获取consul上全部对应服务实例
                    KeyValuePair<string, AgentService> keyValuePair = new KeyValuePair<string, AgentService>();
                    //拿到3个地址，只需要从中选择---可以在这里做负载均衡--
                    //{
                    //    keyValuePair = list.First();//直接拿的第一个
                    //}
                    //{
                    //    var array = list.ToArray();
                    //    //随机策略---平均策略
                    //    keyValuePair = array[new Random(iSeed++).Next(0, array.Length)];
                    //}
                    //{
                    //    var array = list.ToArray();
                    //    //轮询策略---平均策略
                    //    keyValuePair = array[iSeed++ % array.Length];
                    //}
                    {
                        //权重---注册服务时指定权重，分配时获取权重并以此为依据
                        List<KeyValuePair<string, AgentService>> pairsList = new List<KeyValuePair<string, AgentService>>();
                        foreach (var pair in list)
                        {
                            int count = int.Parse(pair.Value.Tags?[0]);
                            for (int i = 0; i < count; i++)
                            {
                                pairsList.Add(pair);
                            }
                        }
                        keyValuePair = pairsList.ToArray()[new Random(iSeed++).Next(0, pairsList.Count())];
                    }
                    resultUrl = $"{uri.Scheme}://{keyValuePair.Value.Address}:{keyValuePair.Value.Port}{uri.PathAndQuery}";
                    string result = WebApiHelperExtend.InvokeApi(resultUrl);
                    userList = Newtonsoft.Json.JsonConvert.DeserializeObject<List<Users>>(result);
                }
            }
            #endregion
            base.ViewBag.Users = userList;
            base.ViewBag.Url = resultUrl;
            return View();
        }
```

访问客户端：https://localhost:44360/Test/Info，

### 权重

API启动时，添加自定义参数 `--weight=8` 增加该服务(端口为：5728）的权重，

```C#
 dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728 --weight=8
```

在**API项目**中，Program.cs，

```C#
        public static void Main(string[] args)
        {
            var config = new ConfigurationBuilder()
             .SetBasePath(Directory.GetCurrentDirectory())
             .AddCommandLine(args)//支持命令行
             .Build();

            CreateHostBuilder(args).Build().Run();
        }
```

添加对命令行的支持，以便在`IConfiguration`能根据

```C#
configuration["weight"]
```

获取参数。

在**注册服务**时：

```C#
    public static class ConsulHelper
    {
        public static void ConsulRegist(this IConfiguration configuration)
        {
            ConsulClient client = new ConsulClient(c =>
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);//命令行参数必须传入
            int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
            client.Agent.ServiceRegister(new AgentServiceRegistration()
            {
                ID = $"serive:{port}", //"service" + Guid.NewGuid(),//唯一的
                Name = "ZhaoxiUserService",//组名称-Group
                Address = ip,//其实应该写ip地址
                Port = port,//不同实例
                Tags = new string[] { weight.ToString() },//标签
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
            });
            Console.WriteLine($"http://{ip}:{port}完成注册");
        }
    }
}
```

获取参数`--weigh`,

```C#
int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
```

**放入`Tags`字段中**

```C#
Tags = new string[] { weight.ToString() },//标签
```



**客户端**调用时，**通过`Tags`获取`--weigh`值**，然后根据该值设置权重策略

```C#
                    //权重---注册服务时指定权重，分配时获取权重并以此为依据
                    List<KeyValuePair<string, AgentService>> pairsList = new List<KeyValuePair<string, AgentService>>();
                    foreach (var pair in list)
                    {
                        int count = int.Parse(pair.Value.Tags?[0]);
                        for (int i = 0; i < count; i++)
                        {
                            pairsList.Add(pair);
                        }
                    }
                    keyValuePair = pairsList.ToArray()[new Random(iSeed++).Next(0, pairsList.Count())];
                    resultUrl = $"{uri.Scheme}://{keyValuePair.Value.Address}:{keyValuePair.Value.Port}{uri.PathAndQuery}";
                    string result = WebApiHelperExtend.InvokeApi(resultUrl);
```

![1612512970399](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612512970399.png)

根据权重, 比如，3个API地址权重分别是：1, 1, 8，生成10个`AgentService`,存放在临时列表`pairsList`中，然后取列表下标的随机数。其中有8个端口是5278的服务API，它的命中概率最大，这样就实现权重策略。



## 6.6 Ocelot

课程：[Course12]

### Gateway(网关)



**为什么需要网关？**
        有了Consul，使用服务名即可访问。但手机、web端等外部访问者仍然需要和N多服务器交互，需要记忆他们的服务器地址、端口号等。一旦内部发生修改，很麻烦，而且有时候内部服务器是不希望外界直接访问的—需要路由功能！

​        网关的最核心功能就是路由

### 网关的功能

- 路由---核心功能
- 集群负载均衡

实现了客户端和服务实例的隔绝—保护—节约IP—提高效率

网关本身也可以做集群（用Nigx）



**好处**：

- 各个业务系统轻松独立维护服务器；
- 复用权限校验；
- 限流、熔断、降级、收费等。



### Ocelot

Ocelot就是一个提供了请求路由、安全验证等功能的API网关微服务



#### 搭建网关

独立进程，完成网关代请求：

1 独立webapi程序(3.1)
2 nuget-ocelot
3 startup配置中间件
4 配置文件

5.运行

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```



**新建一个[WebApi]模板项目，添加以下包**：

```xml
    <PackageReference Include="Ocelot" Version="13.8.0" />
```

 **替换所有的中间件**：

```C#
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddOcelot();
            //services.AddControllers();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            app.UseOcelot();
            //if (env.IsDevelopment())
            //{
            //    app.UseDeveloperExceptionPage();
            //}

            //app.UseHttpsRedirection();

            //app.UseRouting();

            //app.UseAuthorization();

            //app.UseEndpoints(endpoints =>
            //{
            //    endpoints.MapControllers();
            //});
        }
    }
```

**配置Ocelot**,

```json
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                 .ConfigureAppConfiguration(c =>
                 {
                     c.AddJsonFile("configuration.json", optional:  false,  reloadOnChange: true);
                 })
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
    }
```

`configuration.json`

```json
////*****************************单地址********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } //可以多个，自行负载均衡
      ],
      "UpstreamPathTemplate": "/T5726/{url}", //网关地址--url变量   //冲突的还可以加权重Priority
      "UpstreamHttpMethod": [ "Get", "Post" ]
    }
  ]
}
```

- Downstream:下游，API方

- Upstream：上游，，客户端方，调用方

  

上面的配置可以通俗的解读为:

客户端调用`/T5726/{url}`, 网关将访问映射为：`http://locahost:5726/api/{url}`



**运行**：

启动API：

```C#
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
```

这个接口有数据：http://localhost:5726/api/users/get,返回：

```json
[{"userID":1,"userName":"User-01","userEmail":null},{"userID":2,"userName":"User-02","userEmail":null},{"userID":3,"userName":"User-03","userEmail":null},{"userID":4,"userName":"User-04","userEmail":null},{"userID":5,"userName":"User-05","userEmail":null},{"userID":6,"userName":"User-06","userEmail":null}]
```



启动网关：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

访问网关：

```powershell
http://localhost:6299/T5726/users/get
```

返回：

```json
[{"userID":1,"userName":"User-01","userEmail":null},{"userID":2,"userName":"User-02","userEmail":null},{"userID":3,"userName":"User-03","userEmail":null},{"userID":4,"userName":"User-04","userEmail":null},{"userID":5,"userName":"User-05","userEmail":null},{"userID":6,"userName":"User-06","userEmail":null}]
```



#### 配置多个API实例

修改配置文件`configuration.json`

```json
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } //可以多个，自行负载均衡
      ],
      "UpstreamPathTemplate": "/T5726/{url}", //网关地址--url变量   //冲突的还可以加权重Priority
      "UpstreamHttpMethod": [ "Get", "Post" ]
    },
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5727 //服务端口
        }
      ],
      "UpstreamPathTemplate": "/T5727/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ]
    },
   {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5728 //服务端口
        }
      ],
      "UpstreamPathTemplate": "/T5728/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ]
    }
  ]
}
```

新增2个端口：5727和5728两个端口的 API

开启3个API：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

重启网关：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

访问3个地址都有数据：

```powershell
http://localhost:6299/T5726/users/get
http://localhost:6299/T5727/users/get
http://localhost:6299/T5728/users/get
```



#### 单地址访问多API

上一节配置多个API实例的时候，客户端还是的访问多个地址，获取数据：

```powershell
http://localhost:6299/T5726/users/get
http://localhost:6299/T5727/users/get
http://localhost:6299/T5728/users/get
```

那如何实现单地址访问多个API的目标，

修改配置文件`configuration.json`

```json
//*****************************单地址多实例负载均衡********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } //可以多个，自行负载均衡
        ,
        {
          "Host": "localhost",
          "Port": 5727 //服务端口
        },
        {
          "Host": "localhost",
          "Port": 5728 //服务端口
        }
      ],
      "UpstreamPathTemplate": "/T5/{url}", //网关地址--url变量   //冲突的还可以加权重Priority
      "UpstreamHttpMethod": [ "Get", "Post" ],
      "LoadBalancerOptions": {
        "Type": "RoundRobin" //轮询      LeastConnection-最少连接数的服务器   NoLoadBalance不负载均衡
      }
    }
  ]
}
```

重启网关：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

单地址访问多API, 并**实现了负载均衡**

```powershell
http://localhost:6299/T5/users/get
```



#### Ocelot+Consul+Polly

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1618468571114.png" alt="1618468571114" style="zoom:80%;" />

整合网关和服务注册发现
调用者只负责调用网关
网关去跟Consul交互
**Consul维护实例，Consul—完成了集群管理，发现—健康检查—下线**



运行Consul：

```powershell
consul_1.6.2.exe agent –dev
```



运行3个API服务：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

访问下http://localhost:5726/api/users/get，检查是否返回数据，有数据，说明服务启动成功



查看Consul中发现的服务:http://localhost:8500

![1612513040343](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612513040343.png)

配置Ocelot:

[*.MicroServiceGateway]项目的配置文件 `configuration.json`修改为：

```Json
////*****************************单地址多实例负载均衡+Consul********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "UpstreamPathTemplate": "/TConsul/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ],
      "ServiceName": "ZhaoxiUserService", //consul服务名称
      "LoadBalancerOptions": {
        "Type": "RoundRobin" //轮询      LeastConnection-最少连接数的服务器   NoLoadBalance不负载均衡
      },
      "UseServiceDiscovery": true
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": "http://127.0.0.1:6299", //网关对外地址
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul" //由Consul提供服务发现
    }
  }
}
```

重点是`"UseServiceDiscovery": true`表明使用服务自动发现，而不是像之前那样写死：

```json
"DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 5726 //服务端口
        } ,
                ,
        {
          "Host": "localhost",
          "Port": 5727 //服务端口
        },
        {
          "Host": "localhost",
          "Port": 5728 //服务端口
        }
      ]
```



至于如何发现，在配置节点`GlobalConfiguration`进行配置：

```json
"GlobalConfiguration": {
    "BaseUrl": "http://127.0.0.1:6299", //网关对外地址
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul" //由Consul提供服务发现
    }
  }
```

使用`Consul`（其地址：localhost:8500）提供API服务地址，对外的网关地址为：http://127.0.0.1:6299



此时，要Ocelot中使用Consul，需要在网关项目中引用包：

```xml
   <PackageReference Include="Ocelot.Provider.Consul" Version="13.8.0" />
```

并添加Consul支持：

```C#
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddOcelot().AddConsul(); 
        }
```

启动网关项目：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

访问地址：http://localhost:6299/TConsul/users/get，返回数据：

```json
[{"userID":1,"userName":"User-01","userEmail":null},{"userID":2,"userName":"User-02","userEmail":null},{"userID":3,"userName":"User-03","userEmail":null},{"userID":4,"userName":"User-04","userEmail":null},{"userID":5,"userName":"User-05","userEmail":null},{"userID":6,"userName":"User-06","userEmail":null}]
```



至此，我们可得到**OCelot+Consul**的好处：

- **客户端不用管理API地址，仅仅是通过一个网关地址：http://localhost:6299/TConsul/users/get 即可**
- **负载均衡：刷新页面，会发现依次轮询3个API服务**
- **API服务器的健康检查，下线和重新上线**



####   

**Polly**是一种.NET弹性和瞬态故障处理库，允许我们以非常顺畅和线程安全的方式来执诸如行恢复等策略。
重试，断路，超时，故障

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612522693907.png" alt="1612522693907" style="zoom:33%;" />

**缓存**---可以有效提升性能
**限流**---限制了单位时间内的访问量(失败一部分比垮掉强)
**熔断**---保险丝，单位时间错误超过多少就直接停掉，多长时间后再恢复
           合并请求



要Ocelot中使用Polly，需要在网关项目中引用包：

```xml
  <PackageReference Include="Ocelot.Provider.Polly" Version="13.8.0" />
```

并添加Polly支持：

```C#
        public void ConfigureServices(IServiceCollection services)
        {
               services.AddOcelot().AddConsul().AddPolly();
        }
```

添加配置文件：

```json
//*****************************单地址多实例负载均衡+Consul+Polly********************************
{
  "ReRoutes": [
    {
      "DownstreamPathTemplate": "/api/{url}", //服务地址--url变量
      "DownstreamScheme": "http",
      "UpstreamPathTemplate": "/consul/{url}", //网关地址--url变量
      "UpstreamHttpMethod": [ "Get", "Post" ],
      "ServiceName": "ZhaoxiUserService", //consul服务名称
      "LoadBalancerOptions": {
        "Type": "RoundRobin" //轮询      LeastConnection-最少连接数的服务器   NoLoadBalance不负载均衡
      },
      "UseServiceDiscovery": true,
      "QoSOptions": {
        "ExceptionsAllowedBeforeBreaking": 3, //允许多少个异常请求
        "DurationOfBreak": 10000, // 熔断的时间，单位为ms
        "TimeoutValue": 10000 //如果下游请求的处理时间超过多少则自如将请求设置为超时 默认90秒
      }
      //"RateLimitOptions": {
      //  "ClientWhitelist": [], //白名单
      //  "EnableRateLimiting": true,
      //  "Period": "5m", //1s, 5m, 1h, 1d  jeffzhang
      //  "PeriodTimespan": 5, //多少秒之后客户端可以重试
      //  "Limit": 5 //统计时间段内允许的最大请求数量
      //},
      //"FileCacheOptions": {
      //  "TtlSeconds": 10
      //} //"缓存"
    }
  ],
  "GlobalConfiguration": {
    "BaseUrl": "http://127.0.0.1:6299", //网关对外地址
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul" //由Consul提供服务发现
    },
    //"RateLimitOptions": {
    //  "QuotaExceededMessage": "Too many requests, maybe later? 11", // 当请求过载被截断时返回的消息
    //  "HttpStatusCode": 666 // 当请求过载被截断时返回的http status
    //}
  }
```

启动网关项目：

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```

**启动后，为了测试各个功能，可以直接修改配置文件，配置能动态生效，不用重启程序**

访问测试数据地址：http://localhost:6299/Consul/users/get，



配置节点说明：

##### 缓存

```C#
      "FileCacheOptions": {
        "TtlSeconds": 10
      } //"缓存"
    }
```

 缓存数据10秒



##### 限流

限制了单位时间内的访问量(失败一部分比垮掉强)

```json
{
  "ReRoutes": [
    {
      //......,
      "RateLimitOptions": {
        "ClientWhitelist": [], //白名单
        "EnableRateLimiting": true,
        "Period": "5m", //1s, 5m, 1h, 1d  jeffzhang
        "PeriodTimespan": 10, //多少秒之后客户端可以重试
        "Limit": 3 //统计时间段内允许的最大请求数量
      },
     //......,
        
    }
  ],
   //......,
    "RateLimitOptions": {
      "QuotaExceededMessage": "Too many requests, maybe later? 11", // 当请求过载被截断时返回的消息
      "HttpStatusCode": 666 // 当请求过载被截断时返回的http status
    }
  }
}
```

> 特别注意：
>
> 为了方便测试，把缓存的配置节点`FileCacheOptions`注释掉。



上面的配置可以解读为：

每5秒内（"Period": "5m"），最多能请求3次（ "Limit": 3），第4次的请求时，返回状态码：666，并有提示信息：“Too many requests, maybe later? 11”，

等待10秒（"PeriodTimespan": 10）后，又可以在5秒内请求3次，依次反复。



一直刷新页面，3次后请求失败，返回自定义的状态码：666

![1612524816784](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612524816784.png)

![1612525179225](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612525179225.png)

等待10秒后，又可以访问3次。



##### 熔断（QoS）

​         保险丝，单位时间错误超过多少就直接停掉，多长时间后再恢复合并请求



为了测试，我们在API项目中定义一个会抛出异常的接口方法：

```C#
    [Route("api/[controller]/[action]")]
    [ApiController]
    public class UsersController : ControllerBase
    {
        [HttpGet]
        public IEnumerable<Users> GetExcetion()
        {
            this._logger.LogWarning($"{DateTime.Now.ToString("HH:mm:ss fff")} {this.GetType()} GetExcetion......");
            throw new Exception();
        }
    }
```



设置配置文件：

```json
      "QoSOptions": {
        "ExceptionsAllowedBeforeBreaking": 3, //允许多少个异常请求
        "DurationOfBreak": 10000, // 熔断的时间，单位为ms
        "TimeoutValue": 10000 //如果下游请求的处理时间超过多少则自动将请求设置为超时 默认90秒
      },
```

> 为了测试不被其它配置干扰，注释掉限流的相关配置节点`RateLimitOptions`



然后访问：http://localhost:6299/Consul/users/GetExcetion

[没效果，待解决]



## 6.7  认证与授权

### 传统用户识别

基于cookie-session
是把用户信息保存在服务器，每次请求带上标识匹配资源

没有分布式架构，无法支持横向扩展。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612595395270.png" alt="1612595395270" style="zoom: 80%;" />

### Token校验

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612595455227.png" alt="1612595455227"  />





### Jwt(Json Web Token)

官网：https://jwt.io/
1 授权：这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，允许用户访问该令牌允许的路由，服务和资源。Single Sign On是一种现在广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。

2 信息交换：JSON Web令牌是在各方之间安全传输信息的好方法。因为JWT可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。



#### jwt结构

```json
Header　头
{  "alg": "HS256",  "typ": "JWT"}

Payload　有效载荷
JWT 默认是不加密的，任何人都可以读到

Signature　签名--防止抵赖-防止篡改
=HMACSHA256( base64UrlEncode(header) + "." +  base64UrlEncode(payload),  secret)
xxxxx.yyyyy.zzzzz
}
```

私钥加密，只有对应的公钥才能解密



### Jwt认证

#### API项目

在【API】项目中引用包：

```xml
 <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="3.1.1" />
```

添加Jwt认证中间件：

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region jwt校验
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,//是否验证Issuer
                    ValidateAudience = true,//是否验证Audience
                    ValidateLifetime = true,//是否验证失效时间
                    ValidateIssuerSigningKey = true,//是否验证SecurityKey
                    ValidAudience = this.Configuration["audience"],//Audience
                    ValidIssuer = this.Configuration["issuer"],//Issuer，这两项和前面签发jwt的设置一致
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(this.Configuration["SecurityKey"])),//拿到SecurityKey
                    //AudienceValidator = (m, n, z) =>
                    //{
                    //    return m != null && m.FirstOrDefault().Equals(this.Configuration["audience"]);
                    //},//自定义校验规则，可以新登录后将之前的无效
                };
            });
            #endregion
     }

   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
            #region jwt
            app.UseAuthentication();//注意添加这一句，启用验证
            #endregion   
   }

```

配置文件`appsettings`,添加如下配置节点：

```json
  "audience": "http://localhost:5726",
  "issuer": "http://localhost:5726",
  "SecurityKey": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDI2a2EJ7m872v0afyoSDJT2o1+SitIeJSWtLJU8/Wz2m7gStexajkeD+Lka6DSTy8gt9UwfgVQo6uKjVLG5Ex7PiGOODVqAEghBuS7JzIYU5RvI543nNDAPfnJsas96mSA7L/mD7RTE2drj6hf3oZjJpMPZUQI/B1Qjb5H3K3PNwIDAQAB"

```

启动API服务

新增一个控制器`UsersNewController.cs`

```C#
    [Route("api/[controller]/[action]")]
    [ApiController]
    [Microsoft.AspNetCore.Authorization.Authorize]
    public class UsersNewController : ControllerBase
    {
        [HttpGet]
        [Microsoft.AspNetCore.Authorization.AllowAnonymous]
        public Users GetUserByID(int id)
        {
           //.....
        }
    }
```

在控制器添加特性`[Authorize]`,但在`GetUserByID`Action添加特性`[AllowAnonymous]`

启动服务：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

http://localhost:5726/api/usersnew/GetUserByID?id=1可以返回数据

http://localhost:5726/api/usersnew/get,返回状态码401，未认证



#### 认证中心项目

新建一个以WebAPI模板的项目【*.AuthenticationCenter】，

配置文件：

````Json
  "audience": "http://localhost:5726",
  "issuer": "http://localhost:5726",
  "SecurityKey": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDI2a2EJ7m872v0afyoSDJT2o1+SitIeJSWtLJU8/Wz2m7gStexajkeD+Lka6DSTy8gt9UwfgVQo6uKjVLG5Ex7PiGOODVqAEghBuS7JzIYU5RvI543nNDAPfnJsas96mSA7L/mD7RTE2drj6hf3oZjJpMPZUQI/B1Qjb5H3K3PNwIDAQAB"

````



`IJWTService.cs`

```C#
    public interface IJWTService
    {
        string GetToken(string UserName);
    }
```



`JWTService.cs`

```C#
    /// <summary>
    /// 备注下：代码演示的是对称加密，所以只有一个key，在返回的信息里面是没有的
    ///         PPT介绍时，说的是非对称的，那样是把解密key公开的，前面是后台用私钥加密的，
    /// 可以保证别人解密后 拿到的数据  跟前面2部分hash后的结果一致 保证没有篡改
    ///  此外，公钥不是在返回结果，那只是个打比方~
    /// </summary>
    public class JWTService : IJWTService
    {
        private readonly IConfiguration _configuration;
        public JWTService(IConfiguration configuration)
        {
            _configuration = configuration;
        }

        public string GetToken(string UserName)
        {
            var claims = new[]
            {
               new Claim(ClaimTypes.Name, UserName),
               new Claim("NickName","Eleven"),
               new Claim("Role","Administrator"),//传递其他信息  
            };
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["SecurityKey"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            /**
             * Claims (Payload)
                Claims 部分包含了一些跟这个 token 有关的重要信息。 JWT 标准规定了一些字段，下面节选一些字段:

                iss: The issuer of the token，token 是给谁的
                sub: The subject of the token，token 主题
                exp: Expiration Time。 token 过期时间，Unix 时间戳格式
                iat: Issued At。 token 创建时间， Unix 时间戳格式
                jti: JWT ID。针对当前 token 的唯一标识
                除了规定的字段外，可以包含其他任何 JSON 兼容的字段。
             * */
            var token = new JwtSecurityToken(
                issuer: _configuration["issuer"],
                audience: _configuration["audience"],
                claims: claims,
                expires: DateTime.Now.AddMinutes(5),//5分钟有效期
                signingCredentials: creds);
            string returnToken = new JwtSecurityTokenHandler().WriteToken(token);
            return returnToken;
        }
    }
```



`Startup.cs`

```C#
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
            services.AddScoped<IJWTService, JWTService>();
        }


        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseHttpsRedirection();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
```



`AuthenticationController.cs`

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class AuthenticationController : ControllerBase
    {
        [Route("Login")]
        [HttpPost]
        public string Login(string name, string password)
        {
            if ("Eleven".Equals(name) && "123456".Equals(password))//应该数据库
            {
                string token = this._iJWTService.GetToken(name);
                return JsonConvert.SerializeObject(new
                {
                    result = true,
                    token
                });
            }
            else
            {
                return JsonConvert.SerializeObject(new
                {
                    result = false,
                    token = ""
                });
            }
        }
    }

```



启动项目:

```C#
dotnet Zhaoxi.AspNetCore31.AuthenticationCenter.dll --urls="http://*:9527" --ip="127.0.0.1" --port=9527
```



登录并获取Token：

POST  http://localhost:9527/api/Authentication/Login?name=Eleven&password=123456 

```json
{"result":true,"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiRWxldmVuIiwiTmlja05hbWUiOiJFbGV2ZW4iLCJSb2xlIjoiQWRtaW5pc3RyYXRvciIsImV4cCI6MTYxMjYwNzYzOCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2IiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2In0.r2La3mYkcJHwEMG1hU-UN7ZcltO6--SQYCgYjciGfr8"}
```

打开[https://jwt.ms/](https://jwt.ms/) 解析Jwt数据结构：

```Json
{
  "alg": "HS256",
  "typ": "JWT"
}.{
  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name": "Eleven",
  "NickName": "Eleven",
  "Role": "Administrator",
  "exp": 1612607638,
  "iss": "http://localhost:5726",
  "aud": "http://localhost:5726"
}.[Signature]
```



https://jwt.io/中使用私钥来验证token是否有效：

私钥：

```json
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDI2a2EJ7m872v0afyoSDJT2o1+SitIeJSWtLJU8/Wz2m7gStexajkeD+Lka6DSTy8gt9UwfgVQo6uKjVLG5Ex7PiGOODVqAEghBuS7JzIYU5RvI543nNDAPfnJsas96mSA7L/mD7RTE2drj6hf3oZjJpMPZUQI/B1Qjb5H3K3PNwIDAQAB
```

![1612608273926](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612608273926.png)





使用返回的token，添加到访问API的地址的请求头中，

GET  http://localhost:5726/api/usersnew/get 

 Authorization :

```md
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiRWxldmVuIiwiTmlja05hbWUiOiJFbGV2ZW4iLCJSb2xlIjoiQWRtaW5pc3RyYXRvciIsImV4cCI6MTYxMjYwNzYzOCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2IiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1NzI2In0.r2La3mYkcJHwEMG1hU-UN7ZcltO6--SQYCgYjciGfr8
```



![1612607558374](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612607558374.png)



## 6.8 分布式

【Course-14】

### CAP

CAP定理---分布式的入门理论

Consistency              一致性
Availability                 可用性
Partition tolerance     分区容错

分布式系统下，网络出错是必然存在的---也就是不可靠的
在分区容错一定出现的情况，C和A是不能同时满足的

**CAP是不能同时满足的！**



### 分布式事务-BASE

**Base理论：**

- Basically Available(基本可用)

- 最终一致性

- Soft state（软状态）

- Eventually consistent

  **微服务架构里面，可用性是最重要的**，因为为了保证一致性，会造成多个微服务节点阻塞，影响性能

  

  思想是最重要，指引方向



### 主要的分布式事务模式

#### 2PC

![1612616121041](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612616121041.png)



#### TCC（Try-Confirm-Cancel）

基于**Base理论** 实现的

![1612617058067](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612617058067.png)



#### 本地消息表

MQ分布式事务--本地消息表--基于消息的一致性

上游投递消息
下游获取消息
上游投递稳定性
下游接受稳定性

![1612735624126](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612735624126.png)

### 分布式跟踪

业务延迟很大，怎么定位问题？

- Butterfly
- **Skywalking**

分布式追踪和APM （应用性能管理） 的Server端，它将包含Collector，Storage，独立的Web UI，并使用Open Tracing规范来设计追踪数据

 SkyWalking 的核心是数据分析和度量结果的存储平台，通过 HTTP 或 gRPC 方式向 SkyWalking Collecter 提交分析和度量数据，SkyWalking Collecter 对数据进行分析和聚合，存储到 Elasticsearch、H2、MySQL、TiDB 等其一即可，最后我们可以通过 SkyWalking UI 的可视化界面对最终的结果进行查看 。



### 分布式日志

Exceptionless：开源的日志收集和分析框架，能为应用程序提供实时错误、特性和日志报告。



### 配置中心

**Apollo**-配置中心

微服务架构环境中，项目中配置文件比较繁杂，而且不同环境的不同配置修改相对频繁，每次发布都需要对应修改配置，如果配置出现错误，需要重新打包发布，时间成本较高，

因此需要做统一的配置中心，能做到自动更新配置文件信息



### Docker

容器部署运维



### Kubernetes

容器编排



## 6.9 架构漫谈

【Course-15-16】



### 大数据高并发（Level 1）

如何应对大数据高并发？
读写分离
负载均衡/集群
消息队列
Redis
分布式
缓存
分库分表

开放性话题，演绎下系统架构的变迁，把其中的核心环节详解下！



#### 单机系统

![1612780355050](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780355050.png)

PV/UV/IP
单机承载能力—硬件资源不够
压力测试—loadrunner

随着时间的推移，用户增多，数据增多，并发量增多了，然后服务器扛不住了，怎么办？

1 垂直扩展：升级硬件
    立竿见影，但是有上限
2 水平扩展：多来几台服务器
    一个人力气不够，多来几个人



#### 独立服务器

![1612780398289](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780398289.png)

第一次分布式：这就是分布式
分布式就是一台服务器做的事儿分成多台服务器协作完成

很轻松的提升承载能力，但是当前的划分粒度是很粗放的

分布式的第一要务就是不要使用分布式



#### 缓存

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780441581.png" alt="1612780441581" style="zoom: 80%;" />



系统性能优化的第一步就是使用缓存，成本低见效快(有弊端)

二八原则：
80%财富集中在20%人手里
80%的活儿是20%的人干了
80%的访问都集中在20%数据上
(性能优化就应该盯着大多数)

随着时间的推移，用户增多，数据增多，并发量增多了，然后服务器扛不住了，怎么办？



缓存一般解决数据库的压力，

弊端是数据延迟



缓存，立竿见影，因为直接重用结果，
降低数据库压力，提升性能
改造也特别简单，成本也低

也要注意缓存的缺点，是可能有数据延迟(过期时间)
再给出解决方案，以场景为例，证明真的用过

----应对大数据高并发，这个是第一阶段答案



#### 集群负载均衡

![1612780589469](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1612780589469.png)

集群：一台服务器做的事儿，现在由多台服务器共同承载，每台服务器都是独立完成的
---同一个服务有多个实例

分布式：一台服务器做的事儿分成多台服务器协作完成，每台服务器完成其中的一个部分
---微服务里面多个服务串成一个业务逻辑

其实集群也算分布式



在服务压力大，水平扩展，增强承载能力
每台服务器都能完成响应---内容是一样的(部署一台，其他FTP同步的)

**DNS负载均衡-**

可以在DNS配置多个站点响应的，由DNS决定谁来响应
负载均衡：多个选项中，按照一定的策略去选择
就近策略---轮询策略---权重策略



**服务器自己搞定负载均衡**

- 硬件派—软硬结合(服务器内置软件)—F5(解决方案)
- 软件派：
  LVS---基于四层协议---ip+port 但是不知道内容---策略有限性能高---难度大
  HAProxy---基于7层协议---Http内容—策略很丰富—配置比较难(国内少)



**Nginx**

七层协议---url-hash    ip-hash 
用户持久化问题，登录服务器1 保存session，访问服务器2不认识！
共享session：StateServer/SqlServer/Redis
会话粘滞---ip-hash—高可用有问题，分配不均匀

请求携带：

​    cookie（局限性是：客户端必须是浏览器）
​    token：每次请求携带的字符串---无状态

JWT有两种加密方式

- 对称加密(代码演示)---鉴权中心&API都有一个相同的key---加密算法.有效内容.加密前两块儿内容做签名—证明来源+没有篡改

- 非对称加密---鉴权中心是私钥做加密---加密算法.有效内容.加密前两块儿内容做签名—第三方应用首先拿公钥—解密密文+比较---证明来源+没有篡改



### 大数据高并发（Level2）

搭建过环境---知道几种策略---持久化的解决方案

#### 读写分离

![1613110690902](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613110690902.png)

数据库瓶颈：数据库读写分离
木桶理论：决定一个木桶装水能力是由最短的那块儿板
二八原则：80%的业务都是查询，20%是增删改

##### 1主库, N从库

写主库，读从库，从库订阅主库的变化，包括： 数据结构—数据都是一模一样的

**主库只能有一个**

配置经历---当下用的是发布-订阅—写作业和抄作业的区别
使用场景—代码支持—负载均衡---



**延迟，解决不了---只能扬长避短去用—(借助nosql帮忙)**

比如秒杀，先初始化数据到NoSql--增删改查都是先NoSql再到SqlServer



#### 分库分表表分区

​        从设计角度分担压力(让数据库可以水平扩展)

**垂直分库**

按业务分库—不同的服务器—降低—合理划分/通过服务交互/再来个合并库/技术手段

> 做报表肯能需要合并库



**水平分库**

每个库是一样的—数据不同---降低—合理划分/通过服务交互/再来个合并库/技术手段



#### 方向代理&CDN

![1613112683793](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613112683793.png)

继续缓存
CDN加速/缓存：阿里云
南网宿北
CDN其实是DNS提供的
DNS是互联网的第一心跳，CDN就是把数据存在离用户最近的地方
主要解决图片 视频，缓存
加快速度—减少服务器请求
反向代理：屏蔽和保护，也可以缓存一下
本地缓存+CDN+反向代理=--明天上午10点，一起来探讨缓存



#### 分布式文件系统

![1613112779758](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613112779758.png)

分布式文件服务器
图片多  视频多的
TFS  GFS  NFS
就是把多个硬盘管理成本地硬盘
可以直接读写--



#### 专项突破

![1613113404837](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613113404837.png)



专人做专事：这样才能高效！

一些特殊的业务：

比如全文检索、

秒杀：NoSql解决-队列



我就特别抗拒，让我做乱七八糟的事儿

一个系统的崩溃就是源于一个点，所以用专业的技术来解决独特的问题



#### 分布式异步队列

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E6%AD%A5%E9%98%9F%E5%88%97.png" style="zoom:50%;" />

队列是可以无处不在的，效果非常厉害，
但是成本有点高。
1 队列提升响应能力，削峰
2 高可用—服务持续响应
可扩展---业务和UI分离

不能实时反馈结果---业务妥协
还有可能失败---可以重试，人工介入—返回失败

队列还有个重要应用是分布式事务



#### 业务拆分

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/%E4%B8%9A%E5%8A%A1%E6%8B%86%E5%88%86.png)

继续拆分，垂直业务拆分
门户网站—Ask---BBS—Blog—NEW---DB组各种知识库
独立团队 独立维护 独立部署
很有效的提升承载能力

数据共享方式：
数据库---接口---队列—缓存Nosql







### 大数据高并发（Level 3）

怎么设计-怎么管理-分布式事务分布式锁
微服务实践



#### 分布式&微服务

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1.png)

又双叒叕拆，拆成独立服务+数据库，一方面可以增强承载能力，另外也复用

分布式，是有巨大成本的
分布式事务---CAP
分布式的第一要务就是不要分布式



### 总结

再问一次，如何应大数据高并发？
这是个开放问题，是个送分题，
考察技术视野—考察经验—考察思维方式
首先得分析问题所在，然后提一下常规的解决方案，然后着重强调自己的经历

你擅长什么，就移植个什么，
然后使劲儿说，技术+业务



### 大型系统

见【大型系统架构解析.xmind】



## 7 数据结构和算法



## 8 Vue

### Visual Code 插件

- Vue2 Snippets
- Vue Preview
- Vue VsCode Snippets
- Vue-beautify
- Vue-fomat



### 生命周期

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="lib/vue.min.js"></script>
</head>
<body>
    <div id="app">
        {{msg}}
    </div>
    <script>
        //MVVM => M:Model、V:View、VM:ViewModel
        var vm = new Vue({
            el:"#app",
            data:{
                msg:"Hello world"
            },
            //在Vue实例创建前触发——类似于cpu还在图纸上
            beforeCreate() {
                console.log(this.msg);
            },
            //Vue实例被创建，这是最早可以操作data、methods中数据的时候——类似于cpu已被制造
            created() {
                console.log(this.msg);
            },
            //实例挂在前触发——类似于CPU以安装到电脑上，但是电脑未开机
            beforeMount() {
                
            },
            //已被挂载，此时我们的data中的数据可以渲染到页面——类似于电脑一开机，cpu开始工作
            mounted() {

            },
            //在数据被更新时，但是虽然data中的数据被更新了，但是页面中的数据并没有被更新
            beforeUpdate() {
                console.log("beforeUpdate");
            },
            //此时data中的数据以及页面中的数据都被更新了
            updated() {
                console.log("update");
            },
            //在实例被注销时触发
            beforeDestroy() {
                console.log("beforeDestroy");
            },
            //实例已被注销时触发
            destroyed() {
                console.log("destroyed");
            },
        })
    </script>
</body>
</html>
```



### 命令

#### v-cloak

插值表达式在vue实例没有对页面进行渲染时会出现非常恶心的大括号

`v-cloak`可以在页面未渲染前不显示插值表达式的内容，比如下面的例子，在页面未被渲染时不会显示

```html
  {{msg}
```

这个插值表达式的及其内容，

```html
<body>
    <div id="app" v-cloak>
        {{msg}
    </div>
    <script>
    
            var vm = new Vue({
            el: "#app",
            data: {
                msg: "张三"
            }
        })
    </script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</body>
```



#### {{}}插值表达式和v-text

    - 区别1：插值表达式在vue实例没有对页面进行渲染时会出现非常恶心的大括号，而插值表达式不会出现这种情况。
    - 区别2：二者皆可对页面进行数据的渲染，但是差值表达式不会覆盖标签原有的内容，而v-text会替换掉被渲染标签中的内容



#### 示例一

VueCmd.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="lib/vue.min.js"></script>
</head>

<body>
    <div id="app" >
        <p>姓名：{{msg}}</p>
        <p v-text="msg2">姓名</p>
        <p v-html="msg2"></p>
        <input :type="type">
        <button @click="clickMe()">点击我</button>
    </div>
    <script>
            var vm = new Vue({
            el: "#app",
            data: {
                msg: "张三",
                msg2:"<b>李四</b>",
                type:"checkbox"
            },
            methods: {
                clickMe:function(){
                    alert();
                }
            },
        })
    </script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</body>

</html>
```

##### 

##### `{{msg}}`插值表达式

##### v-text="msg2"`

文本绑定



##### `v-html="msg2"`

会解析成html，而不是显示文本`<b>李四</b>`



##### `:type="type"`

类型绑定，界面会显示成 `checkbox `html元素



##### `@click="clickMe()"`

事件绑定，事件方法定义在`     methods:{}`对象中



#### 示例二

CheckAll.html

```html
<body>
    <div id="app">
        <input type="checkbox" @change="checkedAll" v-model="checkAll">全选
        <p v-for="user in users">
            <input type="checkbox" v-model="user.isChecked" @change="check">{{user.userName}}——{{user.isChecked}}
        </p>
    </div>
    <script>
        var vm = new Vue({
            el: "#app",
            data: {
                users: [
                    { userName: "张三", id: 1, isChecked: false },
                    { userName: "李四", id: 2, isChecked: false },
                    { userName: "王五", id: 3, isChecked: false },
                ],
                checkAll: false
            },
            methods: {
                checkedAll() {
                    this.users.forEach(element => {
                        element.isChecked = this.checkAll;
                    });
                },
                check() {
                    // if (this.users.length == this.users.filter(m => m.isChecked).length)
                    //     this.checkAll = true;
                    // else
                    //     this.checkAll = false;
                    this.checkAll = this.users.every(m => m.isChecked)
                }
            },
        })
    </script>
</body>
```



##### `v-model`

实现双向绑定，且绑定的表单html元素的`value`属性



##### `v-for`

###### :key

```html
       <p v-for="(user,index)  in users" :key="user.id">
            <input type="checkbox">{{user.userName}}——{{user.isChecked}}
       </p>
```

`:key`默认取变量`index`，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613316758290.png" alt="1613316758290" style="zoom:50%;" />

勾选`index=0`的张三，点击【AddUser】,新增一个`User`：赵六，此时勾选的是新增的赵六，而不是原来的

张三，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613317074388.png" alt="1613317074388" style="zoom:50%;" />

所以，如果有动态变化（新增或删除）的`User`，最好使用`v-for`的`:key`做好不要使用默认的`index`,而是指定`User`的唯一标识,比如`User.id`,如下代码所示：

```html
        <p v-for="(user,index)  in users" :key="user.id">
            <input type="checkbox">{{user.userName}}——{{user.isChecked}}
        </p>
```



###### 单个变量

```html
    <p v-for="(val,key,i) in user">{{val}}——{{key}}——{{i}}</p>

   user:{ userName: "张三", id: 1, isChecked: false },
```

输出：

```html
张——userName——0
```



#### if&show

```html
<body>
    <div id="app">
        <div v-if="isShow">hahaha</div>
        <div v-else>huhuhu</div>
        <div v-show="isShow">heihei</div>
    </div>
    <script>
         var vm = new Vue({
            el:"#app",
            data:{
                isShow:false
            },
        })
    </script>
</body>
```



### 样式绑定

#### :class

- 单样式绑定

```html
<p :class="'testP1'">我是P标签</p>

        .testP1{
            color:brown;
        }
        .testP2{
            color:blue;
        }
```

`'testP1'`要添加单引号，不加单引号的话会到`Vue.data`对象，显然是不对的。



- 多样式绑定

```html
<p :class="['testP1', 'testP2']">我是P标签</p>
```



- 三元表达式

  ```html
  <p :class="[isShowRed?'testP1':'testP2']">我是P标签</p>
  ```

  三元表达式放在中括号中。

  

#### :style

```html
  <p :style="[style1,style2]">我是P标签</p>
 
         var vm = new Vue({
            el: "#app",
            data:{
                style1:{color:"#fff","font-size":"18px"},
                style2:{"background-color": "brown"}
            }
        })

```

#### 

### 计算属性

​           计算属性会把结果放到缓存中

定义计算属性:

```html
<body>
    <div id="app">
        <p>{{myNum}}</p>
        <button @click="add()">+</button>
    </div>
    <script>
        var vm = new Vue({
            el: "#app",
            data: {
                num: 10
            },
            methods: {
                add: function () {
                    this.num = this.myNum + 1;
                }
            },
            computed: {
                myNum() {
                    return this.num;
                }
            }
        })
    </script>
</body>
```



### 自定义命令

```html
<body>
    <div id="app">
        <p v-ace>{{num}}</p>
    </div>
    <script>
        Vue.directive("ace",{
            bind(el,binding){
               var price = parseInt(el.innerText).toFixed(2);
               el.innerText = price;
            }
        })

        var vm = new Vue({
            el:"#app",
            data:{
                num:10
            }
        })
    </script>
</body>
```

`Vue.directive`定义自定义命令，可以获取到`Dom`对象`el`, 而`binding`包含指令的信息



### 组件

#### 全局组件

```html
<body>
    <div id="app">
        <my-header></my-header>
    </div>
    <script>
        Vue.component("my-header",{
            template:'<h1>{{msg}}</h1>',
            data(){
                return {
                    msg:"hello vue"
                }
            }
        })
        var vm = new Vue({
            el: "#app"
        })
    </script>
</body>
```



#### 局部组件

```html
<body>
    <div id="app">
        <hello></hello>
        <word></word>
    </div>
    <script>
        var vm = new Vue({
            el: "#app",
            components: {
                "hello": {
                    template: '<h2>{{msg}}</h2>',
                    data() {
                        return {
                            msg: "局部组件1"
                        }
                    }

                },
                "word": {
                    template: '<h2>{{msg}}</h2>',
                    data() {
                        return {
                            msg: "局部组件2"
                        }
                    }

                }

            }
            
        })
    </script>
</body>
```

#### 

#### 模板（template）

```html
<body>
    <div id="app">
        <word></word>
    </div>

    <template id="temp">
        <div>
            this is {{msg}}
        </div>
    </template>

    <script>

        var vm = new Vue({
            el: "#app",
            components: {
                "word": {
                    //template: '<h2>{{msg}}</h2>',
                    template:"#temp",
                    data() {
                        return {
                            msg: "局部组件2"
                        }
                    }

                }

            }
            
        })
    </script>
</body>
```



#### 组件传参

```html
<body>
    <div id="app">
        <word :param1="componentParam" param2="组件参数2"></word>
    </div>

    <template id="temp">
        <div>
            this is {{msg}} : {{param1}} , {{param2}}
        </div>
    </template>

    <script>
        Vue.component("my-header",{
            template:'<h1>{{msg}}</h1>',
            data(){
                return {
                    msg:"全局组件"
                }
            }
        })
        var vm = new Vue({
            el: "#app",
            data:{
                "componentParam":"组件参数 From vm 对象"
            },
            components: {
                "word": {
                    template:"#temp",

                    data() {
                        return {
                            msg: "局部组件2"
                        }
                    },
                    props:['param1', 'param2']
                }
            }
            
        })
    </script>
</body>
```

定义组件属性：

```json
props:['param1', 'param2']
```

传参：

```html
 <word :param1="componentParam" param2="组件参数2"></word>
```

其中，

```html
:param1="componentParam"
```

参数名前有`:`,说明参数`param1`是通过数据绑定指定值，即： 指明`param1`绑定`vm.data.componentParam`的值



#### 组件嵌套

```html
<body>
    <div id="app">
        <parent-compt></parent-compt>
    </div>

    <template id="parent-child">
        <div>
            this is {{msg}} 
            <child></child>
        </div>
    </template>

    <script>
        var vm = new Vue({
            el: "#app",
            data: {
              
            },
            components: {
                "parent-compt": {
                    template: "#parent-child",
                    data() {
                        return {
                            msg: "父组件"
                        }
                    },
                    components: {
                        //组件嵌套
                        'child': {
                            template: '<p>{{childMsg}}</p>',
                            data() {
                                return {
                                    childMsg: "组件嵌套:子组件"
                                }
                            }
                        }
                    }
                }

            }

        })
    </script>
</body>
```



#### 组件间传值



### 路由

要使用路由，得引用如下js：

```js
<script src="lib/vue-router.js"></script>
```

简单示例

```html
<body>
    <div id="app">
        <router-link to='/main'>main</router-link>
        <router-link to='/userList'>userList</router-link>
        <router-view></router-view>
    </div>

    <script>
        var main = {
            template: '<b>这是主页</b>'
        };

        var userList = {
            template: '<b>这是用户列表</b>'
        };

        var routes = [
            { path: "/",redirect:main },
            { path: "/main", component: main, name:"main" },
            { path: "/userList", component: userList, name:"userlist"}
        ];

        const router = new VueRouter({
            routes: routes
        })

        var vm = new Vue({
            el: "#app",
            router:router
        })
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    </style>
</body>
```



## 9. AspNet.Core API

[Course:31\32]

### Filter

（与5.5 相同）

### JWT

（与5.6 相同）



### 集群&负载均衡

**分布式**：一个流程线，由多个系统配合完成；
**集群**：多个服务器，每个服务器完成一整套动作

![1613488749872](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613488749872.png)



#### Nginx实操

##### WebApi

在WebApi项目中定义`NgnixController`

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class NginxController : ControllerBase
    {
        private readonly ILogger<FirstController> _logger;

        public NginxController(ILogger<FirstController> logger)
        {
            _logger = logger;
            _logger.LogInformation($"{nameof(FirstController)} 控制器被实例化~~");
        }

        private static int iCount = 0;
        private static string id = Guid.NewGuid().ToString("D");

        [HttpGet]
        [Route("GetString")]
        public string GetString()
        {
            var host = Request.Host.ToString();
            return Newtonsoft.Json.JsonConvert.SerializeObject(new
            {
                应用程序监听端口号 = $"this is {host}, Guid={id}",
                访问次数 = ++iCount
            });
        }

    }
```

然后启动三个服务器实例：

```powershell
dotnet AspNetCore.WebApi.dll --urls="http://*:10001" --ip="127.0.0.1" --port= 10001
dotnet AspNetCore.WebApi.dll --urls="http://*:10002" --ip="127.0.0.1" --port= 10002
dotnet AspNetCore.WebApi.dll --urls="http://*:10003" --ip="127.0.0.1" --port= 10003
```



访问http://localhost:10001/api/Nginx/GetString

输出：

```html
{"应用程序监听端口号":"this is localhost:10001, Guid=f5993ded-7780-4928-9331-6b2f8198d194","访问次数":1}
```



##### 下载安装配置

http://nginx.org/en/download.html

下载后，解压压缩包，比如：`F:\tmp\ngnix\nginx-1.17.8`

***特别注意，解压的路径不要放在有中文的路径中***

- 修改Nginx端口：

  打开文件`conf/nginx.conf`,将端口变成 8989：

  ```xml
      server {
          listen       8989;
          server_name  localhost;
  ```

  如果配置文件有修改，可以使用如下命名重启：

  ```powershell
  nginx -s reload
  ```

  

- 启动Ngin

  在解压的目录中，打开cmd，输入如下命名，启动Nginx.

  ```powershell
  F:\tmp\ngnix\nginx-1.17.8>start nginx.exe
  ```

  访问：http://localhost:8989/

  ![1613491094782](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613491094782.png)

  看到这个页面，表示Nginx启动成功

  

  > 将nginx安装为windows服务
  >
  > https://www.cnblogs.com/ihappycat/p/11823342.html



- 配置Nginx转发：

Location: name
Upstream: Name
Server:port

打开文件`conf/nginx.conf`,

```md
    // ......
    server {
        listen       8989;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }
```

修改为：

```md
#默认是轮询
   upstream AspNetCoreWebApi
   {
	server  localhost:10001 weight=2;
	server  localhost:10002 weight=4;
	server  localhost:10003 weight=4;
   }
 #weight=设置权重策略  但是这里是从比例上来 约等于

    server {
        listen       8989;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
	        proxy_pass  http://AspNetCoreWebApi;
            #root   html;
            #index  index.html index.htm;
        }

```

重启Nginx:

```powershell
nginx -s reload
```

访问http://localhost:8989/api/Nginx/GetString

```powershell
{"应用程序监听端口号":"this is AspNetCoreWebApi, Guid=ed31b1be-5664-46b6-9e5c-ab7f2e407a06","访问次数":2}
```

提醒：

​        注意到，通过Nginx转发后，

```C#
var host = Request.Host.ToString();
```

只不再类似为：

```powershell
localhost:10001
```

而是配置 文件中

```md
 location / {
	   proxy_pass  http://AspNetCoreWebApi;
```

中的字符串`AspNetCoreWebApi`



### 跨域

我们有时候在使用Ajax请求WebApi的时候，会爆出上面这个错误；
Access to XMLHttpRequest at 'http://localhost:64304/api/CrossDomain/GetCrossDomainData' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

产生跨域问题的根源是浏览器的同源策略，是浏览器的行为



#### (浏览器)同源策略

![1613495244563](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613495244563.png)

同源策略（Sameoriginpolicy）是一种约定，它是**浏览器**最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。
部分Html标签可以 Script Iframe img



#### 如何解决跨域问题

1   JSONP 通过浏览器标签去请求Api；避开跨域问题；
	是通过浏览器的一些指定标签<Img src>  <Script src> <frame >
	去跨域请求，获取到数据以后，可以通过一个回调函数来把数据进行	解析，然后使用数据；	
2   通过后台模拟Http请求请求Api Api提供方是一个进程；我通过后台
3   在服务器端指定允许你跨域；
	AspNetCore 内置的有这个支持跨域的程序包；
    组件支持：Microsoft.AspNetCore.Cors



#### AspNetCore解决跨域

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region 支持跨域  所有的Api都支持跨域
                
            services.AddCors(option => option.AddPolicy("AllowCors", 
             _build => _build.AllowAnyOrigin().AllowAnyMethod()));
         
            #endregion
     }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
          app.UseCors("AllowCors");
    }
  
```



## 10 IdentityServer4

参考资料：

- 生成环境秘钥：

  https://www.cnblogs.com/edisonchou/p/identityserver4_foundation_and_quickstart_01.html



### 为什么需要授权

送外卖的故事：
美团-饿了么-蜂鸟-跑腿小递
很多快递要进小区(假设能进来)
小区有密码锁—能给密码吗--不行

- 假设每次进来都打电话---确认了---放行---每次都要找我

- 假设弄个临时密码(有效期短点)---假如不再点饿了么—取消密码—大家都失效

- 一人一个临时密码—临时密码找我拿的—声明自己的身份—我确认了—给你个东西(临时密码/Token)---然后你就能进来---下次你还能进来

  这里的token(带点信息)使用过程 就是授权机制



### 什么是OAuth2.0

授权机制，是一种规范/协议，制定了授权流程
解决授权问题
大家都遵守，才好沟通

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/oauth2.0-auth.png)

OAuth 就是一种授权机制。
数据所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。
系统从而产生一个短期的进入令牌（token），用来代替密码，
供第三方应用使用。

规范了下授权的流程



### Token  VS  密码

都能进入系统，丢失后都是有风险的
Token短期的，密码是长期
令牌可以取消，密码只能修改(影响全部)
Token可以控制权限，scope

OAuth，就是Token比密码安全



### OAuth2.0 四种授权

- 客户端凭证（client credentials）

- 密码式（password）

- 隐藏式（implicit）

- 授权码（authorization-code）

  

  混合式（Hybrid）

  

### IdentityServer4

[Course-40]

ASP.NET CORE量身定制
实现了OpenID Connect和OAuth2.0协议
认证授权中间件



#### QuickStart UI

https://github.com/IdentityServer/IdentityServer4.Quickstart.UI

在自己新建的`*.IdentityServer4`的认证授权项目中，引用`IdentityServer4`包后，运行如下命名

```powershell
dotnet new -i identityserver4.templates
dotnet new is4ui
```

项目会自动生成UI的一些代码：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613527284924.png" alt="1613527284924" style="zoom:80%;" />

然后启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```


http://localhost:7200/.well-known/openid-configuration



#### client_credentials(客户端模式)

最简单
Id+Secret
**这种授权方式：一般用于用来给客户端授权，没有用户（参与）**

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613531170007.png" style="zoom: 80%;" />，

##### IdenityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
       
       #region 客户端
           
           services.AddIdentityServer()//怎么处理
              .AddDeveloperSigningCredential()//默认的开发者证书--临时证书--生产环境为了保证token不失效，证书是不变的
              .AddInMemoryClients(ClientInitConfig.GetClients())//InMemory 内存模式
              .AddInMemoryApiResources(ClientInitConfig.GetApiResources());//能访问啥资源
            
       #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
         #region 添加IdentityServer中间件
            app.UseIdentityServer();//拦截部分请求
         #endregion
   }
```

`ClientInitConfig.cs`

```C#
/// <summary>
    /// 客户端模式
    /// </summary>
    public class ClientInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                new ApiResource("UserApi", "用户获取API")
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },//客户端密码，进行了加密
                    AllowedGrantTypes = GrantTypes.ClientCredentials,
                    //授权方式，客户端认证，只要ClientId+ClientSecrets
                    AllowedScopes = new [] { "UserApi" },//允许访问的资源
                    Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }
    }
```

启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Client
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";//ids4的地址
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });

            // 自己加些策略
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "client_eMail")
                    && context.User.Claims.First(c => c.Type.Equals("client_eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

定义给第三方调用的API

`Ids4Controller`

```c#
public class Ids4Controller : Controller
    {
        [Authorize]
        public IActionResult Index()
        {
            Console.WriteLine("************************************************");
            //string id_token = base.HttpContext.Request.Cookies["id_token"];
            //var token_parts = id_token.Split('.');
            //var header = Encoding.UTF8.GetString(Base64Url.Decode(token_parts[0]));
            //var claims = Encoding.UTF8.GetString(Base64Url.Decode(token_parts[1]));
            //var sign = Encoding.UTF8.GetString(Base64Url.Decode(token_parts[2]));
            //Console.WriteLine(header);
            //Console.WriteLine(claims);
            //Console.WriteLine(sign);

            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
            Console.WriteLine("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");
            return View();
        }


        [Authorize(Roles = "Admin")]
        public IActionResult IndexRole()
        {
            return View();
        }


        [Authorize(Policy = "eMailPolicy")]
        public IActionResult IndexPolicy()
        {
            return View();
        }

        [Authorize(Policy = "DoubleEmail")]
        public IActionResult IndexPolicyDouble()
        {
            return View();
        }

        [AllowAnonymous]
        public IActionResult IndexToken()
        {
            return View();
        }

        [AllowAnonymous]
        public IActionResult IndexCodeToken()
        {
            //从url读取code---post请求一下Tencent---token
            return View();
        }

    }
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

获取token的地址： http://localhost:7200/connect/token 

- 获取token

  Post:  http://localhost:7200/connect/token 

  form-data:

  ```json
  grant_type:client_credentials
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  ```

![1613533970909](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613533970909.png)

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1MzM4OTcsImV4cCI6MTYxMzUzNzQ5NywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJjbGllbnRfcm9sZSI6IkFkbWluIiwiY2xpZW50X25pY2tuYW1lIjoiRWxldmVuIiwiY2xpZW50X2VNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdfQ.RCmWr_mM_L8FxsB2kPfdTwwkguaH4S4a1HfoGGuMdUyT6w4zN20gRUgSTNRMRlljTZLK5x2ONuVBxXtAR2HT50kzOo1j5m0enV5YvjGOZVeW70L7WHOP7iMGMvvG1QyW7--TfZKW9U1wZBL_ElZ3ZAzjw3_ttyPnN4lNDewpXBdw6VBjGih4zhCdvtQSZtff2zG2dlSCEstrXdUCawMETlaBloqvg397RDKGyN0hYiyC8qnzpuYSjgg9m-yXJdXTQOZmW9iR0hWlRl31YI61_-0W08bX0gqzC4MiiTHVbF8duYBgPcOJLhoymvIy_VgOTy_GTB99KUW-fjfBt12Hiw
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613533897,
  "exp": 1613537497,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "client_role": "Admin",
  "client_nickname": "Eleven",
  "client_eMail": "57265177@qq.com",
  "scope": [
    "UserApi"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

![1613535970695](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613535970695.png)



#### Password(密码模式) 

携带密码校验，最习惯

密码是从哪里来的，客户端输入给第三方

**安全性：不安全，因为客户端输入账号和密码给第三方，需要充分信任第三方应用**。



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {

            #region 密码模式
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryApiResources(PasswordInitConfig.GetApiResources())//API访问授权资源
               .AddInMemoryClients(PasswordInitConfig.GetClients())  //客户端
               .AddTestUsers(PasswordInitConfig.GetUsers());//添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

`PasswordInitConfig.cs`

```C#
/// <summary>
    /// 密码模式
    /// </summary>
    public class PasswordInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")

                new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),

                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.ResourceOwnerPassword,//密码模式
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    //cliam无效
                }
            };
        }
    }
```



看到代码：

```C#
 .AddTestUsers(PasswordInitConfig.GetUsers());//添加用户
```

显然，这种方式需要用户的参与



启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Password
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "TestApi";
                    options.RequireHttpsMetadata = false;
                });
       
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

获取token的地址： http://localhost:7200/connect/token 

- 获取token

  Post:  http://localhost:7200/connect/token 

  form-data:

  ```json
  grant_type:password
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  scope:TestApi
  username:Eleven
  password:123456
  ```

相较与【客户端模式】，多了两个参数：

```json
username:Eleven
password:123456
```

这是用户的账号和密码。

请求token，如下所示

![1613537528701](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613537528701.png)

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1MzczMTQsImV4cCI6MTYxMzU0MDkxNCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTM3MzE0LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.Q4rioq48LR5lcs9t50jzHuBSJMHEOTnrxz11xowqLC_9hQEULY5Mrd77Lk7K65BOfiXT_PwmWSipEN6BWYBrJjfwApVtsnCh5tCbAshSYhYpLwFMk1N_s30mQhCVy-8YjN-iguoqT8VlSv8frPETTwExe-72zGp_zdUbzYASz-DI-Y1ARZwZv9zCMBy0Sn6jz5EoEU3HFEo6QNK1TOcJ0lK5dgjlout4sRDJhRu9LZ8CG5Hj-aXNRKEbxDn41FAfVMBVESY4GqCnKB0FykxeRSZfwJ7b1UZYnuWsjyjnh4uRQSxsiCREqW5a-GSugvXYvWrZPYGr1xIxlfEQLSS6bA
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613537314,
  "exp": 1613540914,
  "iss": "http://localhost:7200",
  "aud": "TestApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613537314,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

![1613535970695](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613535970695.png)



#### Implicit(隐藏模式) 

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613540163968.png" alt="1613540163968" style="zoom:80%;" />

浏览器模式—允许授权给浏览器

用户访问A—没有token—A提供地址跳转B登录
--输入账号密码—授权---调回A的地址(url带token)
--访问A时带上token

**保护了密码（没有向第三方应用(A.com)提供账号和密码），只是暴露了token**



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region 隐藏模式
            services.AddIdentityServer()
               .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryApiResources(ImplicitInitConfig.GetApiResources()) //API访问授权资源
               .AddInMemoryClients(ImplicitInitConfig.GetClients())//客户端
               .AddTestUsers(ImplicitInitConfig.GetUsers()); //添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

`ImplicitInitConfig.cs`

```C#
   /// <summary>
    /// 隐藏模式：用户---朝夕---腾讯授权中心
    /// http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexToken&response_type=token&scope=UserApi
    /// 用户访问朝夕---需要token---跳转到授权中心---朝夕提供地址---然后用户向腾讯授权中心输入账号密码
    /// 
    /// http://localhost:5726/Ids4/IndexToken#access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE1OTAxNTUwMjUsImV4cCI6MTU5MDE1ODYyNSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNTkwMTU0OTQ3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.WdeNz6A2AxPCU8iO7X6D5ewQD2rVn72CZz7Z_bKUuQU5rdMn3IfIUsKioTzOf5UCrf4oNicu2smYR2VGt7eCFB1_OYAgFWxMDPVu0iVDuTOj8Uhuxwdy9fdPfHCcAa9gAAn2fZg7-IOfY-V4mx3VnhDwoPA_Jzti9E9x-UMcNBzuCs15qRm4CfSiirMe5HaWflrBrBiE4t5QjWR9tJk_ntP5hzjOQCShD8XWj-t1a2oCZzNFIvWP6DF4foppDXwF85FFGDTg-ZE4-dHC3iHY6523KskD9hk4SjHzkn8EVQudnMM5sVQYyp3K9PWAUZ9OQl2n7mDzN8vG5dlbYlCF3w&token_type=Bearer&expires_in=3600&scope=UserApi
    /// 
    /// 到这里获取到token
    /// </summary>
    public class ImplicitInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")
                    new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),//增加cliam
                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }


        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Implicit",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Implicit,//隐藏模式
                    RedirectUris={"http://localhost:5726/Ids4/IndexToken" },//可以多个，根据请求来的转发
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

代码解析：

```C#
RedirectUris={"http://localhost:5726/Ids4/IndexToken" },//可以多个，根据请求来的转发
```

授权后回调的第三方应用的链接，回调时会携带access_token,



启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Implicit
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

认证回到页面：

```C#
    public class Ids4Controller : Controller
    {

        [AllowAnonymous]
        public IActionResult IndexToken()
        {
            return View();
        }
    }
}
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```





##### 第三方应用

###### 用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

认证地址： http://localhost:7200/connect/authorize 

认证回调地址，我们注册为：http://localhost:5726/Ids4/IndexToken,参见如下代码

```C#
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Implicit",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Implicit,//隐藏模式
                    RedirectUris={"http://localhost:5726/Ids4/IndexToken" },//可以多个，根据请求来的转发
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

在Postman,设置如下请求http://localhost:5726/Ids4/Index ，该页面是需要授权才能访问的，所以我们需要在【Authorization】选项卡配置获取token的参数配置，如下图所示：

![1613542182822](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542182822.png)

点击【Get New Access Token】按钮，会弹出如下弹框，其实是跳转到认证中心（IdentityServer4项目）

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542546481.png" alt="1613542546481" style="zoom:80%;" />

输入账号密码：

```C#
        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }
```

```C#
                     Username="Eleven",
                     Password="123456",
```

点击登录后，会弹出如下弹框，询问用户是否授权

![1613542658446](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542658446.png)

点击【Yes,Allow】进行授权。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542811276.png" alt="1613542811276" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542845423.png" alt="1613542845423" style="zoom:80%;" />

获取access_token:

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDI3OTMsImV4cCI6MTYxMzU0NjM5MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjpbIlVzZXJBcGkiLCJUZXN0QXBpIl0sImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQyNjMyLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSIsIlRlc3RBcGkiXSwiYW1yIjpbInB3ZCJdfQ.DIejxN3m1RrNuVm-MyTFCWOmlKly1NP367AXCCiB8DK7KdQqCzlTFnjpHhLh3I2zjbXX1N3WjfTaWTFz8dg5qbHSHT_jTbYKXMHwbn4XxZLwKHFe_NxA8pMXAtcF5w-YNGZFK16JdUU_Ww1i05EIGoB5Os1TV9rusQeqAVXLqpwjvNgepLhtoujMWgMeqtH3zQHO7i_LyB_wa00dktjpp02ep___0Q8S0VmxjyeyYwlBZ2aCyfrWwjat5jmgRmNlSX90eU_Y2gronwMgjCJcmzHdl7JwkEMO6P60ZdCK2TZ-psHJlxAqFcusAcwbBlzTEzR19tva5bIQX7XI3eD3qw
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613542793,
  "exp": 1613546393,
  "iss": "http://localhost:7200",
  "aud": [
    "UserApi",
    "TestApi"
  ],
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613542632,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "UserApi",
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

在上述步骤中获取的access_token, 点击【Use Token】，就可以访问收取页面了

![1613543012648](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613543012648.png)



###### 浏览器模拟第三方应用

访问授权页面http://localhost:5726/Ids4/Index ，返回401，

访问如下地址，获取 access_token

```md
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexToken&response_type=token&scope=UserApi
```

注意, 参数：**response_type=token**，在OAuth2.0协议上表示的是获取access_token



![1613544071226](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613544071226.png)输入账号密码：

 Username="Eleven",
 Password="123456",

点击【Login】后，跳转到【授权确认页面】：

> **【授权确认页面】这个页面只会出现一次，往后就不会在出现**，即使是在浏览器中删除了Cookie，也不会出现，除非重启【IdentityServer4项目】

![1613546699863](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613546699863.png)

点击【Yes,Allow】按钮，跳转回API项目：

```md
http://localhost:5726/Ids4/IndexToken#access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDQxMzMsImV4cCI6MTYxMzU0NzczMywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQ0MTMzLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.bPlbURxEtinlnl842bZS5JG5wKNPtztLtwoxZlncWKTHQrHXZMHjU3FQ93tM6QzUpmV9MWh0ixrCb0Zv6tozCtK7ezDJ8ZVIyLgS_FxrffmVAaJpu_1hvxgaLL5o2T32qo8wP9xWw5NHdxR5iTD9l9aUfizNgcWt-pK9ezJ_FM-lXMnCoOtHmkeI_P-M7w17H4j1mHLloZ2aPRTaeOdZjbxaag-Zk3Mj4gkf9w4Pd71xp93jhRQqTiDRSFlA-XXVnVazesxzr32HQKElsipV-ReT4Zb-rAFzOvVclhpWXyYIZ-jRtlSbnhgte9H-yyA1OKGaC1jY0kVZSuu5P-NCZQ&token_type=Bearer&expires_in=3600&scope=UserApi
```

**我们可以在http://localhost:5726/Ids4/IndexToken 对应的控制器`IndexTokenController`中，获取access_token，并保持在缓存中，以后的每次请求都带上即可。**

下面在`IndexToken.cshtml`中演示了如何从返回的Url中获取access_token:

```html

@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>

<script type="text/javascript">
        var token = null;
        window.onload = function () {
            var url = window.location.href;

            var array = url.split("#");
            if (array.length > 1) {
                token = array[1];
             document.getElementById("token").innerHTML = token;
            }
        }
</script>
```

然后客户端就可以在请求中带入**access_token**即可访问授权页面



#### Code(授权码模式) 

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/oathun-code-model.png" style="zoom:80%;" />

先授权码，通过授权码去获取Token，保护密码-保护token



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region Code模式
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryApiResources(CodeInitConfig.GetApiResources()) //API访问授权资源
               .AddInMemoryClients(CodeInitConfig.GetClients())//客户端
               .AddTestUsers(CodeInitConfig.GetUsers()); //添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

`CodeInitConfig.cs`

```C#
   /// <summary>
    /// 授权码模式：用户---朝夕---腾讯授权中心
    /// http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code&scope=UserApi
    /// 用户访问朝夕---需要token---跳转到授权中心---朝夕提供地址---然后用户向腾讯授权中心输入账号密码
    /// --返回Code--拿着Code+clientpassword通过后端去获取token
    /// 
    /// f9iE2qzai38_dHvA8nef-zN0IH3OrbKY9Ut6Twar2R0
    /// 
    /// </summary>
    public class CodeInitConfig
    {
        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")
                new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),
                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Code",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Code,//授权码
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

代码解析：

```C#
RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" }
```

授权后回调的第三方应用的链接，回调时会携带授权码（author_token）,



启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region IdentityServer4--Code
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

认证回到页面：

```C#
    public class Ids4Controller : Controller
    {

        [AllowAnonymous]
        public IActionResult IndexCodeToken()
        {
            return View();
        }
    }
}
```

```html

@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>

<script type="text/javascript">
        var token = null;
        window.onload = function () {
            var url = window.location.href;

            var array = url.split("#");
            if (array.length > 1) {
                token = array[1];
             document.getElementById("token").innerHTML = token;
            }
        }
</script>
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

###### 前端js

使用 a javascript library named *oidc-client*  

[*oidc-client* ](https://cdnjs.cloudflare.com/ajax/libs/oidc-client/1.6.1/oidc-client.js)



###### 用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

认证地址： http://localhost:7200/connect/authorize 

认证回调地址，我们注册为：http://localhost:5726/Ids4/IndexCodeToken,参见如下代码

```C#
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Code",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Code,//授权码
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

在Postman,设置如下请求http://localhost:5726/Ids4/Index ，该页面是需要授权才能访问的，所以我们需要在【Authorization】选项卡配置获取token的参数配置，如下图所示：

![1613549366777](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549366777.png)

点击【Get New Access Token】按钮，会弹出如下弹框，其实是跳转到认证中心（IdentityServer4项目）

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542546481.png" alt="1613542546481" style="zoom:80%;" />

输入账号密码：

```C#
        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",
                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim("eMail","57265177@qq.com")
                    }
                }
            };
        }
```

```C#
                     Username="Eleven",
                     Password="123456",
```

点击登录后，会弹出如下弹框，询问用户是否授权

![1613549447329](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549447329.png)

点击【Yes,Allow】进行授权。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542811276.png" alt="1613542811276" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549498428.png" alt="1613549498428" style="zoom:80%;" />

获取access_token:

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDk0NjAsImV4cCI6MTYxMzU1MzA2MCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQyNjMyLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.V4gNncsNOUxAN16nPMCudVQ5vwArthLH6UGsUh8GjSnEt4dZCLisM7EFqpQ__AJhekpdiKARjemNOKFbvxDd_2DtiFAxfWkhOvjrHPg_KBqD6bdwrL-3w2BzFgclKS4K3dkqGrv7kmYR8iWZ7z8eIoOYRoqLWpffuNHdegOFO5KfQpfykp9Tq79v5JZTSImJnhaIO5rWrFvQhsR4zgz2lhGo7LbUnxpNpXbkKhYBfMfn35i8L3ndrk0Yf67frlJ7S7Vqf7lGIrfP_qaGMQSRtUZGirX_V-4w-alaXkfmkdKtap4h-eIJmECOaOBk2vQDVnjhZhVSxQ2d2zrbjLyh4Q
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613549460,
  "exp": 1613553060,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613542632,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "UserApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

在上述步骤中获取的access_token, 点击【Use Token】，就可以访问收取页面了

![1613549819145](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549819145.png)



###### 浏览器模拟第三方应用

访问授权页面http://localhost:5726/Ids4/Index ，返回401，

访问如下地址，获取 授权码，

```md
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code&scope=UserApi
```

注意, 参数：response_type=code，表示的是获取授权码

![1613547817771](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613547817771.png)

输入账号密码：

 Username="Eleven",
 Password="123456",

点击【Login】后，点击【Login】后，跳转到【授权确认页面】：

![1613547904460](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613547904460.png)

点击【Yess, Allow】按钮后，跳转回API项目：

![1613548237420](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613548237420.png)

```md
http://localhost:5726/Ids4/IndexCodeToken?code=IkAPVJWMfIYvEFqN22SH7ZV6NgNvI2CIhUGuHERo7p8&scope=UserApi
```

，从回调的Url中，我们可以获取到授权码：

```md
IkAPVJWMfIYvEFqN22SH7ZV6NgNvI2CIhUGuHERo7p8
```



然后，第三方应用过通过这个授权码去获取**access_token**,具体的做法是：

发送POST请求（带上授权码）到获取 token（**access_token**）的地址：

Post:  http://localhost:7200/connect/token

form-data:

```json
grant_type:authorization_code
client_id:Zhaoxi.AspNetCore31.AuthDemo
client_secret:eleven123456
scope:UserApi
redirect_uri:http://localhost:5726/Ids4/IndexCodeToken
code:IkAPVJWMfIYvEFqN22SH7ZV6NgNvI2CIhUGuHERo7p8
```

其中，code请求参数放的就是授权码；



下面是2种方式通过授权码码获取accesss_token的方法演示：

- Postman:

  ![1613556067572](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613556067572.png)

  

- 第三方应用项目的页面中获取

​      我们修改下回调页面`IndexCodeToken.cshtml`:

![1613554382692](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613554382692.png) 

这里添加了一个按钮【 获取access_token 】，根据当前获取到的授权码，去获取access_token

```js
        $("#btn_get_access_token").click(function () {
            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType":"json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "UserApi",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
            });
        })
```

![1613558142793](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613558142793.png)

完整代码如下：

```html

@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>


<button id="btn_get_access_token">获取access_token</button>
<h3>access_token：</h3>
<h3 id="access_token"></h3>

<script type="text/javascript">
    var authorization_code = ""; //授权码
    var content = "";
    window.onload = function () {
        var url = window.location.href;

        var array = url.split("#");
        if (array.length > 1) {
            content = array[1];
        }
        var search = window.location.search;
        if (search) {
            search = search.substr(1);
            var paras = search.split("&");
            paras.forEach(element => {
                content += element;
                content += ";"
            });//序列化处理
        }
        document.getElementById("token").innerHTML = content;

        if (search) {
            search = search.substr(1);
            var paras = search.split("&");
            var codeQueryStr = paras[0]; //code = Mm86eRw - iXt8DcZH_0RcIv0 - ruQ7mhZcLFWsbj5tb3w

            var authorization_code = codeQueryStr.split("=")[1];
        }

        $("#btn_get_access_token").click(function () {
            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType":"json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "UserApi",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
            });
        })

    }
</script>
```



**注意，需要在IdentityServer4项目添加如下代码解决跨域问题**

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region 支持跨域  所有的Api都支持跨域
                
            services.AddCors(option => option.AddPolicy("AllowCors", 
             _build => _build.AllowAnyOrigin().AllowAnyMethod()));
         
            #endregion
     }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
          app.UseCors("AllowCors");
    }
  
```



*[Course-41]*

#### OpenID Connect

**OIDC（OpenID Connect）**是在OAuth2上构建了一个身份层，是一个基于OAuth2协议的身份认证标准协议。

**OAuth2** 授权协议---解决了N多个快递员如何进小区的问题Access_Token---门卫不知道快递员是谁---没有用户信息(可以有，但是不关心，因为协议没有规范说这里有用户信息，无规范就无普遍认可)



两者表现出来是一样的，但是出发点不同

OAuth----->Access_Token
OIDC----->Id_Token
一次请求，可以拿到2个token



#### Hybrid(混合模式)



参考资料：

https://chsakell.com/2019/03/11/asp-net-core-identity-series-oauth-2-0-openid-connect-identityserver/

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/author-hybird.png" style="zoom:80%;" />

 在**Code(授权码模式)**或者**Imlplicit(隐藏模式)**的基础上多返回一个`id_token`，这种模式就是**Hybird(混合模式)**



##### IdentityServer4项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {
            #region Hybrid模式
            services.AddIdentityServer()
               .AddDeveloperSigningCredential()//默认的开发者证书 
               .AddInMemoryIdentityResources(HybridInitConfig.GetIdentityResources())//身份信息授权资源
               .AddInMemoryApiResources(HybridInitConfig.GetApiResources()) //API访问授权资源
               .AddInMemoryClients(HybridInitConfig.GetClients())//客户端
               .AddTestUsers(HybridInitConfig.GetUsers()); //添加用户
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
        #region 添加IdentityServer中间件
        app.UseIdentityServer();//拦截部分请求
        #endregion
   }
```

- 多了个身份信息授权资源

```C#
.AddInMemoryIdentityResources(HybridInitConfig.GetIdentityResources())//身份信息授权资源
```



`HybridInitConfig.cs`

```C#
   /// <summary>
    /// 混合模式:access_token+id_token
    /// http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code%20token%20id_token&scope=UserApi%20openid%20CustomIdentityResource&response_model=fragment&nonce=12345

    /// 
    /// 4种模式：code,code%20token,code%20id_token,code%20token%20id_token
    /// 获取tokenid，scope必须%20openid，其他随意
    /// 必须加入nonce
    /// 自定义claim需要从IdentityResource增加，然后allowscope允许
    /// 
    /// http://localhost:5000/connect/authorize?client_id=apiClientImpl&redirect_uri=https://localhost:5002/auth.html&response_type=token&scope=secretapi
    /// </summary>
    public class HybridInitConfig
    {
        /// <summary>
        /// 用户信息，能返回哪些用户信息
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<IdentityResource> GetIdentityResources()
        {
            return new IdentityResource[]
            {
               new IdentityResources.OpenId(),
               new IdentityResources.Profile(),//一堆默认属性
               new IdentityResource(
                   "CustomIdentityResource",
                   "This is Custom Model",
                    new List<string>(){ "phonemodel","phoneprise", "eMail"})//自定义Id资源，植入claim

            };
        }

        /// <summary>
        /// 定义ApiResource   
        /// 这里的资源（Resources）指的就是管理的API
        /// </summary>
        /// <returns>多个ApiResource</returns>
        public static IEnumerable<ApiResource> GetApiResources()
        {
            return new[]
            {
                //new ApiResource("UserApi", "用户获取API"),
                // new ApiResource("TestApi", "用户TestAPI")
                new ApiResource("UserApi", "用户获取API",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" }),
                 new ApiResource("TestApi", "用户TestAPI",new List<string>(){IdentityModel.JwtClaimTypes.Role,"eMail" })
            };
        }

        public static List<TestUser> GetUsers()
        {
            return new List<TestUser>()
            {
                new TestUser()
                {
                     Username="Eleven",
                     Password="123456",
                     SubjectId="0",

                     Claims=new List<Claim>(){
                        new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                        new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven"),
                        new Claim(ClaimTypes.Name,"apiUser"),
                        new Claim("eMail","57265177@qq.com"),
                        new Claim("prog","正式项目"),
                        new Claim("phonemodel","huawei"),
                        new Claim("phoneprise","5000元"),
                    }
                }
            };
        }

        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    AlwaysIncludeUserClaimsInIdToken=true,
                    AllowOfflineAccess = true,

                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for HyBrid",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AccessTokenLifetime=3600,//默认1小时
                    AllowedGrantTypes = GrantTypes.Hybrid,//混合模式
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] {
                        "UserApi",
                        "TestApi",//资源范围
                        IdentityServerConstants.StandardScopes.OpenId,//Ids4：获取Id_token，必需加入"openid"
                         IdentityServerConstants.StandardScopes.Profile,//用户信息范围
                       "CustomIdentityResource"},
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
    }
```

代码解析：

```C#
return new IdentityResource[]
            {
               new IdentityResources.OpenId(),
               new IdentityResources.Profile(),//一堆默认属性
               new IdentityResource(
                   "CustomIdentityResource",
                   "This is Custom Model",
                    new List<string>(){ "phonemodel","phoneprise", "eMail"})//自定义Id资源，植入claim

            };
        }
```

- 多出了`IdentityResource`

- 授权方式为：

  ```C#
    AllowedGrantTypes = GrantTypes.Hybrid,//混合模式
  ```

  

启动项目

```powershell
dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
```



##### API项目

`Startup.cs`

```C#
   public void ConfigureServices(IServiceCollection services)
   {

            #region IdentityServer4--Hybrid
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "UserApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
   }


   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
   {
      #region  Ids4
       app.UseAuthentication();
      #endregion
   }
```

**显然，这个跟客户端模式，API项目的设置没什么变化**

认证回到页面：

```C#
    public class Ids4Controller : Controller
    {

        [AllowAnonymous]
        public IActionResult IndexCodeToken()
        {
            return View();
        }
    }
}
```

```html
@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>
<h3 id="token"></h3>

<script type="text/javascript">
        var token = null;
        window.onload = function () {
            var url = window.location.href;

            var array = url.split("#");
            if (array.length > 1) {
                token = array[1];
             document.getElementById("token").innerHTML = token;
            }
        }
</script>
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



##### 第三方应用

###### 前端js

使用 a javascript library named *oidc-client*  

[*oidc-client* ](https://cdnjs.cloudflare.com/ajax/libs/oidc-client/1.6.1/oidc-client.js)



###### 用Postman模拟第三方应用,

访问http://localhost:7200/.well-known/openid-configuration

可以知道认证中心的相关信息，比如：

认证地址： http://localhost:7200/connect/authorize 

认证回调地址，我们注册为：http://localhost:5726/Ids4/IndexCodeToken,参见如下代码



在Postman,设置如下请求http://localhost:5726/Ids4/Index ，该页面是需要授权才能访问的，所以我们需要在【Authorization】选项卡配置获取token的参数配置，如下图所示：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613641205777.png" alt="1613641205777"  />



往下失败的,因为根据以上配置，查看PostMan的控制台，知道产生的 获取授权码的链接是：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613641248329.png" alt="1613641248329"  />

```html
http://localhost:7200/connect/authorize?response_type=code&state=abc123456&client_id=Zhaoxi.AspNetCore31.AuthDemo&scope=openid UserApi CustomIdentityResource&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken
```

而正确的地址是：

```html
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code token id_token&scope=UserApi openid CustomIdentityResource&response_model=fragment&nonce=12345
```



**------综上以下失败，不出现：待日后再解决----**

点击【Get New Access Token】按钮，会弹出如下弹框，其实是跳转到认证中心（IdentityServer4项目）

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542546481.png" alt="1613542546481" style="zoom:80%;" />

输入账号密码：

```C#
                     Username="Eleven",
                     Password="123456",
```

点击登录后，会弹出如下弹框，询问用户是否授权

![1613549447329](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549447329.png)

点击【Yes,Allow】进行授权。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613542811276.png" alt="1613542811276" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549498428.png" alt="1613549498428" style="zoom:80%;" />

获取access_token:

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM1NDk0NjAsImV4cCI6MTYxMzU1MzA2MCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNTQyNjMyLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVXNlckFwaSJdLCJhbXIiOlsicHdkIl19.V4gNncsNOUxAN16nPMCudVQ5vwArthLH6UGsUh8GjSnEt4dZCLisM7EFqpQ__AJhekpdiKARjemNOKFbvxDd_2DtiFAxfWkhOvjrHPg_KBqD6bdwrL-3w2BzFgclKS4K3dkqGrv7kmYR8iWZ7z8eIoOYRoqLWpffuNHdegOFO5KfQpfykp9Tq79v5JZTSImJnhaIO5rWrFvQhsR4zgz2lhGo7LbUnxpNpXbkKhYBfMfn35i8L3ndrk0Yf67frlJ7S7Vqf7lGIrfP_qaGMQSRtUZGirX_V-4w-alaXkfmkdKtap4h-eIJmECOaOBk2vQDVnjhZhVSxQ2d2zrbjLyh4Q
```

在网站https://jwt.ms/解析token(jwt编码格式，jwt-token):

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613549460,
  "exp": 1613553060,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613542632,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "UserApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

访问下只用授权才能查看的页面

```C#
public class Ids4Controller : Controller       
{
       [Authorize]
        public IActionResult Index()
        {
            foreach (var item in base.HttpContext.User.Identities.First().Claims)
            {
                Console.WriteLine($"{item.Type}:{item.Value}");
            }
           
            return View();
        }
```



使用PostMan带上token访问 http://localhost:5726/Ids4/Index ：

在上述步骤中获取的access_token, 点击【Use Token】，就可以访问收取页面了

![1613549819145](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613549819145.png)



###### 浏览器模拟第三方应用

访问授权页面http://localhost:5726/Ids4/Index ，返回401，



**获取授权码**

访问如下地址，混合模式:access_token+id_token

```md
http://localhost:7200/connect/authorize?client_id=Zhaoxi.AspNetCore31.AuthDemo&redirect_uri=http://localhost:5726/Ids4/IndexCodeToken&response_type=code token id_token&scope=UserApi openid CustomIdentityResource&response_model=fragment&nonce=12345
```

注意, 参数：

- response_type=code token id_token，表示的是获取access_token+id_token
- scope=UserApi openid： 请求的授权范围
- response_model=fragment
- nonce=12345



![1613547817771](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613547817771.png)

输入账号密码：

 Username="Eleven",
 Password="123456",

点击【Login】后，点击【Login】后，跳转到【授权确认页面】：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613628920486.png" alt="1613628920486" style="zoom:100%;" />

看到了混合模式，多出一项授权内容，即获取身份信息的授权：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613629006593.png" alt="1613629006593" style="zoom:80%;" />



点击【Yess, Allow】按钮后，跳转回API项目：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613629428376.png" alt="1613629428376" style="zoom:80%;" />

跳转Uri：

```md
http://localhost:5726/Ids4/IndexCodeToken#code=44oIc1DHRFUHVAhOwNBHJ_iyORa0a2J-z-Pq9GViL7c&id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYyOTY4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiWmhhb3hpLkFzcE5ldENvcmUzMS5BdXRoRGVtbyIsIm5vbmNlIjoiMTIzNDUiLCJpYXQiOjE2MTM2MjkzODMsImF0X2hhc2giOiJ4RE1wSmQ0eGh4enBPYkJJZXVMUW9RIiwiY19oYXNoIjoiREJfYWFlMFRMS2R0ZWdFZkg3TnRfUSIsInNpZCI6InFOd2owcTJzdFZIcHFhZjhHQno1SnciLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwicGhvbmVtb2RlbCI6Imh1YXdlaSIsInBob25lcHJpc2UiOiI1MDAw5YWDIiwiYW1yIjpbInB3ZCJdfQ.JNmYxEDq80FxLyd3WWsj3qc1KQf0VIdWu0ss4S9PC-Mv8ZMYjicgBoSaETuooiE-Qt4gA61-bfURk6lwaE1YkO6agP-iQGxSmKpp_MbRUNn03hZ4o5eard-XgqsXS_fLiZj3-9X_idgtT13qELEN0p3nYzRqUe5iWyJSd6wy30A6QhC9qi81qtrKtGAuRZE0MCCJP8xUzbQx7zvDeYS7QvoQtx2TiNtlzGhEA9GqYoFoLrk8OrZa0EymAMX4JWZ2zztfDw9tScO7V1NBST8BFP-S_lMssluDSoRSZUN-ovShd4ediOht1mM6vXJH42MbDRyAozGboN1M1Fhbg8D2fg&access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYzMjk4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsib3BlbmlkIiwiQ3VzdG9tSWRlbnRpdHlSZXNvdXJjZSIsIlVzZXJBcGkiXSwiYW1yIjpbInB3ZCJdfQ.BdlY-g8aDYIrgi2kuMlvla1UF3FI6txlz4EVx1sU_d-C1Mt-ZInt4ZaH1_jVe5eu69malQrYLJKkx41Kfy9LDXdfk4ePWUYBw8p3t1IImWDGL0ro4ngS71Y9x0_-ArxH3c_8PMjx7J8v_ZE_H2qB7CWGPqQQTtQL5adkGbA3fLaSyJdMSSgFOYhgEFirXjnDy5OlsmgYNL4DefIcQMdrGosAJgGot2wlJwyPa18rhTLULb3zfOr36pUoUUp71cmQTsAA-aGNpJC3SXPmyb98N426ka138VPIfQtAGKiEMgr3gXcsvHh8brm6GeDBiy-b8GmU5WCpBrBTSrVci88cnQ&token_type=Bearer&expires_in=3600&scope=openid CustomIdentityResource UserApi&session_state=BK-2C9SZLvA-ktDKrHwbs8DCGRuiKn4zgLhuRm8x-EQ.zMElkwSVzl52uo-eitYHVA
```

，从回调的Url中，我们可以获取到：

- 授权码(authorization code)：

```md
44oIc1DHRFUHVAhOwNBHJ_iyORa0a2J-z-Pq9GViL7c
```

- id_token:

  ```md
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYyOTY4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiWmhhb3hpLkFzcE5ldENvcmUzMS5BdXRoRGVtbyIsIm5vbmNlIjoiMTIzNDUiLCJpYXQiOjE2MTM2MjkzODMsImF0X2hhc2giOiJ4RE1wSmQ0eGh4enBPYkJJZXVMUW9RIiwiY19oYXNoIjoiREJfYWFlMFRMS2R0ZWdFZkg3TnRfUSIsInNpZCI6InFOd2owcTJzdFZIcHFhZjhHQno1SnciLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwicGhvbmVtb2RlbCI6Imh1YXdlaSIsInBob25lcHJpc2UiOiI1MDAw5YWDIiwiYW1yIjpbInB3ZCJdfQ.JNmYxEDq80FxLyd3WWsj3qc1KQf0VIdWu0ss4S9PC-Mv8ZMYjicgBoSaETuooiE-Qt4gA61-bfURk6lwaE1YkO6agP-iQGxSmKpp_MbRUNn03hZ4o5eard-XgqsXS_fLiZj3-9X_idgtT13qELEN0p3nYzRqUe5iWyJSd6wy30A6QhC9qi81qtrKtGAuRZE0MCCJP8xUzbQx7zvDeYS7QvoQtx2TiNtlzGhEA9GqYoFoLrk8OrZa0EymAMX4JWZ2zztfDw9tScO7V1NBST8BFP-S_lMssluDSoRSZUN-ovShd4ediOht1mM6vXJH42MbDRyAozGboN1M1Fhbg8D2fg&access_token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2MjkzODMsImV4cCI6MTYxMzYzMjk4MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjI4ODg0LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsib3BlbmlkIiwiQ3VzdG9tSWRlbnRpdHlSZXNvdXJjZSIsIlVzZXJBcGkiXSwiYW1yIjpbInB3ZCJdfQ.BdlY-g8aDYIrgi2kuMlvla1UF3FI6txlz4EVx1sU_d-C1Mt-ZInt4ZaH1_jVe5eu69malQrYLJKkx41Kfy9LDXdfk4ePWUYBw8p3t1IImWDGL0ro4ngS71Y9x0_-ArxH3c_8PMjx7J8v_ZE_H2qB7CWGPqQQTtQL5adkGbA3fLaSyJdMSSgFOYhgEFirXjnDy5OlsmgYNL4DefIcQMdrGosAJgGot2wlJwyPa18rhTLULb3zfOr36pUoUUp71cmQTsAA-aGNpJC3SXPmyb98N426ka138VPIfQtAGKiEMgr3gXcsvHh8brm6GeDBiy-b8GmU5WCpBrBTSrVci88cnQ
  ```

  特别注意，这里得到的Id_token 不是我们讲到的Id_token

  

**获取access_token和Id_token**

然后，第三方应用过通过这个授权码去获取**access_token**,具体的做法是：

发送POST请求（带上授权码）到获取 **access_toke**和 **Id_token**的地址：

Post:  http://localhost:7200/connect/token

form-data:

```json
grant_type:authorization_code
client_id:Zhaoxi.AspNetCore31.AuthDemo
client_secret:eleven123456
scope:openid UserApi CustomIdentityResource
redirect_uri:http://localhost:5726/Ids4/IndexCodeToken
code:44oIc1DHRFUHVAhOwNBHJ_iyORa0a2J-z-Pq9GViL7c
```

其中，code请求参数放的就是授权码；



下面是2种方式通过授权码码获取accesss_token和Id_token的方法演示：

- Postman:

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613635681387.png" alt="1613635681387"  />


返回值：

```json
{
    "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2MTM2MzU0NzgsImV4cCI6MTYxMzYzNTc3OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiWmhhb3hpLkFzcE5ldENvcmUzMS5BdXRoRGVtbyIsIm5vbmNlIjoiMTIzNDUiLCJpYXQiOjE2MTM2MzU0NzgsImF0X2hhc2giOiIxNlNKcklKcEsxN1lrTkJfTllxU053Iiwic2lkIjoiTHlLT3JrSWVCUlJILXgxNnYxZlNVQSIsInN1YiI6IjAiLCJhdXRoX3RpbWUiOjE2MTM2MzU0NTEsImlkcCI6ImxvY2FsIiwiZU1haWwiOiI1NzI2NTE3N0BxcS5jb20iLCJwaG9uZW1vZGVsIjoiaHVhd2VpIiwicGhvbmVwcmlzZSI6IjUwMDDlhYMiLCJhbXIiOlsicHdkIl19.PD4TMgF8KH6MgTWttmIkTgRlqoEDm_Pu6kL6Ia9GxxWst4Bf3M1xeZhhXCTK2ni8GoQupLq_MvccTv1cMBnc0s-eb6MxqrX9NZ_H4ZPV0vJI3pbTe_Mkyc0rU9ZeXrzYH50GvwGOpxraij9SdSkmr_WG_R6m9-uOvyvQcWSC-KqBj4oaZizisH6536RF0xliEylYLWcNsH839gBulFl6LQaQObmd73douLYLF-GeUOpxkp9BJJYMIw0obElAw0XL6kXCZ0fhdDYvaef631CTFdE0Fs6LWvqDXOvZI5c9RZzn1HnTjWpbbF564kegWFJQEDGvd2N0AHNrsbRG_yDrgA",
    "access_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2MzU0NzgsImV4cCI6MTYxMzYzOTA3OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVXNlckFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjM1NDUxLCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsib3BlbmlkIiwiQ3VzdG9tSWRlbnRpdHlSZXNvdXJjZSIsIlVzZXJBcGkiXSwiYW1yIjpbInB3ZCJdfQ.OQAwXFub4-ggrpwLkg0TnAF3QYZuC6W7wvt82dqvEz2dloiMUZMdyfUS8ryvckfjQ_0kbeg7jng43lQ4fhziy93UEmVGKjI-bFWJtTUze5PhofgfYtGpK5updONiw2imIwjaA-LWRUebQ3OUEd4KONy2W0MAAui86fpzUMNSB8d6gwyYtkTVYQ3SMnvokP6qy6kEh94XnrELSoP5sHJWczAWcdcbp3dAgorGrwcwvLTbZo5hnqQa5eDSQwxqoTExyuxIeqLEg7HQNDgZ_TWAXo2-cLkW2Tid3rAYQuK8PFfLvwG4b9qlRehQ78r2TC48_t259kEioX4bIu6PW-Kd8A",
    "expires_in": 3600,
    "token_type": "Bearer",
    "scope": "openid CustomIdentityResource UserApi"
}
```



**id_token**:

```md
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "JWT"
}.{
  "nbf": 1613635478,
  "exp": 1613635778,
  "iss": "http://localhost:7200",
  "aud": "Zhaoxi.AspNetCore31.AuthDemo",
  "nonce": "12345",
  "iat": 1613635478,
  "at_hash": "16SJrIJpK17YkNB_NYqSNw",
  "sid": "LyKOrkIeBRRH-x16v1fSUA",
  "sub": "0",
  "auth_time": 1613635451,
  "idp": "local",
  "eMail": "57265177@qq.com",
  "phonemodel": "huawei",
  "phoneprise": "5000元",
  "amr": [
    "pwd"
  ]
}.[Signature]
```



**access_token**

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613635478,
  "exp": 1613639078,
  "iss": "http://localhost:7200",
  "aud": "UserApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613635451,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "openid",
    "CustomIdentityResource",
    "UserApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```



- 第三方应用项目的页面中获取

​      我们修改下回调页面`IndexCodeToken.cshtml`:

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613638947589.png" alt="1613638947589" style="zoom:80%;" /> 

这里添加了一个按钮【 获取access_token和id_token 】，

根据当前获取到的授权码，去获取access_token和Id_token

```js
                $("#btn_get_access_token").click(function () {
            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType": "json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "openid UserApi CustomIdentityResource",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code,
                   
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
                document.getElementById("id_token").innerHTML = response.id_token;
            });
        })
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613639011605.png" alt="1613639011605" style="zoom:80%;" />

完整代码如下：

```html


@{
    ViewData["Title"] = "IndexToken";
}

<h1>IndexToken</h1>

<h3>token:</h3>
<p id="token"></p>


<button id="btn_get_access_token">获取access_token和id_token</button>

<h3>id_token：</h3>
<p id="id_token"></p>

<h3>access_token：</h3>
<p id="access_token"></p>

<script type="text/javascript">
    var authorization_code = ""; //授权码
    var content = "";
    window.onload = function () {
        var url = window.location.href;
        
        var array = url.split("#");
        if (array.length > 1) {
            content = array[1];

            var paras = content.split("&");
            var codeQueryStr = paras[0]; //code = Mm86eRw - iXt8DcZH_0RcIv0 - ruQ7mhZcLFWsbj5tb3w
            console.log("codeQueryStr: " + codeQueryStr)
            authorization_code = codeQueryStr.split("=")[1]; //array[1].split('&')[0].split("=")[1]

        }
        var search = window.location.search;
        if (search) {
            search = search.substr(1);
            var paras = search.split("&");
            paras.forEach(element => {
                content += element;
                content += ";"
            });//序列化处理
        }
        document.getElementById("token").innerHTML = content;


        $("#btn_get_access_token").click(function () {

            console.log("authorization_code：" + authorization_code)

            var settings = {
                "url": "http://localhost:7200/connect/token",
                "method": "POST",
                "timeout": 0,
                "dataType": "json",
                "data": {
                    "grant_type": "authorization_code",
                    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
                    "client_secret": "eleven123456",
                    "scope": "openid UserApi CustomIdentityResource",
                    "redirect_uri": "http://localhost:5726/Ids4/IndexCodeToken",
                    "code": authorization_code,
                }
            };

            //根据授权码获取access_token
            $.ajax(settings).done(function (response) {
                console.log(response);
                document.getElementById("access_token").innerHTML = response.access_token;
                document.getElementById("id_token").innerHTML = response.id_token;
            });
        })
    }
</script>
```



**注意，需要在IdentityServer4项目添加如下代码解决跨域问题**

```C#
     public void ConfigureServices(IServiceCollection services)
     {
            #region 支持跨域  所有的Api都支持跨域
                
            services.AddCors(option => option.AddPolicy("AllowCors", 
             _build => _build.AllowAnyOrigin().AllowAnyMethod()));
         
            #endregion
     }

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
          app.UseCors("AllowCors");
    }
  
```



*[Course-41]*



#### IdentityServer4-集成数据库

参考资料：

- https://chsakell.com/2019/03/11/asp-net-core-identity-series-oauth-2-0-openid-connect-identityserver/

- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/Docs/IdentityServer%20%E5%AE%9E%E6%88%98.md
- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Startup.cs

##### 2个半DbContext

引用如下包：

```xml
 <PackageReference Include="IdentityServer4.EntityFramework" Version="3.1.3" />
 <PackageReference Include="IdentityServer4.EntityFramework.Storage" Version="3.1.3" />
```



- ConfigurationDbContext

  ```C#
  public class ConfigurationDbContext<TContext> : DbContext, 
  IConfigurationDbContext, 
  IDisposable 
  where TContext : DbContext, IConfigurationDbContext
  {
          public DbSet<Client> Clients { get; set; }
          public DbSet<IdentityResource> IdentityResources { get; set; }
          public DbSet<ApiResource> ApiResources { get; set; }
  }
  ```

  包含：客户端-资源-Identity 相关配置信息

  

- PersistedGrantDbContext

  ```C#
  //
  // 摘要:
  //     DbContext for the IdentityServer operational data.
  public class PersistedGrantDbContext<TContext> : DbContext, IPersistedGrantDbContext, IDisposable 
  where TContext : DbContext, IPersistedGrantDbContext
  {
  
          public PersistedGrantDbContext(DbContextOptions options, OperationalStoreOptions storeOptions);
  
          public DbSet<PersistedGrant> PersistedGrants { get; set; }
          public DbSet<DeviceFlowCodes> DeviceFlowCodes { get; set; }
  }
  ```

  保持 操作数据：grant-type 、token

- 用户信息

  CustomUserDbContext：没有内置，自己添加

  用户账号密码等信息

  一般我们会有基于`AspNetCore.Identity`框架建立的身份认证系统，比如：
  
  见示例：https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Startup.cs
  
  ```C#
              services.AddDbContext<ApplicationDbContext>(options =>
              {
                  if (useInMemoryStores)
                  {
                      options.UseInMemoryDatabase("IdentityServerDb");
                  }
                  else
                  {
                      options.UseSqlServer(connectionString);
                  }
              });        
             services.AddIdentity<IdentityUser, IdentityRole>()
                  .AddEntityFrameworkStores<ApplicationDbContext>()
                  .AddDefaultTokenProviders();
  ```
  
  我们可以使用`IdentityServer4`的扩展方法`AddAspNetIdentity`
  
  ```C#
  
  #region 程序集 IdentityServer4.AspNetIdentity, Version=3.0.1.0, Culture=neutral, PublicKeyToken=f294d0afe402bb2b
  #endregion
  
  namespace Microsoft.Extensions.DependencyInjection
  {
      //
      // 摘要:
      //     Extension methods to add ASP.NET Identity support to IdentityServer.
      public static class IdentityServerBuilderExtensions
      {
          //
          // 摘要:
          //     Configures IdentityServer to use the ASP.NET Identity implementations of IUserClaimsPrincipalFactory,
          //     IResourceOwnerPasswordValidator, and IProfileService. Also configures some of
          //     ASP.NET Identity's options for use with IdentityServer (such as claim types to
          //     use and authenticaiton cookie settings).
          //
          // 参数:
          //   builder:
          //     The builder.
          //
          // 类型参数:
          //   TUser:
          //     The type of the user.
          public static IIdentityServerBuilder AddAspNetIdentity<TUser>(this IIdentityServerBuilder builder) where TUser : class;
      }
  }
  ```
  
  把基于`AspNetCore.Identity`框架建立的身份认证系统集成进去
  
  ```C#
  var builder = services.AddIdentityServer(options =>
       {
       })
      // this adds the config data from DB (clients, resources)
      .AddConfigurationStore(options =>
                             {
  
                             })
      // this adds the operational data from DB (codes, tokens, consents)
      .AddOperationalStore(options =>
                           {
  
                           })
      .AddAspNetIdentity<IdentityUser>();
  ```
  
  

#####  初始化数据库

参考资料：

- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Startup.cs



appsettings.json，添加数据库连接字符串：

```json
  "ConnectionStrings": {
    "DefaultConnection": "Server=.;Database=Ids4-1;User ID=sa;Password=123456;"
  }
```

Startup.cs

```C#
public void ConfigureServices(IServiceCollection services)
{
             var connectionString = this.Configuration.GetConnectionString("DefaultConnection");

            services
                .AddIdentityServer()
                .AddDeveloperSigningCredential()
                .AddConfigurationStore(options =>
                {
                    options.ConfigureDbContext = builder =>
                    {
                        builder.UseSqlServer(connectionString, b => b.MigrationsAssembly("Zhaoxi.AspNetCore31.AuthenticationCenterIds4"));
                    };
                })
                .AddConfigurationStore(options =>
                {
                    options.ConfigureDbContext = builder =>
                    {
                        builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                    };
                })
                .AddOperationalStore(options =>
                {
                    options.ConfigureDbContext = builder =>
                    {
                        builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                    };
                })
               .AddTestUsers(PasswordInitConfig.GetUsers());
               //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
               //.AddProfileService<CustomProfileService>();

            services.InitSeedData(connectionString);//初始原来的那些内存数据
}
```

代码解析：

- 没有用户，所以**我们这里使用密码模式下的内存用户信息**：

  ```C#
  AddTestUsers(PasswordInitConfig.GetUsers())
  ```




在VS程序包管理控制台，通过如下两个命令，执行数据库迁移：

参考资料：

https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/Data/instructions.md



**设置启动项目为：Zhaoxi.AspNetCore31.AuthenticationCenterIds4，然后执行：**

```powershell
add-migration InitialIdentityServerConfigurationDbMigration -c ConfigurationDbContext -o Data/Migrations/IdentityServer/ConfigurationDb 

add-migration InitialIdentityServerPersistedGrantDbMigration -c PersistedGrantDbContext -o Data/Migrations/IdentityServer/PersistedGrantDb
```

无法迁移：

```md
The EF Core tools version '3.1.0-preview1.19506.2' is older than that of the runtime '3.1.4'. Update the tools for the latest features and bug fixes.
```

The EF Core tools 版本太低，提示升级到`3.1.4`

```powershell
Install-Package Microsoft.EntityFrameworkCore.Tools -Version 3.1.4
```



执行数据库更新：

```powershell
Update-Database -Context ConfigurationDbContext 
Update-Database -Context PersistedGrantDbContext
```

数据库生成如下数据库：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613660629243.png" alt="1613660629243" style="zoom:80%;" />

##### 种子数据

```c#
services.InitSeedData(connectionString);//初始原来的那些内存数据
```

SeedDataInit.cs

参考资料：

- https://github.com/K-Artisan/AspNetCore-Learning/blob/main/AspNetCore.Docs/Security/Identity/AspNetCore.Identity.Samples/identity/IdentityServer4/IdentityServer/DatabaseInitializer.cs

```C#
  public static class SeedDataInit
    {
        /// <summary>
        /// 初始化种子数据
        /// </summary>
        /// <param name="service"></param>
        /// <param name="conncetionString"></param>
        public static void InitSeedData(this IServiceCollection service, string conncetionString)
        {
            var migtationAssembly = typeof(SeedDataInit).GetTypeInfo().Assembly.GetName().Name;
            service.AddConfigurationDbContext(options =>
            {
                options.ConfigureDbContext = db => db.UseSqlServer(conncetionString,
                    sql => sql.MigrationsAssembly(migtationAssembly));
            });
            service.AddOperationalDbContext(options =>
            {
                options.ConfigureDbContext = db => db.UseSqlServer(conncetionString,
                    sql => sql.MigrationsAssembly(migtationAssembly));
            });

            var serviceProvider = service.BuildServiceProvider();

            using (var scope = serviceProvider.GetRequiredService<IServiceScopeFactory>().CreateScope())
            {
                scope.ServiceProvider.GetService<PersistedGrantDbContext>().Database.Migrate();
                var context = scope.ServiceProvider.GetService<ConfigurationDbContext>();
                context.Database.Migrate();
                InitCustomSeedData(context);
            }
        }

        private static void InitCustomSeedData(IConfigurationDbContext context)
        {
            if (!context.Clients.Any())
            {
                foreach (var client in PasswordInitConfig.GetClients())
                {
                    context.Clients.Add(client.ToEntity());
                }
                context.SaveChanges();
            }
            if (!context.ApiResources.Any())
            {
                foreach (var api in PasswordInitConfig.GetApiResources())
                    context.ApiResources.Add(api.ToEntity());
                context.SaveChanges();
            }

            //if (!context.IdentityResources.Any())
            //{
            //    foreach (var id in PasswordInitConfig.GetIdentityResources())
            //        context.IdentityResources.Add(id.ToEntity());
            //    context.SaveChanges();
            //}

            //init User
        }
    }
```

这里我们使用之前的**密码模式时定义的APIResource和Client**

```C#
            if (!context.Clients.Any())
            {
                foreach (var client in PasswordInitConfig.GetClients())
                {
                    context.Clients.Add(client.ToEntity());
                }
                context.SaveChanges();
            }
            if (!context.ApiResources.Any())
            {
                foreach (var api in PasswordInitConfig.GetApiResources())
                    context.ApiResources.Add(api.ToEntity());
                context.SaveChanges();
            }
```



##### 密码模式

至此，我们使用了：

   `SeedDataInit.cs`

```C#
            if (!context.Clients.Any())
            {
                foreach (var client in PasswordInitConfig.GetClients())
                {
                    context.Clients.Add(client.ToEntity());
                }
                context.SaveChanges();
            }
            if (!context.ApiResources.Any())
            {
                foreach (var api in PasswordInitConfig.GetApiResources())
                    context.ApiResources.Add(api.ToEntity());
                context.SaveChanges();
            }
```

- 密码模式时的定义的**Clients**，`PasswordInitConfig.GetClients()`,并保持到 数据库

- 密码模式时的定义的**ApiResources**，`PasswordInitConfig.GetApiResources()`,并保持到 数据库

- 密码模式时的定义的**Users**，`PasswordInitConfig.GetUsers()`,通过如下代码添加到内存中

  `Startup.cs`

  ```C#
  services
      .AddIdentityServer()
      .AddDeveloperSigningCredential()      
      ......
      .AddTestUsers(PasswordInitConfig.GetUsers());
      //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
      //.AddProfileService<CustomProfileService>();
  ```

  

User使用的是内存用户信息,下面使用**密码模式**获取token，

在PostMan中建立请求：

POST： http://localhost:7200/connect/token 

form-data：

```json
grant_type:password
client_id:Zhaoxi.AspNetCore31.AuthDemo
client_secret:eleven123456
scope:TestApi
username:Eleven
password:123456
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613662492160.png" alt="1613662492160"  />

得到的token：

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2NjI1MzcsImV4cCI6MTYxMzY2NjEzNywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjYyNTM3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.IqegoFvnB9BsPWy7JItOJ-egKOja75v5vTf4UPpQ436bn9qgvdd05kJu0pz82eVLcQJPLz_nmUKn0E9GmHf75CkmLhd6uo8EfOi01oTUmPFByVihxh8wJJ0IpGNKWENDgM9EYUFqHpWArk83HGE3wRHcVzYxzHlU0ZhwSUM7Yc_W9v8z82xLI0-W2w40sBlj3neos14DuAqCEHu-s1lmejENAG-7fkKM23zgWfgpIYS_8l8HyfCmTepjCghGOg4tkAijhN77EG_eJPRW5zD9hbM2ttPgohJ_UiuHhDBXJ7THY8rqvBY97NGAS5_kO6EvOcDOPg6cRcWQOMYBiIWscQ
```
在网站https://jwt.ms/https://jwt.ms 解析下
```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613662537,
  "exp": 1613666137,
  "iss": "http://localhost:7200",
  "aud": "TestApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613662537,
  "idp": "local",
  "role": "Admin",
  "eMail": "57265177@qq.com",
  "scope": [
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```



API 项目也相应的修改下：

在项目【Zhaoxi.AspNetCore31.AuthDemo】，授权模式修改为**Password(密码模式)**对应的代码

`Startup.cs`

```C#
           #region IdentityServer4--Password
            services.AddAuthentication("Bearer")
                .AddIdentityServerAuthentication(options =>
                {
                    options.Authority = "http://localhost:7200";
                    options.ApiName = "TestApi";
                    options.RequireHttpsMetadata = false;
                });
            services.AddAuthorization(options =>
            {
                options.AddPolicy("eMailPolicy",
                    policyBuilder => policyBuilder
                    .RequireAssertion(context =>
                    context.User.HasClaim(c => c.Type == "eMail")
                    && context.User.Claims.First(c => c.Type.Equals("eMail")).Value.EndsWith("@qq.com")));//Client
            });
            #endregion
```

启动项目：

```powershell
dotnet Zhaoxi.AspNetCore31.AuthDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port= 5726
```



在Postman中创建如下请求，该页面要必须授权才能查看：

POST： http://localhost:5726/Ids4/Index 

Header：

- Authorization:Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM2NjI1MzcsImV4cCI6MTYxMzY2NjEzNywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNjYyNTM3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsImVNYWlsIjoiNTcyNjUxNzdAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.IqegoFvnB9BsPWy7JItOJ-egKOja75v5vTf4UPpQ436bn9qgvdd05kJu0pz82eVLcQJPLz_nmUKn0E9GmHf75CkmLhd6uo8EfOi01oTUmPFByVihxh8wJJ0IpGNKWENDgM9EYUFqHpWArk83HGE3wRHcVzYxzHlU0ZhwSUM7Yc_W9v8z82xLI0-W2w40sBlj3neos14DuAqCEHu-s1lmejENAG-7fkKM23zgWfgpIYS_8l8HyfCmTepjCghGOg4tkAijhN77EG_eJPRW5zD9hbM2ttPgohJ_UiuHhDBXJ7THY8rqvBY97NGAS5_kO6EvOcDOPg6cRcWQOMYBiIWscQ

  

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613664579325.png" alt="1613664579325"  />



##### 添加用户信息`Profile`

```C#
services
    .AddIdentityServer()
    .AddDeveloperSigningCredential()      
    ......
    .AddTestUsers(PasswordInitConfig.GetUsers());
    //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
    .AddProfileService<CustomProfileService>();
```

使用` .AddProfileService<CustomProfileService>();`添加用户信息

`CustomProfileService.cs`

```C#
    public class CustomProfileService: IProfileService
    {
        public Task GetProfileDataAsync(ProfileDataRequestContext context)
        {
            //把用户返回的Claims应用到返回
            context.IssuedClaims = context.Subject.Claims.ToList();
            return Task.CompletedTask;
        }

        /// <summary>
        /// 验证用户是否有效
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public Task IsActiveAsync(IsActiveContext context)
        {
            context.IsActive = true;
            return Task.CompletedTask;
        }
    }
}
```



集成自接口`IProfileService`：

```C#
    //
    // 摘要:
    //     This interface allows IdentityServer to connect to your user and profile store.
    public interface IProfileService
    {
        //
        // 摘要:
        //     This method is called whenever claims about the user are requested (e.g. during
        //     token creation or via the userinfo endpoint)
        //
        // 参数:
        //   context:
        //     The context.
        Task GetProfileDataAsync(ProfileDataRequestContext context);
        //
        // 摘要:
        //     This method gets called whenever identity server needs to determine if the user
        //     is valid or active (e.g. if the user's account has been deactivated since they
        //     logged in). (e.g. during token issuance or validation).
        //
        // 参数:
        //   context:
        //     The context.
        Task IsActiveAsync(IsActiveContext context);
    }
```



使用PostMan工具，使用密码模式获取到token：

```md
eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTM3NTcsImV4cCI6MTYxMzcxNzM1NywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIwIiwiYXV0aF90aW1lIjoxNjEzNzEzNzU3LCJpZHAiOiJsb2NhbCIsInJvbGUiOiJBZG1pbiIsIm5pY2tuYW1lIjoiRWxldmVuIiwiZU1haWwiOiI1NzI2NTE3N0BxcS5jb20iLCJzY29wZSI6WyJUZXN0QXBpIl0sImFtciI6WyJwd2QiXX0.NIw-GIeBYHmHcs82zBWos1D6U71HOAsv1SqQvZuS3r97tXZEF2IP2sy0g-rVF6yrXLoLnCFAmgEyO4HWMGj_8ozZEXAsGIP5WPR2PDW-vmmpQRwR_GUd108eKbljdRbheNmLFaLxt7spMlTFW3WE5n-tGmGxZ7TihIBoBcrtCdwEBTPGSg4G2eJnd57T2xkwk2B2dKagOhJADFQUgyYGYepy_EHfSGH2pqrCfArOIH9HeIPu0_0fELnuYl4mqu-hSN8vsJstViGam-FbvTmgEIZoVgU4YAfaqbEVrkDTrjYQw2heUJom97E2VFbRwao5Q3jNBhDFM5cJD0DJ8MX-Tg
```

解析如下：

```json
{
  "alg": "RS256",
  "kid": "g4NXWvoX11IgmrmCRptyhQ",
  "typ": "at+jwt"
}.{
  "nbf": 1613713757,
  "exp": 1613717357,
  "iss": "http://localhost:7200",
  "aud": "TestApi",
  "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
  "sub": "0",
  "auth_time": 1613713757,
  "idp": "local",
  "role": "Admin",
  "nickname": "Eleven",
  "eMail": "57265177@qq.com",
  "scope": [
    "TestApi"
  ],
  "amr": [
    "pwd"
  ]
}.[Signature]
```

看到多了以下内容：

```json
"nickname": "Eleven",
```



##### 其它模式

上一节演示了使用密码模式，并不是意味着集成了数据库就不能使用其它模式，我们可以在使用种子数据的时候，多初始化其它模式的**Clients**，比如**Code模式的Clients**:

```C#
        /// <summary>
        /// 定义验证条件的Client
        /// </summary>
        /// <returns></returns>
        public static IEnumerable<Client> GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = "Zhaoxi.AspNetCore31.AuthDemo",//客户端惟一标识
                    ClientName="ApiClient for Code",
                    ClientSecrets = new [] { new Secret("eleven123456".Sha256()) },
                    AllowedGrantTypes = GrantTypes.Code,//授权码
                    RedirectUris={"http://localhost:5726/Ids4/IndexCodeToken" },//可以多个
                    AllowedScopes = new [] { "UserApi","TestApi" },//允许访问的资源
                    AllowAccessTokensViaBrowser=true//允许将token通过浏览器传递
                }
            };
        }
```

**但是注意修改下`ClientId`,不能重复（要与密码模式注册的Client的ClientId不同）**



##### 使用现有用户信息

到目前，我们的示例中我们还是使用的是**内存User**，

```C#
services
    .AddIdentityServer()
    .AddDeveloperSigningCredential()      
    ......
    .AddTestUsers(PasswordInitConfig.GetUsers());
    //.AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>()
    //.AddProfileService<CustomProfileService>();
```



但是在实际项目中，我们已经有了自己现成的用户系统信息，那问题是：

**如何把现成的User集成到`IdentityServer4`框架中？**



###### 扩展校验之IResourceOwnerPasswordValidator

- 定义校验扩展

  自定义校验扩展`CustomResourceOwnerPasswordValidator`，继承接口`IResourceOwnerPasswordValidator`

  校验规则是：查询数据库是否存在账号和密码匹配的用户

```C#
    /// <summary>
    /// 自定义用户检测方法---完成数据库校验
    /// </summary>
    public class CustomResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
    {
        private readonly IUserServiceTest _iUsersServices;
        public CustomResourceOwnerPasswordValidator(IUserServiceTest userService)
        {
            _iUsersServices = userService;
        }

        public Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
        {
            Console.WriteLine($"This is CustomResourceOwnerPasswordValidator {context.UserName}--{context.Password}");
            var user = this._iUsersServices.Login(context.UserName, context.UserName);//正常数据库
            if (user == null)
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            else
            {
                context.Result = new GrantValidationResult(
                        user.UId.ToString(),
                        OidcConstants.AuthenticationMethods.Password,
                        DateTime.UtcNow,
                        user.Claims);
            }
            return Task.CompletedTask;
        }
    }
```



这个校验使用数据库的账号和密码校验：

```C#
var user = this._iUsersServices.Login(context.UserName, context.UserName);//正常数据库
```

- 数据库账号和密码校验

  `IUserServiceTest`

  ```C#
      public interface IUserServiceTest
      {
          UserTestDTO Login(string userName, string password);
      }
  ```

  

   `UserServiceTest `

  ```C#
    public class UserServiceTest : IUserServiceTest
      {
          public UserTestDTO Login(string userName, string password)
          {
              return new UserTestDTO()
              {
                  UId = 123,
                  UserName = userName,
                  Password = password,
                  Claims = new List<Claim>(){
                          new Claim(IdentityModel.JwtClaimTypes.Role,"Admin"),
                          new Claim(IdentityModel.JwtClaimTypes.NickName,"Eleven-存储于数据库"),
                          new Claim("eMail","57265177_DataBaseUser.com")
                      }
              };
          }
      }
      public class UserTestDTO
      {
          public int UId { get; set; }
          public string UserName { get; set; }
          public string Password { get; set; }
          public List<Claim> Clais { get; set; }
      }
  ```

- 添加扩展校验

  `Startup.cs`

  添加自定义扩展 校验`CustomResourceOwnerPasswordValidator`：

  ```C#
  services.AddIdentityServer()
      //.AddTestUsers(PasswordInitConfig.GetUsers())
      .AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>();
      //.AddProfileService<CustomProfileService>();
  
  services.AddTransient<IUserServiceTest, UserServiceTest>(); 
  ```

  注意，以下代码已经注释掉了

  ```C#
  //.AddTestUsers(PasswordInitConfig.GetUsers())
  ```

  我们已经不在使用内存User了.

  

  截止`IdentityServer4`相关完整代码如下:

  ```C#
  
              var connectionString = this.Configuration.GetConnectionString("DefaultConnection");
              services
                  .AddIdentityServer()
                  .AddDeveloperSigningCredential()
                  .AddConfigurationStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                      };
                  })
                  .AddOperationalStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString, b => b.MigrationsAssembly(typeof(Startup).Assembly.GetName().Name));
                      };
                  })
                 //.AddTestUsers(PasswordInitConfig.GetUsers())
                 .AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>();
                 //.AddProfileService<CustomProfileService>();
  
              services.InitSeedData(connectionString);//初始原来的那些内存数据
              services.AddTransient<IUserServiceTest, UserServiceTest>(); 
  ```

  

- 使用**密码模式**获取token，

  启动项目，用PostMan工具进行测试，测试流程与**密码模式**一样：

  在PostMan中建立请求：

  POST： http://localhost:7200/connect/token 

  form-data：

  ```json
  grant_type:password
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  scope:TestApi
  username:Eleven
  password:123456
  ```

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613662492160.png" alt="1613662492160"  />

  得到的token：

  ```md
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTA3OTYsImV4cCI6MTYxMzcxNDM5NiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIxMjMiLCJhdXRoX3RpbWUiOjE2MTM3MTA3OTYsImlkcCI6ImxvY2FsIiwicm9sZSI6IkFkbWluIiwiZU1haWwiOiI1NzI2NTE3N0BxcS5jb20iLCJzY29wZSI6WyJUZXN0QXBpIl0sImFtciI6WyJwd2QiXX0.Cupm4iHB8puv_spr16f71xmXotd2DTy7n5IlJnRYL-bjkxxIWpNPSV10V6FsH1ThXPXZN87eEl2H_vOuhjjUnjWkT2B5EM_PRcX-qUY9k_8zg5OdeRR81ePObwXqCbkHI_wnylXSt5OIihlOkY2UfJzDjHfzYAxU1d1LeBQnE0OQet-KZOfd5FDYoGZKymTbkNWWtwlGIpyat7V9-jRrlk-S1f_ZEWsKUxMq2JsvlLgZLBGDjQmzr4pZB8Cx4-rg6a5pKcUVbgxaxGiMEyOIEaLfadQ7fBpitmAJcighsuBMEkxFgow6ubE7l0IB8Do6i7H0j566mH2MfMooFS2G0g
  ```

  在网站https://jwt.ms/https://jwt.ms 解析下

  ```json
  {
    "alg": "RS256",
    "kid": "g4NXWvoX11IgmrmCRptyhQ",
    "typ": "at+jwt"
  }.{
    "nbf": 1613711876,
    "exp": 1613715476,
    "iss": "http://localhost:7200",
    "aud": "TestApi",
    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
    "sub": "123",
    "auth_time": 1613711876,
    "idp": "local",
    "role": "Admin",
    "eMail": "57265177_DataBaseUser@qq.com",
    "scope": [
      "TestApi"
    ],
    "amr": [
      "pwd"
    ]
  }.[Signature]
  ```

  

- 添加用户信息

  ```C#
   services.AddIdentityServer()
      //.AddTestUsers(PasswordInitConfig.GetUsers())
      .AddResourceOwnerValidator<CustomResourceOwnerPasswordValidator>();
      .AddProfileService<CustomProfileService>();
  
  services.AddTransient<IUserServiceTest, UserServiceTest>(); 
  ```

  获取的token为：

  ```C#
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTQzODEsImV4cCI6MTYxMzcxNzk4MSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIxMjMiLCJhdXRoX3RpbWUiOjE2MTM3MTQzODEsImlkcCI6ImxvY2FsIiwicm9sZSI6IkFkbWluIiwibmlja25hbWUiOiJFbGV2ZW4t5a2Y5YKo5LqO5pWw5o2u5bqTIiwiZU1haWwiOiI1NzI2NTE3N19EYXRhQmFzZVVzZXJAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsicHdkIl19.gSSphUkqbYV8Txli1bzyMVbgpgilM4Q2JG4jY4omBkZlW-PoY9F74nyHMPAzQRxN3j7HfFyJxj_l4CAbH0DTVojrUhKljbgWRQKEQfIOzO-8bjlikEFuAPx_KXWUR4yohcRlwWxsvFkRmSrag1zPgfAsEJewiH4FIBLQM9a8qen_saEWERLJZ-8Ae1mSVLqkuQg3JYXTN9zjpR_ZNnZ3rlcxnjx8Ger5w-CnDaXxkNoHMA_e8LlTJ1Yjk3AVWbmxO9ZIIG34a3Vi4RvT2n-Xp_EW_2NWp_0UYi1g58DbpvPMG3hq7CWvurIp-fI7FTRA4Ve423-9DEOBDFrWNu4WmA
  ```

  ```json
  {
    "alg": "RS256",
    "kid": "g4NXWvoX11IgmrmCRptyhQ",
    "typ": "at+jwt"
  }.{
    "nbf": 1613714381,
    "exp": 1613717981,
    "iss": "http://localhost:7200",
    "aud": "TestApi",
    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
    "sub": "123",
    "auth_time": 1613714381,
    "idp": "local",
    "role": "Admin",
    "nickname": "Eleven-存储于数据库",
    "eMail": "57265177_DataBaseUser@qq.com",
    "scope": [
      "TestApi"
    ],
    "amr": [
      "pwd"
    ]
  }.[Signature]
  ```

  多出以下信息：

  ```json
   "nickname": "Eleven-存储于数据库",
  ```



##### 自定义校验模式：IExtensionGrantValidator

前面5中授权模式：

          -  客户端模式、
          -  密码模式、
          -  授权码模式、
          -  隐藏模式、
          -  混合模式

都是IdentityServer4框架**内置**的授权模式。



**IdentityServer4框架我们可以支持自定义授权模式**，步骤如下：



- 自定义校验器，必须继承接口`IExtensionGrantValidator`：

```C#
    //
    // 摘要:
    //     Handles validation of token requests using custom grant types
    public interface IExtensionGrantValidator
    {
        //
        // 摘要:
        //     Returns the grant type this validator can deal with
        //
        // 值:
        //     The type of the grant.
        string GrantType { get; }

        //
        // 摘要:
        //     Validates the custom grant request.
        //
        // 参数:
        //   context:
        //     The context.
        //
        // 返回结果:
        //     A principal
        Task ValidateAsync(ExtensionGrantValidationContext context);
    }
```

这里我们自定义一个校验器`CustomElevenGrantValidator`:

```C#
    /// <summary>
    /// 扩展-类型-校验器
    /// </summary>
    public class CustomElevenGrantValidator : IExtensionGrantValidator
    {
        public string GrantType => "CustomEleven";

        private readonly IUserServiceTest _iUserServiceTest;

        public CustomElevenGrantValidator(IUserServiceTest userServiceTest)
        {
            this._iUserServiceTest = userServiceTest;
        }

        public Task ValidateAsync(ExtensionGrantValidationContext context)
        {
            var CE_name = context.Request.Raw.Get("CE_name");
            var CE_password = context.Request.Raw.Get("CE_password");
            Console.WriteLine($"This is CustomElevenGrantValidator CE_name={CE_name}--CE_password={CE_password}");

            if (string.IsNullOrEmpty(CE_name) || string.IsNullOrEmpty(CE_password))
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            var result = this._iUserServiceTest.Login(CE_name, CE_password);
            if (result == null)
            {
                context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant);
            }
            else
            {
                Console.WriteLine($"This is CustomElevenGrantValidator CE_name={CE_name}--CE_password={CE_password}");
                context.Result = new GrantValidationResult(
                             subject: result.UId.ToString(),
                             authenticationMethod: GrantType,
                             claims: result.Claims);
            }
            return Task.CompletedTask;
        }
    }
```

​     这里模拟从数据库查询是否存在给定的账号和密码在数据库中是否存在。

​     存在，校验通过，否则失败。



- 添加自定义校验器

  ```C#
              var connectionString = this.Configuration.GetConnectionString("DefaultConnection");
  
              services
                  .AddIdentityServer()
                  .AddDeveloperSigningCredential()
                  .AddConfigurationStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString);
                      };
                  })
                  .AddOperationalStore(options =>
                  {
                      options.ConfigureDbContext = builder =>
                      {
                          builder.UseSqlServer(connectionString);
                      };
                  })
                  .AddExtensionGrantValidator<CustomElevenGrantValidator>();
  
              services.InitSeedData(connectionString);//初始原来的那些内存数据
              services.AddTransient<IUserServiceTest, UserServiceTest>();
  ```

- 数据库添加GrantType

​       打开数据库表【ClientGrantTypes】，为客户端（ClientId=Zhaoxi.AspNetCore31.AuthDemo）添加名为

​      **CustomEleven**的GrantType类型

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613716944533.png" alt="1613716944533" style="zoom:80%;" />

  其值就是类`CustomElevenGrantValidator`定义的`GrantType`：

```C#
  public class CustomElevenGrantValidator : IExtensionGrantValidator
  {
      public string GrantType => "CustomEleven";
      //........ 
  }
```



> 特别注意: 
>
> 不要忘记这一步哦， 否则返回的结果是：
>
> ```json
> {
>     "error": "unsupported_grant_type"
> }
> ```
>
> 



- 启动项目【IdentityServer4】

  ```powershell
  dotnet Zhaoxi.AspNetCore31.AuthenticationCenterIds4.dll --urls="http://*:7200" --ip="127.0.0.1" --port= 7200
  ```

  

- PostMan测试

  在PostMan中建立请求：

  POST： http://localhost:7200/connect/token 

  form-data：

  ```json
  grant_type:CustomEleven
  client_id:Zhaoxi.AspNetCore31.AuthDemo
  client_secret:eleven123456
  scope:TestApi
  CE_name:Eleven
CE_password:123456
  ```

   其中：

  - **grant_type**的用于指定授权模式，这里我们取值为：**CustomEleven**，其值就是类`CustomElevenGrantValidator`定义的`GrantType`：
  
  ```C#
    public class CustomElevenGrantValidator : IExtensionGrantValidator
    {
        public string GrantType => "CustomEleven";
        //........   }
  ```
```
  
  - 自定义字段
  
    CE_name:Eleven
    CE_password:123456
  
    要与
  
    ```C#
    
            public Task ValidateAsync(ExtensionGrantValidationContext context)
            {
                var CE_name = context.Request.Raw.Get("CE_name");
                var CE_password = context.Request.Raw.Get("CE_password");
```

    一致。

  























  发送请求，

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613717158791.png" alt="1613717158791"  />

  得到token：

  ```md
  eyJhbGciOiJSUzI1NiIsImtpZCI6Imc0TlhXdm9YMTFJZ21ybUNScHR5aFEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2MTM3MTY5NjgsImV4cCI6MTYxMzcyMDU2OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo3MjAwIiwiYXVkIjoiVGVzdEFwaSIsImNsaWVudF9pZCI6IlpoYW94aS5Bc3BOZXRDb3JlMzEuQXV0aERlbW8iLCJzdWIiOiIxMjMiLCJhdXRoX3RpbWUiOjE2MTM3MTY5NjgsImlkcCI6ImxvY2FsIiwicm9sZSI6IkFkbWluIiwiZU1haWwiOiI1NzI2NTE3N19EYXRhQmFzZVVzZXJAcXEuY29tIiwic2NvcGUiOlsiVGVzdEFwaSJdLCJhbXIiOlsiQ3VzdG9tRWxldmVuIl19.BmFd7fuCNMzP9TPXCpMKF-lj0pFrYGf3QJ8uF7oDA_LZycb9f_D_ufcysnlFSnQuTzbC5OWI-qZ6iG75plWs1razDEqXSsCGvnUq58kEJwd5ag7-reH51LLU1lHOia-w1n9Ei7diTodP-d9_5xhxV69dgZ7lf5VxP7dBvj57PKzq3HOv3hFwYeRc98h_NH1O64q84O52NuId9RxqwAO9ulnrSXvtW2YGvvXcoO4_l30IA00X9pNBYRmBnFiEzwvhs-VNbW0w43-YNyYtbhLAX1gZXXKst8UmUV57a6aF-iJbqpTKTaHkkocpDSwd5EqFPHod1-P_kvwCGOgAznsVRw
  ```

  解析为：

  ```C#
  {
    "alg": "RS256",
    "kid": "g4NXWvoX11IgmrmCRptyhQ",
    "typ": "at+jwt"
  }.{
    "nbf": 1613716968,
    "exp": 1613720568,
    "iss": "http://localhost:7200",
    "aud": "TestApi",
    "client_id": "Zhaoxi.AspNetCore31.AuthDemo",
    "sub": "123",
    "auth_time": 1613716968,
    "idp": "local",
    "role": "Admin",
    "eMail": "57265177_DataBaseUser@qq.com",
    "scope": [
      "TestApi"
    ],
    "amr": [
      "CustomEleven"
    ]
  }.[Signature]
  ```

  得到token就可以访问授权页面（ http://localhost:5726/Ids4/Index ）了

  

  原理可参看：IdentityServer4 校验流程

  

#### IdentityServer4 校验流程

1、校验客户端Client_id和Client_Secret。
2、校验客户端是否有当前的授权方式。
3、校验是否有请求scope权限。
4、如果非客户端验证，校验账号密码或自定义规则是否正确。
5、非客户端验证，校验授权信息是否有效。



## 11 gRPC

[Course-42]：看到24:00，不看，有时间再看

参考资料：

https://www.jianshu.com/p/9c947d98e192



gRPC是什么可以用官网的一句话来概括

> A high-performance, open-source universal RPC framework

**所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。**如下图所示就是一个典型的RPC结构图。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613727087751.png" alt="1613727087751" style="zoom:80%;" />

#### gRPC有什么好处以及在什么场景下需要用gRPC

既然是server/client模型，那么我们直接用restful api不是也可以满足吗，为什么还需要RPC呢？下面我们就来看看RPC到底有哪些优势



##### gRPC vs. Restful API

gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下：

- gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。关于protobuf可以参见笔者之前的小文[Google Protobuf简明教程](https://www.jianshu.com/p/b723053a86a6) 
- 另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。
- gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）



##### 使用场景

- 需要对接口进行严格约束的情况，比如我们提供了一个公共的服务，很多人，甚至公司外部的人也可以访问这个服务，这时对于接口我们希望有更加严格的约束，我们不希望客户端给我们传递任意的数据，尤其是考虑到安全性的因素，我们通常需要对接口进行更加严格的约束。这时gRPC就可以通过protobuf来提供严格的接口约束。
- 对于性能有更高的要求时。有时我们的服务需要传递大量的数据，而又希望不影响我们的性能，这个时候也可以考虑gRPC服务，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。

但是，通常我们不会去单独使用gRPC，而是将gRPC作为一个部件进行使用，这是因为在生产环境，我们面对大并发的情况下，需要使用分布式系统来去处理，而gRPC并没有提供分布式系统相关的一些必要组件。而且，真正的线上服务还需要提供包括负载均衡，限流熔断，监控报警，服务注册和发现等等必要的组件。不过，这就不属于本篇文章讨论的主题了，我们还是先继续看下如何使用gRPC。



#### gRPC HelloWorld实例详解

gRPC的使用通常包括如下几个步骤：

1. 通过protobuf来定义接口和数据类型

   **Protobuf是什么**

   Protobuf实际是一套类似Json或者XML的数据传输格式和规范，用于不同应用或进程之间进行通信时使用。通信时所传递的信息是通过Protobuf定义的message数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。

   

2. 编写gRPC server端代码

3. 编写gRPC client端代码
   
   

## 12 Redis

**大数据高并发之Redis**：

- Redis究竟是什么
- Redis能解决什么问题
- 八大数据结构原理与应用
- Redis中的事务
- Redis的持久化（AOF/RDB）
- 集群+主从复制+分片+实现高可用



[Courese-44]

#### NoSql



#### 什么是Redis

Redis ,全称：Remote DIctionary Server 远程字典的服务
内存数据库
1、方便扩展

​     不需要提前去有规范的字段，只要是数据都可以往里面存



2、大数据量高性能
3、八大结构
4 、分布式存储



#### 八大结构

- String
- Hash
- List
- Set
- ZSet
- BitMaps
- HyperLogLoss
- Streams



#### 单线程 VS 多线程

1.单线程不一定要比多线程性能高  

2.单线程的原子性操作

  不需要锁+不需要上下文文的切换,就是一个任务一个人做 

3.一个任务有好多个人去做，肯定有一个去指导这些人去合理安排的做事 

多线程要实现原子性，涉及到各种锁，上下文的切换性能的消耗 

4.单线程多进程 

   我们可以根据我们的服务，开启多个实例 

   其实在我们业务中经常去这么使用的， 



#### I/O多路复用

**io多路复用**: 

​    打个单子，然后把单子给后厨 ，然后让你稍等，菜做完了喊你，你来拿 

**异步**:

​    打个单子，让你留下自己地址，然后把单子给后厨，菜做完了，直接送到你家去了



**redis单线程不代表整个redis服务中只有一个线程**



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613735839756.png" alt="1613735839756" style="zoom:80%;" />

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

###### Select

**fd**指的是文件的描述（句柄）

​     fd1存放了客户端信息 

**内核**指的是：操作系统的内核



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613736274350.png" alt="1613736274350" style="zoom:80%;" />

###### Poll









###### Epoll

EPoll解决Select轮询的问题，加了两个回调函数

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613736915842.png" alt="1613736915842" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613737110039.png" alt="1613737110039" style="zoom:80%;" />

只轮询活跃的事件队列



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613737156011.png" alt="1613737156011" style="zoom:80%;" />



LT--轮询，

ET--只监听活跃队列

65535-端口号的最大限度





<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613737412707.png" alt="1613737412707" style="zoom:80%;" />

#### Reids环境

redis官网：https://redis.io/

redis中文官网：http://www.redis.cn/



VS2019+.NETCore 控制台
Redis4.0+
redis客户端：ServiceStack.Redis +改源代码限制



##### **Redis下载**

Windows：https://github.com/tporadowski/redis/releases

Linux：http://redis.io/download



##### Redis安装资料

参考资料：

- https://www.runoob.com/redis/redis-install.html

- 生产环境安装：

  https://blog.csdn.net/yangwenxue1989/article/details/88884668?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase

  

##### **安装**

​         这里我们下载:`Redis 4.0.14.2 for Windows.msi`, 安装后是Redis变成windows服务

端口是6379；

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613739580822.png" alt="1613739580822" style="zoom:80%;" />

看到使用的配置文件是`C:\Program Files\Redis\redis.windows-service.conf`



###### 测试下是否安装成功

打开CMD

```powershell
#链接Redis
redis-cli.exe

#插入数据
set mykey hi
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613741711653.png" alt="1613741711653" style="zoom:67%;" />





###### 设置密码

打开配置文件`redis.windows-service.conf`

```tex
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it will be very easy to break.
#
# requirepass foobared

```

把`# requirepass foobared`注释去掉

```text
requirepass 123456 
```

这里把密码设置：**123456**

> 特别注意，requirepass前不能有空格



然后重启Redis的windows服务即可。

接着尝试链接Redis，并查询，提示：没有权限请求，说明设置密码生效了

```C#
C:\Program Files\Redis>redis-cli.exe
127.0.0.1:6379> get myKey
(error) NOAUTH Authentication required.
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613742728688.png" alt="1613742728688" style="zoom: 60%;" />



输入如下命令获取连接帮助

```powershell
C:\Program Files\Redis>redis-cli.exe --help

redis-cli 4.0.14.2 (git:017dc989)

Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]
  -h <hostname>      Server hostname (default: 127.0.0.1).
  -p <port>          Server port (default: 6379).
  -s <socket>        Server socket (overrides hostname and port).
  -a <password>      Password to use when connecting to the server.
 
  
// .......
```

我们输入如下连接命名：

```powershell
C:\Program Files\Redis>redis-cli.exe -h 127.0.0.1 -p 6379 -a 123456

127.0.0.1:6379> set k 123456
OK
```



#### Redis管理工具

- RedisDesktopManager

  

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613739988891.png" alt="1613739988891" style="zoom:67%;" />

  如果Redis设置了密码就在**验证**一栏输入密码



​     <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613740019523.png" alt="1613740019523" style="zoom:67%;" />



添加数据

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613740313266.png" alt="1613740313266" style="zoom:67%;" />



##### Key

​      当插入Key用冒号隔开：，管理工具会指自动分级分目录。

比如插入Key为：`MyCompnay:Project01:Shoping:Key1`，值为：hello world

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613819595634.png" alt="1613819595634" style="zoom:80%;" />



#### Redis客户端

C#客户端:https://redis.io/clients#c-sharp

 推荐两个：

- ServiceStack.Redis ，但是这个有限制，每小时请求的次数不能超过6000次等限制

  https://github.com/ServiceStack/ServiceStack.Redis

  不支持集群链接

  

- StackExchange.Redis 

  链接次数无限制，支持集群链接

​      

#### Redis基础





#### ServiceStack.Redis

##### 连接

```C#
using (RedisClient client = new RedisClient("127.0.0.1", 6379, "123456"))
{
    client.Set<string>("name", "我是个字符串");
    Console.WriteLine(client.Get<string>("name"));
}
```



##### 清空

```C#
    //删除当前数据库中的所有Key  默认删除的是select 0
    client.FlushDb();
    //删除所有数据库中的key 
    client.FlushAll();
```



##### String

###### 设置Key的值

```C#
client.Set<string>("name", "我是个字符串");
Console.WriteLine("错误输出");
Console.WriteLine(client.GetValue("name")); //带双引号

Console.WriteLine("正确输出");
Console.WriteLine(client.Get<string>("name"));
Console.WriteLine(JsonConvert.DeserializeObject<string>(client.GetValue("name")));
```



###### 批量设置

```C#
//批量的写入redis key
client.SetAll(new Dictionary<string, string> { { "id", "001" }, { "name", "clay" } });
//批量读取内存中多个key的结果 如果我们获取的key不存在，程序会返回一个空的字符串
var getall = client.GetAll<string>(new string[] { "id", "name", "number" });
foreach (var item in getall)
{
    Console.WriteLine(item);
}
```



###### 设置key的value并设置过期时间

```C#
client.Set<string>("name", "我是个字符串", TimeSpan.FromSeconds(1));
Task.Delay(1 * 1000).Wait();
Console.WriteLine($"name:{client.Get<string>("name")}");
```



###### 在原有key的value值之后追加value

```C#
client.AppendToValue("name", "I");
client.AppendToValue("name", " ");
client.AppendToValue("name", "LOVE YOU");
Console.WriteLine(client.Get<string>("name"));
```



###### 获取旧值赋上新值

```C#
client.Set("name", "我是个字符串");
//获取当前key的之前的值，然后把新的结果替换进入
var value = client.GetAndSetValue("name", "clay");
Console.WriteLine("原先的值" + value);
Console.WriteLine("新值" + client.GetValue("name"));
```



###### 自增1，返回自增后的值

```c#
// Redis中插入一个键值对,且最终结果是：{key:sid, value:1}
Console.WriteLine(client.Incr("sid")); 

Console.WriteLine(client.Incr("sid"));
Console.WriteLine(client.Incr("sid")); //{key:sid, value:3}
Console.WriteLine("华丽丽的结束");
Console.WriteLine(client.GetValue("sid")); //5

//每次通过传递的count累计，count就是累加的值
client.IncrBy("sid", 2); //+3=5
Console.WriteLine(client.Get<string>("sid")); //5
client.IncrBy("sid", 100);//+100 = 105
Console.WriteLine("最后的结果***" + client.GetValue("sid")); //105

```



###### 自减1，返回自减后的值

```C#
Console.WriteLine(client.Decr("sid")); //-1
Console.WriteLine(client.Decr("sid")); //-2
Console.WriteLine(client.Decr("sid")); //-3 
Console.WriteLine("最后的结果" + client.GetValue("sid")); //-3
//通过传入的count去做减肥 之前的结果-count
client.DecrBy("sid", 2); // -5
Console.WriteLine("最终的结果" + client.GetValue("sid"));//-5
```



###### add 和 set 的区别

当使用add 方法去操作redis的时候，如果key存在的话，则不会再次进行操作 返回false 如果操作成功返回true,

用add的时候帮你去判断如果有则不进行操作，如果没有则写，它只能写新值，不能修改

```C#
//当使用add 方法去操作redis的时候，如果key存在的话，则不会再次进行操作 返回false 如果操作成功返回true
Console.WriteLine(client.Add("name", "clay")); //True
//用add的时候帮你去判断如果有则不进行操作，如果没有则写，它只能写新值，不能修改
Console.WriteLine(client.Add("name", "你很好clay")); //False
Console.WriteLine(client.Get<string>("name")); //clay
```



使用set去操作 redis的时候，如果key不存在则写入当前值，并且返回true，通过存在，则对之前的值进行了一个替换 返回操作的结果

```C#
//使用set去操作 redis的时候，如果key不存在则写入当前值，并且返回true，通过存在，则对之前的值进行了一个替换 返回操作的结果
Console.WriteLine(client.Set("name", "clay")); //True
Console.WriteLine(client.Set("name", "你很好clay")); //True
Console.WriteLine(client.Get<string>("name")); //你很好clay
```



###### 示例 : 秒杀

- 订单数 +1
- 库存数 -1

出现的问题是：可能超卖

如果使用多线程，把整个流程打包成原子性+锁

加锁让多线程变成单线程


每个服务器执行一次`Seckill.Show`，这样每个服务器开启10个线程用于模拟10个客户，

```C#
/// <summary>
/// 秒杀
/// </summary>
public class Seckill
{
    public static void Show(string id, int minute)
    {
        #region 自减1，返回自减后的值
            //开启10个线程去抢购
        Console.WriteLine($"在{minute}分0秒正式开启秒杀！");
        var flag = true;
        while (flag)
        {
            if (DateTime.Now.Minute == minute)
            {
                Console.WriteLine("秒杀开始-----------");
                flag = false;
                for (int i = 0; i < 10; i++)
                {
                    string name = $"客户端{id}，{i}号用户：";
                    Task.Run(() =>
                     {
                        using (RedisClient client = new RedisClient("127.0.0.1", 6379,"123456"))
                        {

                            //本来是二步走
                            //1 订单+1
                            //2 库存-1 //同一个时间片。只会执行一条指令
                            var num = client.Decr("number");
                            if (num < 0)
                            {
                                Console.WriteLine(name + "抢购失败");
                            }
                            //>=0
                            else
                            {
                                Console.WriteLine(name + "**抢购成功**");
                             }
                         }
                    });
                    Thread.Sleep(10);
                }
            }
            Thread.Sleep(10);
        }
        Console.WriteLine("秒杀结束-----------");
        Console.ReadLine();
        #endregion
    }
}
```

```C#
////命令行参数启动
//服务器1：dotnet RedisSeckill.dll --id=1 minute=18
//服务器2：dotnet RedisSeckill.dll --id=2 minute=18
//服务器3：dotnet RedisSeckill.dll --id=3 minute=18

var builder = new ConfigurationBuilder().AddCommandLine(args);
var configuration = builder.Build();
string id = configuration["id"];
int minute = int.Parse(configuration["minute"]);
Console.WriteLine("开始" + id);

using (RedisClient client = new RedisClient("127.0.0.1", 6379,"123456"))
{
    //首先给数据库预支了秒杀商品的数量
    client.Set<int>("number", 10);
}
Seckill.Show(id, minute);
```



命令行参数启动开启三个客户端，模拟三个服务器,  

```powershell
dotnet RedisSeckill.dll --id=1 minute=18
dotnet RedisSeckill.dll --id=2 minute=18
dotnet RedisSeckill.dll --id=3 minute=18
```



运行结果：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613818899996.png" alt="1613818899996" style="zoom:80%;" />

一共有10个商品，不会发生超卖。



##### HashTable

​        用Redis的`String`结构存储一个对象，步骤是，先把对象序列化成Json，查询时反序列化。

这时，有个需求，只是修改这个对象的一个字段，如果用`String`结构存储，就得把整个对象，序列化和反序列化。

hashtable的数据结构

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613872593932.png" alt="1613872593932"  />



###### 向hashid集合中添加key/value

```C#
//大key
string hashid = "HashKey";	

client.SetEntryInHash(hashid, "id", "001");
Console.WriteLine(client.GetValuesFromHash(hashid, "id").FirstOrDefault());
client.SetEntryInHash(hashid, "name", "clay");
Console.WriteLine(client.GetValuesFromHash(hashid, "name").FirstOrDefault());
client.SetEntryInHash(hashid, "socre", "100");
Console.WriteLine(client.GetValuesFromHash(hashid, "socre").FirstOrDefault());
```



###### 批量新增key的值

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
client.SetRangeInHash(hashid, pairs);
//获取当前key的值
Console.WriteLine(client.GetValueFromHash(hashid, "id"));
Console.WriteLine(client.GetValueFromHash(hashid, "name"));
//一次性的获取所有想要获取的小key（属性的）值  如果key不存在，则返回空，不抛出异常
var list = client.GetValuesFromHash(hashid, "id", "name", "abc");
Console.WriteLine("*********");
foreach (var item in list)
{
    Console.WriteLine(item);
}
```



###### 无则加，有则Flase

如果不存在在添加key/value,返回true

如果hashid集合中存在key/value则不添加返回false，

```C#

Console.WriteLine(client.SetEntryInHashIfNotExists(hashid, "name", "你好美"));  //True
Console.WriteLine(client.SetEntryInHashIfNotExists(hashid, "name", "你好美 哈哈哈")); //Flase
Console.WriteLine(client.GetValuesFromHash(hashid, "name").FirstOrDefault()); //你好      
```



###### 存储对象T t 到hash集合中

```C#
//urn: 类名: id的值
client.StoreAsHash<UserInfo>(new UserInfo() { Id = 2, Name = "clay", number = 0 });
//如果id存在的话，则覆盖之前相同的id 他帮助我们序列化或者反射了一些事儿
client.StoreAsHash<UserInfo>(new UserInfo() { Id = 2, Name = "clay2" });
//获取对象T中ID为id的数据。 必须要有属性id，不区分大小写
Console.WriteLine(client.GetFromHash<UserInfo>(1).Name); //clay2

//不存在时，创建一个各个字段都是默认值的对象
var olduserinfo = client.GetFromHash<UserInfo>(1); //1好像是第一列
olduserinfo.number = 4;
client.StoreAsHash<UserInfo>(olduserinfo);
Console.WriteLine("最后的结果" + client.GetFromHash<UserInfo>(1).number);


client.StoreAsHash<UserInfoTwo>(new UserInfoTwo() { Id = "001", Name = "clay2" });
Console.WriteLine(client.GetFromHash<UserInfoTwo>("001").Name);
client.StoreAsHash<UserInfoTwo>(new UserInfoTwo() { Id = "002", Name = "clay" });
Console.WriteLine(client.GetFromHash<UserInfoTwo>("002").Name);


UserInfo lisi = new UserInfo() { Id = 1, Name = "李四", number = 0 };
client.StoreAsHash<UserInfo>(lisi);
Console.WriteLine(client.GetFromHash<UserInfo>(1).number);
//做个自增
var oldzhang = client.GetFromHash<UserInfo>(1);
oldzhang.number++;
client.StoreAsHash<UserInfo>(oldzhang);
Console.WriteLine(client.GetFromHash<UserInfo>(1).number);
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613872450269.png" alt="1613872450269" style="zoom:80%;" />

![1613836452259](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613836452259.png)

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613836511677.png" alt="1613836511677" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613836533889.png" alt="1613836533889" />

![1613836554552](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613836554552.png)

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613836572912.png" alt="1613836572912" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613836601063.png" alt="1613836601063" style="zoom:80%;" />



###### 获取所有hashid数据集的key/value数据集合

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
client.SetRangeInHash(hashid, pairs);
var dics = client.GetAllEntriesFromHash(hashid);
foreach (var item in dics)
{
    Console.WriteLine(item.Key + ":" + item.Value);
}
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613836838803.png" alt="1613836838803" style="zoom:80%;" />



###### 获取hashid数据集中的数据总数

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
client.SetRangeInHash(hashid, pairs);
//你们自己做到心中有数
Console.WriteLine(client.GetHashCount(hashid)); //2
```



######  获取hashid数据集中所有key的集合

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
client.SetRangeInHash(hashid, pairs);
var keys = client.GetHashKeys(hashid);
foreach (var item in keys)
{
    Console.WriteLine(item);//id/name
}
```



###### 获取hashid数据集中的所有value集合

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
client.SetRangeInHash(hashid, pairs);
var values = client.GetHashValues(hashid);
foreach (var item in values)
{
    Console.WriteLine(item); //001/clay
}
```



###### 删除hashid数据集中的key数据

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
client.SetRangeInHash(hashid, pairs);

client.RemoveEntryFromHash(hashid, "id");

var values = client.GetHashValues(hashid);
foreach (var item in values)
{
    Console.WriteLine(item); //clay
}
```



###### 判断hashid数据集中是否存在key的数据

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
client.SetRangeInHash(hashid, pairs);
Console.WriteLine(client.HashContainsEntry(hashid, "id"));    //True  
Console.WriteLine(client.HashContainsEntry(hashid, "number"));// Flase
```



###### 给hashid数据集key的value加countby，返回相加后的数据

```C#
Dictionary<string, string> pairs = new Dictionary<string, string>();
pairs.Add("id", "001");
pairs.Add("name", "clay");
pairs.Add("number", "2");
client.SetRangeInHash(hashid, pairs);
Console.WriteLine(client.IncrementValueInHash(hashid, "number", 2));//4
```

  注意，存的值必须是数字类型，否则抛出异常



###### 自定义

```C#
public static class HashTool
	{
		public static void StoreAsHash<T>(T model) where T : class, new()
		{
			//获取当前类型的所有字段
			Type type = model.GetType();
			var fields = type.GetProperties();
			// urn: 类名: id的值
			var hashid = type.FullName;
			Dictionary<string, string> pairs = new Dictionary<string, string>();
			var IdValue = string.Empty;
			for (int i = 0; i < fields.Length; i++)
			{
				if (fields[i].Name.ToLower() == "id")
				{
					//如果你真的把两个相同的id的对象存进去，我可能只改其中一个
					//不可能，如果有两个相同的id的对象存进去，则后面的会把前面的替换掉
					IdValue = fields[i].GetValue(model).ToString();
				}
				else
				{
					// 获取字段的值
					pairs.Add(fields[i].Name, fields[i].GetValue(model).ToString());
				}

			}
			if (IdValue == string.Empty)
			{
				IdValue = DateTime.Now.ToString("yyyyMMdd");
			}
			RedisClient client = new RedisClient("127.0.0.1");
			client.SetRangeInHash(hashid + IdValue, pairs);
		}

		public static T GetFromHash<T>(object id) where T : class, new()
		{
			//获取当前类型的所有字段
			Type type = typeof(T);
			// urn: 类名: id的值
			var hashid = type.FullName;
			RedisClient client = new RedisClient("127.0.0.1");
			var dics = client.GetAllEntriesFromHash(hashid + id.ToString());
			if (dics.Count == 0)
			{
				return new T();
			}
			else
			{
				var model = Activator.CreateInstance(type);
				var fields = type.GetProperties();
				foreach (var item in fields)
				{
					if (item.Name.ToLower() == "id")
					{
						item.SetValue(model, id);
					}
					if (dics.ContainsKey(item.Name))
					{
						item.SetValue(model, dics[item.Name]);
					}
				}
				return (T)model;
			}


		}
	}
```

测试：

```C#
HashTool.StoreAsHash<UserInfoTwo>(new UserInfoTwo() { Id = "10001", Name = "clay" });
var user = HashTool.GetFromHash<UserInfoTwo>("10001");

```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613838043915.png" alt="1613838043915" style="zoom:80%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613838094932.png" alt="1613838094932" style="zoom:67%;" />



##### Set

Set 不重复并自动去重的集合



###### Set的数据结构

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613873854752.png" alt="1613873854752" style="zoom:100%;" />



###### 添加键值

```C#
string key = "set_key";

var litaibai = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613838475439.png" alt="1613838475439" style="zoom:80%;" />

添加4次，只插入一条数据，

说明方法`AddItemToSet()`带有自动去重功能，去重的依据是**所有字段都相同**，

```C#
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
litaibai.Name = "李太白2";
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
client.AddItemToSet(key, JsonConvert.SerializeObject(litaibai));
```

改了字段`Name`,会插入两条数据：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613839172733.png" alt="1613839172733" style="zoom:80%;" />



`AddItemToList()`,不会去重，会插入两条一模一样的数据

```C#
var litaibai = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToList(key, JsonConvert.SerializeObject(litaibai));
client.AddItemToList(key, JsonConvert.SerializeObject(litaibai));
```



###### 随机获取key集合中的一个值，获取当前setid中的所有值

```C#
//批量的去操作set 集合
Console.WriteLine("set 开始了");
client.AddRangeToSet(key, new List<string>() { "001", "001", "002", "003", "003", "004" });
////当前setid中的值数量
Console.WriteLine(client.GetSetCount(key)); //4(001,003去重)
//随机获取key集合中的一个值
Console.WriteLine(client.GetRandomItemFromSet(key));
//获取当前setid中的所有值
var lists = client.GetAllItemsFromSet(key); 
Console.WriteLine("展示所有的值");
foreach (var item in lists)
{
    Console.WriteLine(item); //002,004,003,001
}
```



###### 随机删除key集合中的一个值

```C#
client.AddRangeToSet(key, new List<string>() { "001", "001", "002" });
////随机删除key集合中的一个值
Console.WriteLine("随机删除的值" + client.PopItemFromSet(key));
var lists = client.GetAllItemsFromSet(key);
Console.WriteLine("展示删除之后所有的值");
foreach (var item in lists)
{
    Console.WriteLine(item);
}
```

输出

```powershell
随机删除的值002
展示删除之后所有的值
001
```



###### 根据小key 删除

```C#
client.AddRangeToSet(key, new List<string>() { "001", "001", "002" });
client.RemoveItemFromSet(key, "001");
var lists = client.GetAllItemsFromSet(key);
Console.WriteLine("展示删除之后所有的值");
foreach (var item in lists)
{
    Console.WriteLine(item); //002
}
```



###### 从fromkey集合中移除值为value的值，并把value添加到tokey集合中

```C#
client.AddRangeToSet("fromkey", new List<string>() { "003", "001", "002", "004" });
client.AddRangeToSet("tokey", new List<string>() { "001", "002" });
//从fromkey 中把元素004 剪切到tokey 集合中去
client.MoveBetweenSets("fromkey", "tokey", "004");
Console.WriteLine("fromkey data ~~~~~~");
foreach (var item in client.GetAllItemsFromSet("fromkey"))
{
    Console.WriteLine(item); //002,001,003
}

Console.WriteLine("tokey data ~~~~~~");
foreach (var item in client.GetAllItemsFromSet("tokey"))
{
    Console.WriteLine(item); //004,001,002
}
```



###### 并集  把两个集合合并起来，然后去重

```C#
client.AddRangeToSet("keyone", new List<string>() { "001", "002", "003", "004" });
client.AddRangeToSet("keytwo", new List<string>() { "001", "002", "005" });
var unionlist = client.GetUnionFromSets("keyone", "keytwo");
Console.WriteLine("返回并集结果");
foreach (var item in unionlist)
{
    Console.WriteLine(item);//001,002,003,004,005
}
//把 keyone 和keytwo 并集结果存放到newkey 集合中
client.StoreUnionFromSets("newkey", "keyone", "keytwo");
Console.WriteLine("返回并集结果的新集合数据");
foreach (var item in client.GetAllItemsFromSet("newkey"))
{
    Console.WriteLine(item);
}
```

两个方法都是合并，区别是

- `GetUnionFromSets()`只是返回结果，没有存储结果集，
- `client.StoreUnionFromSets("newkey", "keyone", "keytwo");`以`newkey`为`key`存储结果集



输出：

```C#
*****************Set ZSet****************
返回并集结果
001
005
002
004
003
返回并集结果的新集合数据
001
005
002
004
003
```



###### 交集 获取两个集合中共同存在的元素

```C#
client.AddRangeToSet("keyone", new List<string>() { "001", "002", "003", "004" });
client.AddRangeToSet("keytwo", new List<string>() { "001", "002", "005" });
var Intersectlist = client.GetIntersectFromSets("keyone", "keytwo");
Console.WriteLine("交集的结果");
foreach (var item in Intersectlist)
{
    Console.WriteLine(item); //001, 002
}
//把 keyone 和keytwo 交集结果存放到newkey 集合中
client.StoreIntersectFromSets("newkey", "keyone", "keytwo"); //生成新的集合
Console.WriteLine("返回交集结果的新集合数据");
foreach (var item in client.GetAllItemsFromSet("newkey"))
{
    Console.WriteLine(item); //001, 002
}
```



##### Zet(Sorted Set)

- 以Zet类型存储

- 它是一个有序的，去重的集合
- 排序是根据`score`字段排序

```C#
string zsett_key = "zset_key";
//添加一个kye
client.AddItemToSortedSet(zsett_key, "cc", 33); //cc是值，33是排序号
client.AddItemToSortedSet(zsett_key, "cc", 45); //cc是值，45是排序号，根据值'cc'去重，排序号被覆盖为45
Console.WriteLine("ok");
//获取当前value的的下标
Console.WriteLine(client.GetItemIndexInSortedSet(zsett_key, "cc")); //0


//批量操作多个key ，给多个key 赋值1
client.AddRangeToSortedSet(zsett_key, new List<string>() { "a", "b" }, 1);

foreach (var item in client.GetAllItemsFromSortedSet(zsett_key))
{
    Console.WriteLine(item); //a,bcc
}
client.AddItemToSortedSet("蜀国", "刘备", 5);
client.AddItemToSortedSet("蜀国", "关羽", 2);
client.AddItemToSortedSet("蜀国", "张飞", 3);
client.AddItemToSortedSet("魏国", "刘备", 5);
client.AddItemToSortedSet("魏国", "关羽", 2);
client.AddItemToSortedSet("蜀国", "张飞", 3);
//获取 key为蜀国的下标 0，到2 并且排序
IDictionary<String, double> Dic = client.GetRangeWithScoresFromSortedSet("蜀国", 0, 2);
foreach (var r in Dic)
{
    Console.WriteLine(r.Key + ":" + r.Value); //排序获取，输出顺序为：关羽:2, 张飞:3, 刘备:5
}
```



##### List

######  顺序添加

```C#
string listid = "list_key";

var caocao = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToList(listid, JsonConvert.SerializeObject(caocao));
var jiaxu = new UserInfo() { Id = 2, Name = "贾诩" };
client.AddItemToList(listid, JsonConvert.SerializeObject(jiaxu));
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613879733852.png" alt="1613879733852" style="zoom:80%;" />



###### 追加

```C#
var liubei = new UserInfo() { Id = 1, Name = "刘备" };
client.PushItemToList(listid, JsonConvert.SerializeObject(liubei));
```



###### 添加值，并设置过期时间

```C#
var caocao = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToList(listid, JsonConvert.SerializeObject(caocao));
var liubei = new UserInfo() { Id = 2, Name = "刘备" };
client.PushItemToList(listid, JsonConvert.SerializeObject(liubei));
//只在内存中存储一秒
client.ExpireEntryAt(listid, DateTime.Now.AddSeconds(1));//整个队列 只活了1秒
Console.WriteLine(client.GetListCount(listid)); //2
Task.Delay(1 * 1000).Wait();
Console.WriteLine("1秒之后");
Console.WriteLine(client.GetListCount(listid)); //0
//雪崩 问题：瞬间大量的数据消失 -》大量的数据不要一下的全部消失
```



###### 在前添加值（插队），并设置过期时间 

```C#
var caocao = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToList(listid, JsonConvert.SerializeObject(caocao));
var jiaxu = new UserInfo() { Id = 2, Name = "贾诩" };
client.AddItemToList(listid, JsonConvert.SerializeObject(jiaxu));
var gaunyu = new UserInfo() { Id = 3, Name = "关羽" };
//向右追加就是插队
client.PrependItemToList(listid, JsonConvert.SerializeObject(gaunyu)); //关羽插队
Console.WriteLine("ok");
var caomegndeng = new UserInfo() { Id = 3, Name = "曹孟德" };
client.PrependItemToList(listid, JsonConvert.SerializeObject(caomegndeng)); //曹孟德 插队
Console.WriteLine(client.GetListCount(listid)); //4(人)

client.ExpireEntryAt(listid, DateTime.Now.AddSeconds(1)); //整个队列 只活了1秒
Task.Delay(1 * 1000).Wait();
Console.WriteLine("1秒之后");
Console.WriteLine(client.GetListCount(listid)); //0（人）
```



###### 为key添加多个值(批量添加)

```C#
client.AddRangeToList(listid, new List<string>() { "001", "002", "003", "004" });
//批量去读取list中的元素
var lists = client.GetAllItemsFromList(listid);
foreach (var item in lists)
{
    Console.WriteLine(item);
}
```



###### 获取key中下标为star到end的值集合

```C#
client.AddRangeToList(listid, new List<string>() { "001", "002", "003", "004" });
var lists = client.GetRangeFromList(listid, 0, 1);//从下标0到1的值
foreach (var item in lists)
{
    Console.WriteLine(item); // 001,002
}
```



###### 集合操作

- 移除最后一项

```C#
var caocao = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToList(listid, JsonConvert.SerializeObject(caocao));
var jiaxu = new UserInfo() { Id = 2, Name = "贾诩" };
client.AddItemToList(listid, JsonConvert.SerializeObject(jiaxu));
var gaunyu = new UserInfo() { Id = 3, Name = "关羽" };
client.AddItemToList(listid, JsonConvert.SerializeObject(gaunyu));

//移除尾部 并返回移除的数据
Console.WriteLine(client.RemoveEndFromList(listid)); //移除最后一项（Id=3的关羽）;
foreach (var item in client.GetAllItemsFromList(listid))
{
    Console.WriteLine(JsonConvert.DeserializeObject<UserInfo>(item).Name); //李太白,贾诩
}
```



- 移除头部并返回移除的数据

```C#
var caocao = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToList(listid, JsonConvert.SerializeObject(caocao));
var jiaxu = new UserInfo() { Id = 2, Name = "贾诩" };
client.AddItemToList(listid, JsonConvert.SerializeObject(jiaxu));
var gaunyu = new UserInfo() { Id = 3, Name = "关羽" };
client.AddItemToList(listid, JsonConvert.SerializeObject(gaunyu));

client.RemoveStartFromList(listid); //移除 头部，（Id=1 的李太白）
foreach (var item in client.GetAllItemsFromList(listid))
{
    Console.WriteLine(JsonConvert.DeserializeObject<UserInfo>(item).Name); //贾诩,关羽
}
```



- 从一个list的尾部移除一个数据，添加到另外一个list的头部，并返回移动的值

```C#
var caocao = new UserInfo() { Id = 1, Name = "李太白" };
client.AddItemToList(listid, JsonConvert.SerializeObject(caocao));
var jiaxu = new UserInfo() { Id = 2, Name = "贾诩" };
client.AddItemToList(listid, JsonConvert.SerializeObject(jiaxu));
var gaunyu = new UserInfo() { Id = 3, Name = "关羽" };
client.AddItemToList(listid, JsonConvert.SerializeObject(gaunyu));
Console.WriteLine(client.PopAndPushItemBetweenLists(listid, "newlist"));//输出：{"Id":3,"Name":"关羽","number":0}

Console.WriteLine("移动之后新队列的元素结果");
Console.WriteLine(client.GetItemFromList("newlist", 0)); //输出：{"Id":3,"Name":"关羽","number":0}

```



- 根据下标获取想要的集合元素，不做移除操作，并修改当前下标的结果

  ```C#
  var caocao = new UserInfo() { Id = 1, Name = "李太白" };
  client.AddItemToList(listid, JsonConvert.SerializeObject(caocao));
  var jiaxu = new UserInfo() { Id = 2, Name = "贾诩" };
  client.AddItemToList(listid, JsonConvert.SerializeObject(jiaxu));
  var gaunyu = new UserInfo() { Id = 3, Name = "关羽" };
  client.AddItemToList(listid, JsonConvert.SerializeObject(gaunyu)); 
  
  ////根据下标获取想要的集合元素，不做移除操作
  var userstr = client.GetItemFromList(listid, 0);
  Console.WriteLine(JsonConvert.DeserializeObject<UserInfo>(userstr).Name);
  //修改当前下标的结果
  client.SetItemInList(listid, 0, "new value");
  ```

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613881496662.png" alt="1613881496662" style="zoom:80%;" />



#### 发布和订阅

参考资料：

https://www.runoob.com/redis/redis-pub-sub.html

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613882647412.png" alt="1613882647412" style="zoom:80%;" />

##### 发布者

Program.cs

```C#
class Program
{
    static void Main(string[] args)
    {
        try
        {
            //创建一个公众号--创建一个主题
            Console.WriteLine("发布服务");
	        IRedisClientsManager redisClientManager = new 				
            string channelName = "Send_Log";//频道名

				//发布服务器
			RedisPubSubServer pubSubServer = new RedisPubSubServer(redisClientManager, channelName)
            {
                OnMessage = (channel, msg) =>
                {
                    Console.WriteLine($"从频道：{channel}上接受到消息：{msg},时间：{DateTime.Now.ToString("yyyyMMdd HH:mm:ss")}");
                    Console.WriteLine("_______________");
                },
                OnStart = () =>
                {
                    Console.WriteLine("发布服务已启动");
                    Console.WriteLine("________________");
                },
                OnStop = () => { Console.WriteLine("发布服务停止"); },
                OnUnSubscribe = channel => { Console.WriteLine(channel); },
                OnError = e => { Console.WriteLine(e.Message); },
                OnFailover = s => { Console.WriteLine(s); },
            };
            //接收消息
            pubSubServer.Start();
            while (true)
            {
                Console.WriteLine("请输入记录的日志");
                string message = Console.ReadLine();
                redisClientManager.GetClient().PublishMessage(topicname, message);
            }
        }
        catch (Exception ex)
        {

            Console.WriteLine(ex.Message);
        }


    }
}
```

其中，

```C#
IRedisClientsManager redisClientManager = new PooledRedisClientManager("123456@127.0.0.1:6379");

string channelName = "Send_Log";//频道名

//发布服务器
RedisPubSubServer pubSubServer = new RedisPubSubServer(redisClientManager, channelName)
```

以连接字符串`"123456@127.0.0.1:6379"`,**(格式为：密码@IP:Prot)**创建Redis客户端管理器，

用客户端管理器和一个频道名（`Send_Log`）创建发布服务器，



##### 消费者

`Program.c`

```C#
static void Main(string[] args)
{
    try
    {
        //消费者
        using (RedisClient consumer = new RedisClient("127.0.0.1", 6379,"123456"))
        {
            Console.WriteLine($"创建订阅异常信息数据库记录");
            var subscription = consumer.CreateSubscription();
            //接受到消息时
            subscription.OnMessage = (channel, msg) =>
            {
                if (msg != "CTRL:PULSE")
                {
                    Console.WriteLine($"从频道：{channel}上接受到消息：{msg},时间：{DateTime.Now.ToString("yyyyMMdd HH:mm:sss")}");
                    
                    Logger.WriteLogByDB(msg);
                    
                    Console.WriteLine("_____记录成功______");
                }
            };
            
            //订阅频道时
            subscription.OnSubscribe = (channel) =>
            {
                Console.WriteLine("订阅客户端：开始订阅" + channel);
            };
            //取消订阅频道时
            subscription.OnUnSubscribe = (a) => { Console.WriteLine("订阅客户端：取消订阅"); };

            //订阅频道
            string channelName = "Send_Log";
            subscription.SubscribeToChannels(channelName);
        }
    }
    catch (Exception ex)
    {

        Console.WriteLine(ex.Message);
    }

}
```

其中，

创建订阅器

```C#
var subscription = consumer.CreateSubscription();
```

并监听事件：

```C#
 subscription.OnMessage = ()=>{}
```

然后订阅频道：

```C#
 //订阅频道
string channelName = "Send_Log";
subscription.SubscribeToChannels(channelName);
```



Logger.cs

把日志写入数据库

```C#
class Logger
{


    //  开发中 记录日志不用 关系型数据库，用es，mogngodb
    public static void WriteLogByDB(string content)
    {
        string ConStr = "server=.;database=demo;uid=sa;pwd=123456";
        using (SqlConnection sqlcon = new SqlConnection(ConStr))
        {
            sqlcon.Open();
            var sql = "insert into log(content) values(@content)";
            SqlCommand sqlCommand = new SqlCommand(sql, sqlcon);
            sqlCommand.Parameters.Add(new SqlParameter() {              ParameterName="@content",Value=content });
            sqlCommand.ExecuteNonQuery();
        }
    }
}
```

数据库脚本：

```sql
drop database demo;
create database demo;
use demo;
create table log
(
   content varchar(255),
   actiontime datetime default(getdate())
)

truncate table log;
select * from log;
```



##### 测试

同时启动发布者和订阅者两个控制台程序：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613888717105.png" alt="1613888717105" style="zoom:80%;" />



在发布者端发布一条消息：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613888784188.png" alt="1613888784188" style="zoom:80%;" />



#### Redis 事务



事务的特性(ACID）

- 原子性:就是最小的单位
- 一致性 :好多命令，要么全部执行成功，要么全部执行失败
- 隔离性:一个会话和另一个会话之间是互相隔离
- 持久性:执行就执行了，数据保存在硬盘



**Redis中的事务不支持回滚**，比如，

一个事务中有三个指令，中间的指令失败,前面的指令不会回滚，后面的指令继续执行

> 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。
>
> 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。



**示例**：

下面这个示例展示了**Redis中的事务不支持回滚**的情况下，如何做到数据一致性的。

```C#
				//事务模式 
				using (RedisClient client = new RedisClient("127.0.0.1", 6379, "123456"))
				{
					//删除当前数据库中的所有Key  默认删除的是db0
					client.FlushDb();
					//删除所有数据库中的key 
					client.FlushAll();

					client.Set("a", "1");
					client.Set("b", "1");
					client.Set("c", "1");

					//获取当前这三个key的版本号 实现事务
					//watch 用于在进行事务操作的最后一步也就是在执行exec 之前对某个key进行监视
					//client.Watch( "c","b", "c");
					using (var trans = client.CreateTransaction())
					{
						trans.QueueCommand(p => p.Set("a", "3"));
						trans.QueueCommand(p => p.Set("b", "3"));
						trans.QueueCommand(p => p.Set("c", "3"));
						//提交事务  如果在触发事务过程中，其他进程操作了当前的key则，事务提交失败，就是没有指令没有修改成功
						var flag = trans.Commit();
						// ID KEY
						Console.WriteLine(flag);
					}
					//根据key取出值，返回string
					Console.WriteLine(client.Get<string>("a") + ":" + client.Get<string>
					("b") + ":" + client.Get<string>
					("c"));
					Console.ReadLine();
				}
```

以上代码运行结果，如下图分析：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613907426582.png" alt="1613907426582" style="zoom:80%;" />



为了实现Redis事务，我们使用`Watch()`方法，

```C#
client.Watch( "c","b", "c");
```

`watch()` 用于在进行事务操作的最后一步也就是在执行exec 之前对某个key进行监,如果被监听的三个`key`,如果监听到有一个`key`的值被修改了，事务提交失败，即：**事务物中的所有指令都没被提交，没有被提交也就没所谓的回滚一说。**

见下图分析：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613908067845.png" alt="1613908067845" style="zoom:80%;" />



#### Redis 持久化

持久化方式

- 快照方式（RDB）

- 文件追加方式（AOF）

  

##### RDB

 打开Redis配置文件`redis.windows-service.conf`，我们会看到如下配置：

```text
save 900 1
save 300 10
save 60 10000
```

意思是：

```text
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
```

如果 

900秒内有1个key发送变化，

300秒内有5个key发送变化，

60秒内有10000个key发送变化

就会保存一次快照。



做个测试，往redis里添加一个key:value,马上关闭redis程序，然后再启动redis，这时

刚添加的key不存在，因为添加后马上关闭redis，没有满足触发保存快照的条件，所以没有快照生成。

，而原始的key都还存在



###### 通过配置自动触发Bgsave命令的原理

计数器记录了在上一次成功的持久化后，redis进行了多少次写操作，其值在每次写操作之后都加1，在成功完成持久化后清零

Redis有一个周期性操作函数，默认每隔100ms执行一次，它的其中一项工作就是检查自动触发Bgsave命令的条件是否成立



###### 马上生成快照

```powershell
C:\Program Files\Redis>redis-cli.exe -h 127.0.0.1 -p 6379 -a 123456
127.0.0.1:6379> bgsave
Background saving started
127.0.0.1:6379>
```

使用命令`bgsave`立即生产快照，快照文件为:`dump.rdb`



其实，`save`命令也可以产生redis备份,但是不要这样使用，因为

**Save命令**：将内存数据镜像保存为rdb文件，由于redis是单线程模型，
期间会阻塞redis服务进程，redis服务不再处理任何指令，直到rdb文件创建完成位置

**Bgsave命令**：父进程启动一个子进程，由子进程将内存保存在硬盘文件，期间不会影响其他的指令操作



##### AOF

> 特别注意：
>
> ​       RDB和AOF模式是互斥的，当开启AOF模式后，原来使用RDB模式存储的历史数据，在切换为AOF模式后，**RDB模式存储的历史数据将不可读取**。



AOF三个步骤

1. 打开配置文件*.config 中,将

```text
appendonly no
```

修改为：

```text
appendonly yes
```

Redis服务每次结束一个事件循环之前，都会调用flushAppendOnly函数，其中调用write函数将aof_buf写入文件。



现在插入一条数据

```powershell
set aof_test aof
```

写入后，会生成一个文件`appendonly.aof`

```text
*2
$6
SELECT
$1
0
*3
$3
SET
$8
aof_test
$3
aof
```

**文件格式**

- 第一个指令：
  两个参数，第一个参数6个字节，为select
  第二个参数0个字节

  

- 第二个指令:

  三个参数
  第一个参数3个字节为set
  第二个参数4个字节为name
  第三个参数3个字节为aof

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613915496292.png" alt="1613915496292" style="zoom:80%;" />



2. 追加方式

而追加方式的模式在这里配置

```text
# appendfsync always
appendfsync everysec
# appendfsync no
```

三种追加模式：

- appendfsync always  只要有读写

- appendfsync everysec 1s钟的周期
- appendfsync no  等业务不繁忙的时候，这种操作最不可靠

| **类型** | **安全性** | **性能** |
| -------- | ---------- | -------- |
| no       | 低         | 高       |
| everysec | 比较高     | 比较高   |
| always   | 高         | 低       |



##### Redis持久化加载

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613915731141.png" alt="1613915731141" style="zoom:80%;" />



Redis同时支持RDB和AOF模式

但是：优先加载AOF模式

,综上：

​      RDB和AOF模式是互斥的，当开启AOF模式后，原来使用RDB模式存储的历史数据，在切换为AOF模式后，**RDB模式存储的历史数据将不可读取**。



#### Redis集群

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613915978660.png" alt="1613915978660" style="zoom:80%;" />

crc16 算法决定数据写入哪个分片



##### 延迟计算公式(竞选算法)

比如：masterA 出现问题无法使用后，其名下的所有slave，会给集群中的其它mater发起投票，竞选为新的master，选举的算法如下：

 **DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms**

注：SLAVE_RANK表示此从节点已经从主节点复制数据的总量的等级，数据越新，等级越低



##### 集群

某个主节点和所有从节点全部挂掉，我们集群不可用。 
如果半数以上的主节点挂掉，则集群不可用
如果集群任意master挂掉,而且没有从节点，则集群不可用



###### 集群特点

- 主从复制
- 分片
- 高可用



###### 集群部署

- 启动各个redis节点

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616898725389.png" alt="1616898725389" style="zoom: 80%;" />

  修改配置文件里面的port

- 创建集群

```powershell
ruby redis-trib.rb create --replicas 1 
127.0.0.1:6379 127.0.0.1:6380 
127.0.0.1:6381 127.0.0.1:6382 
127.0.0.1:6383 127.0.0.1:6384 
```

部署后的集群管关系如下：

| 主         | 127.0.0.1:6379  | **127.0.0.1:6380** | **127.0.0.1:6381** |
| :--------- | :-------------: | :----------------: | :----------------: |
| 从（只读） | 127.0.0..1:6382 |  127.0.0.0.1:6383  |  127.0.0..1:6384   |
| 分片       |    [0-5460]     |    [5461-10922]    |   [10923-16383]    |



以集成方式登录：

```powershell
redis-clie.exe -p 6379 -c
```

查询集群信息：

```C#
127.0.0.1:6379>cluster nodes 
```

向主节点`6379`添加数据

```powershell
127.0.0.1:6379>set mykey hello
->Redirected to slot [5798] located at 127.0.0.1:6380
Ok
127.0.0.1:6380>get mykey
"hello"
```

重定向到`127.0.0.1:6380`,说明把数据写到`6380`这个分片中

这时把`127.0.0.1:6380`关闭,再链接`6380`查询数据，直接卡死，因为`6380`已经关闭。

再链接`6379`查询数据

```powershell
127.0.0.1:6379>get mykey
->Redirected to slot [5798] located at 127.0.0.1:6383
"hello"
127.0.0.1:6383>cluster nodes

//.........
... 127.0.0.1:6383 myselft,master 
... 127.0.0.1:6380 master,fail
```

`6380`已经链接失败，`6383`已经晋升为`master` 



> 注意：
>
> - ServiceStack.Redis ：
>
>   不支持集群链接
>
> - StackExchange.Redis 
>
>   支持集群链接



###### 库容



**添加新节点**

复制redis文件夹，修改文件夹名为`6385`,

修改配置文件里的端口号`port 6387`

启动Redis实例：

```C#
redis-server.exe redis.windows.conf
```

打开`6379`文件夹

输入：

```C#
ruby redis-trib.rb add-node 127.0.0.1:6385 127.0.0.1:6379
>>> Adding node 127.0.0.1:6385 to cluster 127.0.0.1:6379
    //......
```

登录

```powershell
redis-clie.exe -p 6379 -c
127.0.0.1:6379>cluster nodes 
//.......aaxxxx这时节点的ID
aaaxxx 127.0.0.1:6379 master conneted 0-5460
bbbxxx 127.0.0.1:6381 master conneted 10923-16383
cccxxx 127.0.0.1:6379 master conneted 5461-10922
dddxxx 127.0.0.1:6385 master connected
//.......
```

`127.0.0.1:6385` 作为`master `,但是分片还没分片。

这时，需要给6385 作为主节点，则需要分配一些数据槽(slot)

```powershell
ruby redis-trib.rb reshard 127.0.0.1:6379
//.......

[OK]All nodes agree about slots configuration
//.....
How many solts do you want to move (form 1 to 16384):500 //这里我们输入500
What is the receiving node ID? dddxxx   //输入新节点6385节点的ID
Source node #1:aaaxxx         //从节点6379分成来  
Source node #2:done           //结束分配输入done，接着移动数据
//....
Moving solt 0 from aaaxxx
......
Moving solt 499 from aaaxxx
//

Do you want to proceed with the proposed reshard plan(yes/no)?yes //yes:同意分配计划

//.......
Moving solt 0 from 127.0.0.1:6379 to 127.0.0.1:6385
.......
Moving solt 499 from 127.0.0.1:6379 to 127.0.0.1:6385
//......

#再此登录
redis-clie.exe -p 6379 -c
127.0.0.1:6379>cluster nodes 
//.......aaxxxx这时节点的ID
aaaxxx 127.0.0.1:6379 master conneted 500-5460     //被分出500个slot
bbbxxx 127.0.0.1:6381 master conneted 10923-16383
cccxxx 127.0.0.1:6379 master conneted 5461-10922
dddxxx 127.0.0.1:6385 master connected 0-499       //获得500个slot
//.......
```

其中，

这个命令

```powershell
ruby redis-trib.rb reshard 127.0.0.1:6379
```

的意思是重新分配一些数据槽(slot)出去，后面的地址只是为了链接到集群


新增`127.0.0.1:6386`,重复上述流程即可：

```powershell
ruby redis-trib.rb add-node 127.0.0.1:6386 127.0.0.1:6379
```



**连接进入新节点 把数据移除出去**

```powershell
cluster replicate cbc6a1ee051348d877d06a3fb3e69b12725cd70a  (主节点的ID)
```



**移除节点id，接收的节点id**
```powershell
ruby redis-trib.rb del-node 127.0.0.1:6386  (当前节点id)
```



##### 性能测试

```powershell
redis-benchamark.exe -c 100 -n 10000
```



## 13 Docker

> 教程：https://github.com/K-Artisan/docker-course-kuangshen



### 虚拟机--容器来源

**资源利用率太低**，比如：想要发布Net程序，又要发布Java程序，但配置起来**环境发生冲突**，程序之间相互影响

**快速部署的需求**：发布集群的时候

把一个大的服务器分解成多个小的个体，五脏俱全，各种应用分布在不同的个体里面，互不影响—利用率提高—**镜像快速部署**



### VM-云计算

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613963618316.png" alt="1613963618316" style="zoom:80%;" />



### 容器技术

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1613964949428.png" alt="1613964949428" style="zoom:80%;" />

Docker就是虚拟化的一种轻量级替代技术。Docker的容器技术不依赖任何语言、框架或系统，可以将App变成一种 标准化的、可移植的、自管理的组件，并脱离服务器硬件在任何主流系统中开发、调试和运行。

容器是隔离的小个体---轻量级—共享内核



### Docker基础架构

|                                                          |                                                         |
| -------------------------------------------------------- | ------------------------------------------------------- |
| namespace命名空间

Linux特有的，用来隔离进程，管控资源权限 | Control group控制组
控制进程使用资源的大小，能用多少资源 |
| LXC(Linux containers)
Namespace+cgroup
容器技术—共享内核   | Docker---是在Lxc做了封装，做了开发，提供业务功能        |



### Docker是啥？



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/docker.png" style="zoom:50%;" />

https://www.docker.com/

https://docs.docker.com/docker-for-windows/install/

https://www.runoob.com/docker/docker-tutorial.html



Docker是一种虚拟化的解决方案
可以让应用+依赖独立起来(运行环境)—高效
而且能快速复制

Docker其实是一项应用，
Client/Server



### 安装



#### windows

https://www.runoob.com/docker/windows-docker-install.html



##### WSL2

https://zhuanlan.zhihu.com/p/144583887

https://docs.microsoft.com/en-us/windows/wsl/install-win10#step-4---download-the-linux-kernel-update-package

 用过 WSL 第一代的朋友一定都遇到过一些比较蛋疼兼容性的问题，这些问题是由于 WSL 并不“完整”导致的。说到底 WSL 还只是一个用于访问 Linux 环境的兼容层，并没有实现 Linux 内核的完整功能 

 而 WSL2 基于`Hyper-V`功能的子集提供了“真正的 Linux 内核”，因此上述问题也被解决了。同时，WSL2 也 **支持 Windows 10 家庭版**，因此之前家庭版不能用 Docker Desktop 的情况也已经成了历史 



###### 升级到WSL2

 下面的所有命令均需在有管理员权限的 PowerShell 中执行 

 **A. 安装WSL2功能模块** 

1. 如果之前没有用过 WSL，那么首先需要安装 Windows 10 的 WSL 功能：

```powershell
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
```



2. 安装 WSL2 功能模块：

   ```powershell
   dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
   ```

   

3.   上面的命令执行完毕后，重启电脑完成 WSL2 的安装。 

 

 **B. 安装Linux内核** 

1. 至此为止我们只是开启了 WSL2 的功能，但是还需要安装对应的 Linux 系统内核。 请按照[官方文档](https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/windows/wsl/wsl2-kernel)中的说明下载并安装对应软件包。
2. 在 PowerShell 中，将 WSL 默认版本设置为`2`，这样之后安装的 Linux 发行版才会都安装在 WSL2 中。*若没有安装上一步中的内核，此时系统会提醒你到对应的网址下载内核并安装。*

```powershell
wsl --set-default-version 2
```



 在 PowerShell 中使用如下命令可以检查是否安装成功： 

```powershell

PS C:\WINDOWS\system32> wsl --list --verbose
  NAME                   STATE           VERSION
* docker-desktop         Running         2
  docker-desktop-data    Running         2
```



### CentOS:AspNet.Core+Docker

#### 发布asp.net core项目

按正常的流程把asp.net core 3.1 的项目发布的一个文件夹

```powershell
E:\webpulish\docker\aspnet_docker
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616774460361.png" alt="1616774460361" style="zoom:80%;" />

然后使用**Xftp**把这个文件从Windows 系统上传到CentOS系统的`/webpublish`的目录下：

```shell
[root@centos7 /]# mkdir/webpublish
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616775173477.png" alt="1616775173477" style="zoom:80%;" />



#### 下载 asp.net core docker 镜像

搜索镜像：

```shell
[root@centos7 aspnet_docker]# docker search aspnetcore
NAME                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
microsoft/aspnetcore                      Official images for running compiled ASP.NET…   619                  [OK]
microsoft/aspnetcore-build                Official images for building ASP.NET Core ap…   293                  [OK]
lonwern/aspnetcore-libgdiplus             aspnetcore runtime with libgdiplus              6                    [OK]
microsoft/aspnetcore-build-nightly        Images to build preview versions of ASP.NET …   4                    [OK]

```

没有具体的版本信息，到DockerHub上搜索下：

1.1：https://hub.docker.com/r/microsoft/aspnetcore

2.1/3.1：https://hub.docker.com/_/microsoft-dotnet-core-aspnet/

上述网页提示被移动到了这里

https://hub.docker.com/_/microsoft-dotnet

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616776401009.png" alt="1616776401009" style="zoom:50%;" />

选择：**dotnet/aspnet**:https://hub.docker.com/_/microsoft-dotnet-aspnet/

```shell
5.0 (Current)
docker pull mcr.microsoft.com/dotnet/aspnet:5.0
3.1 (LTS)
docker pull mcr.microsoft.com/dotnet/aspnet:3.1
```



下载镜像：下载aspnet:3.1版本

```shell
[root@centos7 aspnet_docker]# docker pull mcr.microsoft.com/dotnet/aspnet:3.1
3.1: Pulling from dotnet/aspnet
6f28985ad184: Pull complete 
6aa93ebde364: Pull complete 
f1c708cc7347: Pull complete 
f042f5bef7dd: Pull complete 
c7c837096535: Pull complete 
Digest: sha256:a5117c5a4767aa296546f4bbd50cd1385660e8e724fabb356cc72b36a401236e
Status: Downloaded newer image for mcr.microsoft.com/dotnet/aspnet:3.1
mcr.microsoft.com/dotnet/aspnet:3.1

[root@centos7 aspnet_docker]# docker images
REPOSITORY                        TAG                IMAGE ID       CREATED         SIZE
mcr.microsoft.com/dotnet/aspnet   3.1                3186f4d482ae   22 hours ago    208MB


```



#### 运行容器

运行容器

```shell
docker run -d -p 8081:80 --name aspnet_test -v /webpublish/aspnet_docker:/app --workdir /app mcr.microsoft.com/dotnet/aspnet:3.1  dotnet /app/Zhaoxi.AspNetCore31.DockerProject.dll
```



`-p 8081:80`: 8081 为宿主的端口

`--name aspnet_test `容器名称

`-v`:卷挂载主机

`--workdir` /app :Docker的工作目录为 /app

`mcr.microsoft.com/dotnet/aspnet`：镜像版本·

`/app/Zhaoxi.AspNetCore31.DockerProject.dll`:容器运行时执行的命令

```shell
[root@centos7 aspnet_docker]# docker run -d -p 8081:80 --name aspnet_test -v /webpublish/aspnet_docker:/app --workdir /app mcr.microsoft.com/dotnet/aspnet:3.1  dotnet /app/Zhaoxi.AspNetCore31.DockerProject.dll
1639ebd7df26b7f2782b9055010f8ad4d14235e5683855fbecf5267847c3e354
[root@centos7 aspnet_docker]# docker ps 
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

```

容器没有运行：

```shell
[root@centos7 aspnet_docker]# docker ps -a 
CONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS                        PORTS                                              NAMES
1639ebd7df26   mcr.microsoft.com/dotnet/aspnet:3.1   "dotnet /app/Zhaoxi.…"   47 seconds ago   Exited (139) 45 seconds ago                                                      aspnet_test

```

查看日志找原因：

```shell
[root@centos7 aspnet_docker]# docker logs aspnet_test 
Unhandled exception. System.IO.FileNotFoundException: Could not find file '/app/log4net.config'.
File name: '/app/log4net.config'
   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)
   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode)
   at System.IO.FileStream.OpenHandle(FileMode mode, FileShare share, FileOptions options)
   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options)
   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share)
   at System.IO.File.OpenRead(String path)
   at Microsoft.Extensions.Logging.Log4NetProvider.ParseLog4NetConfigFile(String filename)
   at Microsoft.Extensions.Logging.Log4NetProvider.ConfigureLog4NetLibrary(Assembly assembly)
   at Microsoft.Extensions.Logging.Log4NetProvider..ctor(Log4NetProviderOptions options)
   at Microsoft.Extensions.Logging.Log4NetExtensions.AddLog4Net(ILoggingBuilder builder, Log4NetProviderOptions options)
   at Microsoft.Extensions.Logging.Log4NetExtensions.AddLog4Net(ILoggingBuilder builder)
   at Zhaoxi.AspNetCore31.DockerProject.Program.<>c.<CreateHostBuilder>b__1_0(ILoggingBuilder loggingBuilder) in F:\temp-code\.net\Zhaoxi.AspNetCore31.DockerProject\Zhaoxi.AspNetCore31.DockerProject\Program.cs:line 25
   at Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.<>c__DisplayClass5_0.<ConfigureLogging>b__1(ILoggingBuilder builder)
   at Microsoft.Extensions.DependencyInjection.LoggingServiceCollectionExtensions.AddLogging(IServiceCollection services, Action`1 configure)
   at Microsoft.Extensions.Hosting.HostingHostBuilderExtensions.<>c__DisplayClass5_0.<ConfigureLogging>b__0(HostBuilderContext context, IServiceCollection collection)
   at Microsoft.Extensions.Hosting.HostBuilder.CreateServiceProvider()
   at Microsoft.Extensions.Hosting.HostBuilder.Build()
   at Zhaoxi.AspNetCore31.DockerProject.Program.Main(String[] args) in F:\temp-code\.net\Zhaoxi.AspNetCore31.DockerProject\Zhaoxi.AspNetCore31.DockerProject\Program.cs:line 16

#日志显示的是文件/app/log4net.config不存在，查看文件，
[root@centos7 aspnet_docker]# ls log4net.Config
log4net.Config

#得把文件的后缀名改为小写,重命名
[root@centos7 aspnet_docker]# mv log4net.Config log4net.config

#启动刚才运行失败的容器
[root@centos7 aspnet_docker]# docker start aspnet_test 
aspnet_test
[root@centos7 aspnet_docker]# docker ps 
CONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                  NAMES
1639ebd7df26   mcr.microsoft.com/dotnet/aspnet:3.1   "dotnet /app/Zhaoxi.…"   8 minutes ago   Up 8 seconds   0.0.0.0:8081->80/tcp   aspnet_test

```

 

#### 测试发布

在Docker的宿主主机（CentOS系统）中，打开浏览器，访问：http://localhost:8081，或者在CentOS(**IP:192.168.130.129**)的宿主主机中访问http://192.168.130.129:8081

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616779515523.png" alt="1616779515523" style="zoom:80%;" />





#### 云服务器的一些问题

将应用程序发布到云服务器（如：阿里云等），要记得的在安全组中开发端口；

对外映射的端口没开启。

```shell
--查询端口号XXX 是否开启
firewall-cmd --query-port=XXX/tcp  
--开启端口
firewall-cmd --zone=public --add-port=XXX/tcp --permanent
--重启防火墙
```



### CentOS:AspNet.Core+Dockerfile

这一节，我们使用 dockerfile的方式来发布 asp.net core 3.1 网站



#### 项目使用Redis

引用:

```xml
 <PackageReference Include="Microsoft.Extensions.Caching.Redis" Version="2.2.0" />
```

Startup.cs

```C#
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllersWithViews();

            services.AddDistributedRedisCache(options =>
            {
                options.Configuration = "192.168.130.129:8085"; //Docker 宿主主机地址
                options.InstanceName = "RedisDistributedCache0619";
            });
        }
```

使用Redis的页面：

```C#
public class HomeController : Controller
    {
        private readonly ILogger<HomeController> _logger;
        private readonly IConfiguration _IConfiguration;
        private IDistributedCache _iDistributedCache;
        public HomeController(ILogger<HomeController> logger, IConfiguration configuration, IDistributedCache distributedCache)
        {
            _logger = logger;
            this._IConfiguration = configuration;
            this._iDistributedCache = distributedCache;
        }


        public IActionResult IndexRedis()
        {
            this._logger.LogWarning($"This is {this._IConfiguration["CustomMessage"]}");

            #region 解决缓存在不同实例共享问题
            {
                string keyDistributedCache = $"HomeController-Info-DistributedCache";
                string time = this._iDistributedCache.GetString(keyDistributedCache);
                if (!string.IsNullOrWhiteSpace(time))
                {

                }
                else
                {
                    time = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff");
                    this._iDistributedCache.SetString(keyDistributedCache, time, new DistributedCacheEntryOptions()
                    {
                        AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(120)
                    });
                }
                base.ViewBag.DistributedCacheNow = time;
            }
            //Redis数据结构可不止这一个
            #endregion

            base.ViewBag.Now = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff");
            return View();
        }
```

view:

```html
@{
    ViewData["Title"] = "Home Page";
}

<div class="text-center">
    <h1 class="display-4">IndexRedis Welcome2222</h1>
</div>
<h3>ViewTime:@DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff")</h3>
<h2>后台Action时间：@base.ViewBag.Now</h2>
<h2>DistributedCacheNow时间：@base.ViewBag.DistributedCacheNow</h2>
```



#### 项目添加Docker支持

右键项目文件，选择【添加Dokcer支持--目标：Linux】，点击确定后，Vs会在项目的根目录下自动生成一个`Dockerfile`文件：

```dockerfile
#See https://aka.ms/containerfastmode to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.

FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
WORKDIR /src
COPY ["Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj", "Zhaoxi.AspNetCore31.DockerProject/"]
RUN dotnet restore "Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj"
COPY . .
WORKDIR "/src/Zhaoxi.AspNetCore31.DockerProject"
RUN dotnet build "Zhaoxi.AspNetCore31.DockerProject.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "Zhaoxi.AspNetCore31.DockerProject.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "Zhaoxi.AspNetCore31.DockerProject.dll"]
#通篇下来，就是准备基础镜像--copy代码--编译---发布---dotnet
```

不用做任何修改。

#### 项目整体拷贝

把在Windows系统中的项目代码拷贝到CentOS系统中，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616783689029.png" alt="1616783689029" style="zoom:80%;" />

目录及其文件如下：

```shell
[root@centos7 ~]# cd /aspnet_code/
[root@centos7 aspnet_code]# ls
src
[root@centos7 aspnet_code]# cd src
[root@centos7 src]# ls
Zhaoxi.AspNetCore31.DockerProject  Zhaoxi.AspNetCore31.DockerProject.sln
[root@centos7 src]# cd Zhaoxi.AspNetCore31.DockerProject/
[root@centos7 Zhaoxi.AspNetCore31.DockerProject]# ls
appsettings.Development.json  Dockerfile         log4net.config  Properties  Zhaoxi.AspNetCore31.DockerProject.csproj
appsettings.json              Dockerfile-1       Models          Startup.cs  Zhaoxi.AspNetCore31.DockerProject.csproj.user
bin                           Dockerfile - 副本  obj             Views
Controllers                   log                Program.cs      wwwroot




```



#### 创建镜像(使用Dockerfile)

> Dockfile文件要与项目文件夹在同一级目录下

```shell
# 需要把Dockerfile文件移动到与 *.sln同级的目录下 
[root@centos7 Zhaoxi.AspNetCore31.DockerProject]# mv Dockerfile ../
[root@centos7 Zhaoxi.AspNetCore31.DockerProject]# cd ../
[root@centos7 src]# ls
Dockerfile  Zhaoxi.AspNetCore31.DockerProject  Zhaoxi.AspNetCore31.DockerProject.sln

# 把当前目录切换Dokckerfile所在的目录
# 执行如下命名创建镜像（两者择其一），
# build命令，最后有个.  是表示上下文路径，Dockerfile里面设置的命令等是以此上下文路径去执行的，比如要
# 比如打包文件
# [root@centos7 src]# docker build -f Dockerfile -t my_aspnetcore_web:1.0  .
# 不指定使用-f Dockerfile文件时，默认使用名称为：Dockerfile的文件
[root@centos7 src]# docker build -t my_aspnetcore_web:1.0  .
Sending build context to Docker daemon  4.407MB
Step 1/17 : FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
3.1-buster-slim: Pulling from dotnet/core/aspnet
ac2522cc7269: Pull complete 
9fa9d779e93d: Pull complete 
3294d160fd8d: Pull complete 
92c83ca2a3a7: Pull complete 
c0bfea8a890a: Pull complete 
Digest: sha256:8adc8a7640c44922d41b40f39fd6de2568245cccb7c8c2f75e19e846debdc666
Status: Downloaded newer image for mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim
 ---> 645ec0b96f8f
Step 2/17 : WORKDIR /app
 ---> Running in 9e10eca1c7f2
Removing intermediate container 9e10eca1c7f2
 ---> 6b43248f326d
Step 3/17 : EXPOSE 80
 ---> Running in 33657926c4c5
Removing intermediate container 33657926c4c5
 ---> ec2c5bc2af1b
Step 4/17 : EXPOSE 443
 ---> Running in 70eb8edf778a
Removing intermediate container 70eb8edf778a
 ---> 6dc19bd71958
Step 5/17 : FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
3.1-buster: Pulling from dotnet/core/sdk
e22122b926a1: Already exists 
f29e09ae8373: Already exists 
e319e3daef68: Already exists 
e499244fe254: Already exists 
45167b1903e6: Pull complete 
0df6347c1d39: Pull complete 
98f6e4693223: Pull complete 
Digest: sha256:d43e88be7df7061089d63143667ce6e52a132bc34171d409aae926a27467b5c6
Status: Downloaded newer image for mcr.microsoft.com/dotnet/core/sdk:3.1-buster
 ---> a996740b0e4c
Step 6/17 : WORKDIR /src
 ---> Running in c11c36dd7890
Removing intermediate container c11c36dd7890
 ---> 490582ccbed8
Step 7/17 : COPY ["Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj", "Zhaoxi.AspNetCore31.DockerProject/"]
 ---> 80725ff811da
Step 8/17 : RUN dotnet restore "Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj"
 ---> Running in 31877ec63372
  Determining projects to restore...
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/microsoft.visualstudio.azure.containers.tools.targets/index.json'.
  Resource temporarily unavailable
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/log4net/index.json'.
  Resource temporarily unavailable
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/microsoft.extensions.caching.redis/index.json'.
  Resource temporarily unavailable
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/microsoft.extensions.logging/index.json'.
  Resource temporarily unavailable
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/microsoft.extensions.configuration.abstractions/index.json'.
  Resource temporarily unavailable
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/microsoft.extensions.configuration.binder/index.json'.
  Resource temporarily unavailable
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.xml.xpath.xdocument/index.json'.
  Resource temporarily unavailable
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.io.filesystem.watcher/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.net.sockets/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.net.nameresolution/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.net.requests/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.runtime.interopservices/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.reflection.extensions/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.xml.readerwriter/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.text.regularexpressions/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.reflection.typeextensions/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.threading.timer/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.xml.xmldocument/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.linq/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.runtime.extensions/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.threading/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.reflection/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.runtime.serialization.formatters/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.threading.thread/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.runtime.interopservices.runtimeinformation/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.runtime.handles/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.threading.tasks/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.threading.threadpool/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.runtime.serialization.formatters/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.runtime.interopservices.runtimeinformation/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.reflection/index.json'.
  Connection refused
  Retrying 'FindPackagesByIdAsync' for source 'https://api.nuget.org/v3-flatcontainer/system.threading.thread/index.json'.
  Connection refused
  Failed to download package 'System.Threading.Timer.4.0.1' from 'https://api.nuget.org/v3-flatcontainer/system.threading.timer/4.0.1/system.threading.timer.4.0.1.nupkg'.
  Connection refused
  Failed to download package 'System.Threading.Timer.4.3.0' from 'https://api.nuget.org/v3-flatcontainer/system.threading.timer/4.3.0/system.threading.timer.4.3.0.nupkg'.
  Connection refused
  Failed to download package 'System.Threading.4.0.11' from 'https://api.nuget.org/v3-flatcontainer/system.threading/4.0.11/system.threading.4.0.11.nupkg'.
  Connection refused
  Failed to download package 'System.Threading.4.3.0' from 'https://api.nuget.org/v3-flatcontainer/system.threading/4.3.0/system.threading.4.3.0.nupkg'.
  Connection refused
  Restored /src/Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj (in 2.02 min).
Removing intermediate container 31877ec63372
 ---> eadc9b6ded13
Step 9/17 : COPY . .
 ---> b709ea0bbf90
Step 10/17 : WORKDIR "/src/Zhaoxi.AspNetCore31.DockerProject"
 ---> Running in 34a9996925a8
Removing intermediate container 34a9996925a8
 ---> b49dd15a2c1e
Step 11/17 : RUN dotnet build "Zhaoxi.AspNetCore31.DockerProject.csproj" -c Release -o /app/build
 ---> Running in a6cd21dbf965
Microsoft (R) Build Engine version 16.7.2+b60ddb6f4 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  All projects are up-to-date for restore.
  Zhaoxi.AspNetCore31.DockerProject -> /app/build/Zhaoxi.AspNetCore31.DockerProject.dll
  Zhaoxi.AspNetCore31.DockerProject -> /app/build/Zhaoxi.AspNetCore31.DockerProject.Views.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:08.56
Removing intermediate container a6cd21dbf965
 ---> c7591d192d28
Step 12/17 : FROM build AS publish
 ---> c7591d192d28
Step 13/17 : RUN dotnet publish "Zhaoxi.AspNetCore31.DockerProject.csproj" -c Release -o /app/publish
 ---> Running in d7009ba454e2
Microsoft (R) Build Engine version 16.7.2+b60ddb6f4 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  All projects are up-to-date for restore.
  Zhaoxi.AspNetCore31.DockerProject -> /src/Zhaoxi.AspNetCore31.DockerProject/bin/Release/netcoreapp3.1/Zhaoxi.AspNetCore31.DockerProject.dll
  Zhaoxi.AspNetCore31.DockerProject -> /src/Zhaoxi.AspNetCore31.DockerProject/bin/Release/netcoreapp3.1/Zhaoxi.AspNetCore31.DockerProject.Views.dll
  Zhaoxi.AspNetCore31.DockerProject -> /app/publish/
Removing intermediate container d7009ba454e2
 ---> 7d8232860402
Step 14/17 : FROM base AS final
 ---> 6dc19bd71958
Step 15/17 : WORKDIR /app
 ---> Running in 1bc60064faad
Removing intermediate container 1bc60064faad
 ---> 319e614f58ab
Step 16/17 : COPY --from=publish /app/publish .
 ---> ef83756b1408
Step 17/17 : ENTRYPOINT ["dotnet", "Zhaoxi.AspNetCore31.DockerProject.dll"]
 ---> Running in 535164221aea
Removing intermediate container 535164221aea
 ---> 81434d9699a2
Successfully built 81434d9699a2
Successfully tagged my_aspnetcore_web:1.0


```



查看生成的镜像：

```shell
[root@centos7 src]# docker images my_aspnetcore_web
REPOSITORY          TAG       IMAGE ID       CREATED              SIZE
my_aspnetcore_web   1.0       81434d9699a2   About a minute ago   213MB

```



#### 运行容器

```shell
# 运行容器
[root@centos7 src]# docker run -itd --name aspnet_by_mydockerimage -p 8082:80 my_aspnetcore_web:1.0
9692c5ffc7e9bc0c4e9e92c65d7064f3fb5170efc796d0188a2106720f4bcf7d

[root@centos7 src]# docker ps
CONTAINER ID   IMAGE                                 COMMAND                  CREATED         STATUS         PORTS                           NAMES
9692c5ffc7e9   my_aspnetcore_web:1.0                 "dotnet Zhaoxi.AspNe…"   8 seconds ago   Up 6 seconds   443/tcp, 0.0.0.0:8082->80/tcp   aspnet_by_mydockerimage
1639ebd7df26   mcr.microsoft.com/dotnet/aspnet:3.1   "dotnet /app/Zhaoxi.…"   2 hours ago     Up 2 hours     0.0.0.0:8081->80/tcp            aspnet_test

```



#### 测试发布

在Docker的宿主主机（CentOS系统）中，打开浏览器，访问：http://localhost:8082，或者在CentOS(**IP:192.168.130.129**)的宿主主机中访问http://192.168.130.129:8082

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616786507987.png" alt="1616786507987" style="zoom: 80%;" />

### 使用Nginx做集群

 下载 nginx 镜像

```shell
[root@centos7 ~]# docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
6f28985ad184: Already exists 
29f7ebf60efd: Pull complete 
879a7c160ac6: Pull complete 
de58cd48a671: Pull complete 
be704f37b5f4: Pull complete 
158aac73782c: Pull complete 
Digest: sha256:e5e61af4e0cfcaf799d18aa422463f1c9770fee46f634abf51b74d33594ca338
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest

```

Nginx配置文件

创建nginx配置文件挂载目录

```shell
[root@centos7 ~]# mkdir -p /docker/nginx/
```

将配置文件 nginx.conf拷贝到CentOS的`/docker/nginx/`目录下：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616806910967.png" alt="1616806910967" style="zoom:80%;" />

```nginx
##代码块中的events、http、server、location、upstream等都是块配置项##
##块配置项可以嵌套。内层块直接继承外层快，例如：server块里的任意配置都是基于http块里的已有配置的##
 
##Nginx worker进程运行的用户及用户组 
#语法：user username[groupname]    默认：user nobody nobody
#user用于设置master进程启动后，fork出的worker进程运行在那个用户和用户组下。当按照"user username;"设置时，用户组名与用户名相同。
#若用户在configure命令执行时，使用了参数--user=usergroup 和 --group=groupname,此时nginx.conf将使用参数中指定的用户和用户组。
#user  nobody;
 
##Nginx worker进程个数：其数量直接影响性能。
#每个worker进程都是单线程的进程，他们会调用各个模块以实现多种多样的功能。如果这些模块不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程，反之，有可能出现阻塞式调用，那么，需要配置稍多一些的worker进程。
worker_processes  1;
 
##ssl硬件加速。
#用户可以用OpneSSL提供的命令来查看是否有ssl硬件加速设备：openssl engine -t
#ssl_engine device;
 
##守护进程(daemon)。是脱离终端在后台允许的进程。它脱离终端是为了避免进程执行过程中的信息在任何终端上显示。这样一来，进程也不会被任何终端所产生的信息所打断。##
##关闭守护进程的模式，之所以提供这种模式，是为了放便跟踪调试nginx，毕竟用gdb调试进程时最繁琐的就是如何继续跟进fork出的子进程了。##
##如果用off关闭了master_proccess方式，就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求
#daemon off;   #查看是否以守护进程的方式运行Nginx 默认是on 
#master_process off; #是否以master/worker方式工作 默认是on
 
##error日志的设置#
#语法： error_log /path/file level;
#默认： error_log / log/error.log error;
#当path/file 的值为 /dev/null时，这样就不会输出任何日志了，这也是关闭error日志的唯一手段；
#leve的取值范围是debug、info、notice、warn、error、crit、alert、emerg从左至右级别依次增大。
#当level的级别为error时，error、crit、alert、emerg级别的日志就都会输出。大于等于该级别会输出，小于该级别的不会输出。
#如果设定的日志级别是debug，则会输出所有的日志，这一数据量会很大，需要预先确保/path/file所在的磁盘有足够的磁盘空间。级别设定到debug，必须在configure时加入 --with-debug配置项。
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
 
##pid文件（master进程ID的pid文件存放路径）的路径
#pid        logs/nginx.pid;
 
 
events {
 #仅对指定的客户端输出debug级别的日志： 语法：debug_connection[IP|CIDR]
 #这个设置项实际上属于事件类配置，因此必须放在events{……}中才会生效。它的值可以是IP地址或者是CIRD地址。
 	#debug_connection 10.224.66.14;  #或是debug_connection 10.224.57.0/24
 #这样，仅仅以上IP地址的请求才会输出debug级别的日志，其他请求仍然沿用error_log中配置的日志级别。
 #注意：在使用debug_connection前，需确保在执行configure时已经加入了--with-debug参数，否则不会生效。
	worker_connections  1024;
}
 
##核心转储(coredump):在Linux系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内容(核心映像)写入一个文件(core文件)，以作为调试只用，这就是所谓的核心转储(coredump).
 
http {
##嵌入其他配置文件 语法：include /path/file
#参数既可以是绝对路径也可以是相对路径（相对于Nginx的配置目录，即nginx.conf所在的目录）
    include       mime.types;
    default_type  application/octet-stream;
 
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
 
    #access_log  logs/access.log  main;
 
    sendfile        on;
    #tcp_nopush     on;
 
    #keepalive_timeout  0;
    keepalive_timeout  65;
     upstream taishan {
    #weigth参数表示权值，权值越高被分配到的几率越大
    server 192.168.130.129:8081 weight=2;
    server 192.168.130.129:8082 weight=1; 
} 
    #gzip  on;
 
    server {
##listen监听的端口
#语法：listen address:port [ default(deprecated in 0.8.21) | default_server | [ backlog=num | rcvbuf=size | sndbuf=size | accept_filter=filter | deferred | bind | ssl ] ]
#default_server: 如果没有设置这个参数，那么将会以在nginx.conf中找到的第一个server块作为默认server块
	listen       80;
 
#主机名称：其后可以跟多个主机名称，开始处理一个HTTP请求时，nginx会取出header头中的Host，与每个server中的server_name进行匹配，以此决定到底由那一个server来处理这个请求。有可能一个Host与多个server块中的server_name都匹配，这时会根据匹配优先级来选择实际处理的server块。server_name与Host的匹配优先级见文末。
	 server_name  localhost;
 
        #charset koi8-r;
 
        #access_log  logs/host.access.log  main;
 
        #location / {
        #    root   html;
        #    index  index.html index.htm;
        #}
 
##location 语法： location [=|~|~*|^~] /uri/ { ... }
# location的使用实例见文末。
#注意：location时有顺序的，当一个请求有可能匹配多个location时，实际上这个请求会被第一个location处理。
	location / {
	proxy_pass  http://taishan;
        }
 
        #error_page  404              /404.html;
 
        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
 
        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://39.96.34.52:8091;
        #}
 
        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}
 
        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }
 
 
 
    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;
 
    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
 
 
    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;
 
    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;
 
    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;
 
    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;
 
    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
 
}
```

Nginx默认80端口



运行容器

```shell
[root@centos7 ~]# docker run -d --name aspnet_nginx -p 8086:80 -v /docker/nginx/log/:/var/log/nginx/ -v /docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro  nginx
33f37e24e5c20069efa646fcc65b775b42e97f7de5ac1ee08e989ef0af909d72
[root@centos7 ~]# docker ps 
CONTAINER ID   IMAGE                                 COMMAND                  CREATED          STATUS          PORTS                           NAMES
33f37e24e5c2   nginx                                 "/docker-entrypoint.…"   14 seconds ago   Up 12 seconds   0.0.0.0:8086->80/tcp            aspnet_nginx
9692c5ffc7e9   my_aspnetcore_web:1.0                 "dotnet Zhaoxi.AspNe…"   6 hours ago      Up 6 hours      443/tcp, 0.0.0.0:8082->80/tcp   aspnet_by_mydockerimage
1639ebd7df26   mcr.microsoft.com/dotnet/aspnet:3.1   "dotnet /app/Zhaoxi.…"   8 hours ago      Up 8 hours      0.0.0.0:8081->80/tcp            aspnet_test
[root@centos7 ~]# 

```

 :ro--即readonly，只读，**容器内对路径是只读权限，要改变指定路径的内容，只能通过宿主机来操作** 

在访问Nngix, http://192.168.130.129:8086

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616808042199.png" alt="1616808042199" style="zoom:80%;" />



### 使用Redis+Docker

下载Redis镜像：

```shell
docker pull redis:6.0
```

拷贝redis.conf到宿主主机（192.168.130.129）的`/docker/redis/`目录下或者在CentOS中创建

```shell
[root@centos7 ~]# mkdir -p /docker/redis/
[root@centos7 ~]# cd /docker/redis
[root@centos7 redis]# vim redis.config

```

redis.conf的内容如下：见`配置文件/redis.conf`

其中，

默认情况下，redis的配置是：

- 没有密码
- 默认端口6379
- 只能本机访问，不能远程访问

所有得修改下配置文件：

`bind 0.0.0.0`:可以监听其它主机的IP，

```shell
#只能监听本机（本Docker容器）的端口
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1 ::1
```

`protected-mode no`可以使得外网可以访问，远程登录



运行容器

```shell
[root@centos7 redis]# docker run -d -p 8085:6379  -v /docker/redis/redis.conf:/usr/local/etc/redis/redis.conf -v /docker/redis/data:/data:rw --name redis_dotnet redis:6.0 redis-server /usr/local/etc/redis/redis.conf
a3662c63fa3494d34e47640fc2f78a3cde5fd92e556826adaedfb41ccc5b10ac

```

测试连接：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616825221326.png" alt="1616825221326" style="zoom:80%;" />



测试网站是否能使用了Redis

我们在这个网站：http://192.168.130.129:8082的页面的如下页面使用了redis：

```C#
        public IActionResult IndexRedis()
        {
            this._logger.LogWarning($"This is {this._IConfiguration["CustomMessage"]}");

            #region 解决缓存在不同实例共享问题
            {
                string keyDistributedCache = $"HomeController-Info-DistributedCache";
                string time = this._iDistributedCache.GetString(keyDistributedCache);
                if (!string.IsNullOrWhiteSpace(time))
                {

                }
                else
                {
                    time = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff");
                    this._iDistributedCache.SetString(keyDistributedCache, time, new DistributedCacheEntryOptions()
                    {
                        AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(120)
                    });
                }
                base.ViewBag.DistributedCacheNow = time;
            }
            //Redis数据结构可不止这一个
            #endregion

            base.ViewBag.Now = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff");
            return View();
        }
```

现在我们访问这个页面：http://192.168.130.129:8082/home/IndexRedis

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616825809380.png" alt="1616825809380" style="zoom:80%;" />

DistributedCacheNow时间 使用的是redis缓存的时间



### Docker管理

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616826344248.png" alt="1616826344248" style="zoom:80%;" />



#### Docker Compose

> 资料：
>
> https://www.runoob.com/docker/docker-compose.html
>
> https://docs.docker.com/compose/



##### Compose 简介

Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。

如果你还不了解 YML 文件配置，可以先阅读 [YAML 入门教程](https://www.runoob.com/w3cnote/yaml-intro.html)。

Compose 使用的三个步骤：

- 使用 Dockerfile 定义应用程序的环境。
- 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。
- 最后，执行 docker-compose up 命令来启动并运行整个应用程序



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616826494639.png" alt="1616826494639" style="zoom:80%;" />



##### 实操

下载：

```shell
[root@centos7 ~]# curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   423  100   423    0     0    409      0  0:00:01  0:00:01 --:--:--   410
100 16.2M  100 16.2M    0     0  3067k      0  0:00:05  0:00:05 --:--:-- 4002k

[root@centos7 ~]# docker-compose -v
docker-compose version 1.25.0, build 0a186604
```

给compose授权，因为它要管理多个容器：

```shell
[root@centos7 ~]# chmod +x /usr/local/bin/docker-compose
```



把上一节创建的容器全部停止并删除：

```shell
[root@centos7 ~]# docker stop aspnet_test aspnet_by_mydockerimage aspnet_nginx redis_dotnet 
aspnet_test
aspnet_by_mydockerimage
aspnet_nginx
redis_dotnet


[root@centos7 ~]# docker rm aspnet_test aspnet_by_mydockerimage aspnet_nginx redis_dotnet 
aspnet_test
aspnet_by_mydockerimage
aspnet_nginx
redis_dotnet

[root@centos7 ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

```

> 删除容器后，其使用卷技术挂载的目录及其文件时而然会保持在宿主机中，
>
> 如果我们后面新建的容器，挂载的目录一样，还是可以读取使用之前被删除的容器的数据



编写YML文件，`docker-compose.yml`

```shell
[root@centos7 ~]# cd /docker
[root@centos7 docker]# mkdir docker-compose
[root@centos7 docker]# cd docker-compose/
[root@centos7 docker-compose]# vim docker-compose.yml
```

插入如下内容并保持退出

```yml
version: "3.3"
services:
  service1:
    build:
      context: /aspnet_code/src
    image: my_aspnetcore_web:dockcompose
    ports:
      - 8081:80/tcp
  service2:
    image: my_aspnetcore_web:dockcompose
    ports:
      - 8082:80/tcp
    command: ["dotnet", "/app/Zhaoxi.AspNetCore31.DockerProject.dll"]
  nginx:
    image: nginx:latest
    ports:
      - 8086:80/tcp
    volumes:
      - /docker/nginx/nginx.conf:/etc/nginx/nginx.conf
  redis:
    image: redis:6.0
    ports:
      - 8085:6379/tcp
    volumes:
      - /docker/redis/redis.conf:/usr/local/etc/redis/redis.conf
      - /docker/redis/data:/data:rw
    command: ["redis-server", "/usr/local/etc/redis/redis.conf"]
```

参数说明：

```shell
- image - 指定了我们用来运行容器的镜像，如果指定的image不存在，它会自动从远程仓库下载
- ports - 指定了我们映射端口，这里把容器80端口映射到宿主机器8081/8082端口
- volumes - 指定了容器里的存储路径以volume挂载方式映射到宿主机器上

- context- 指定Dockerfile所在的位置
```

`yml`文件

```shell
services:
  service1:
    build:
      context: /aspnet_code/src
    image: my_aspnetcore_web:dockcompose
    ports:
      - 8081:80/tcp
```

使用之前的拷贝的asp.net core 3.1的项目代码和Dockerfile文件创建Docker镜像文件`my_aspnetcore_web:dockcompose`，版本为：`:dockcompose`

```shell
[root@centos7 ~]# ls /aspnet_code/src/
Dockerfile  Zhaoxi.AspNetCore31.DockerProject  Zhaoxi.AspNetCore31.DockerProject.sln
```

创建完镜像后，`sever2`就可以直接使用该镜像创建容器：

```yml
  service2:
    image: my_aspnetcore_web:dockcompose
    ports:
      - 8082:80/tcp
    command: ["dotnet", "/app/Zhaoxi.AspNetCore31.DockerProject.dll"]
```



docker-compose 启动

请确保在存在`docker-compose.yml`文件的目录中运行，



```shell
# 最好是使用 -d 在后台运行，否则没法出来，得开启新的shell终端
# 这里是为了演示构建过程，才使用了前台运行

[root@centos7 docker-compose]# docker-compose up 
Creating network "docker-compose_default" with the default driver
Building service1
Step 1/17 : FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
 ---> 645ec0b96f8f
Step 2/17 : WORKDIR /app
 ---> Using cache
 ---> 6b43248f326d
Step 3/17 : EXPOSE 80
 ---> Using cache
 ---> ec2c5bc2af1b
Step 4/17 : EXPOSE 443
 ---> Using cache
 ---> 6dc19bd71958

Step 5/17 : FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
 ---> a996740b0e4c
Step 6/17 : WORKDIR /src
 ---> Using cache
 ---> 490582ccbed8
Step 7/17 : COPY ["Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj", "Zhaoxi.AspNetCore31.DockerProject/"]
 ---> 1c625670b658
Step 8/17 : RUN dotnet restore "Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj"
 ---> Running in 0b08798e3700
  Determining projects to restore...
  Restored /src/Zhaoxi.AspNetCore31.DockerProject/Zhaoxi.AspNetCore31.DockerProject.csproj (in 19.11 sec).
Removing intermediate container 0b08798e3700
 ---> 04a231a57c56
Step 9/17 : COPY . .
 ---> 82bf73b3808b
Step 10/17 : WORKDIR "/src/Zhaoxi.AspNetCore31.DockerProject"
 ---> Running in 27d2f22f0b06
Removing intermediate container 27d2f22f0b06
 ---> e00bf61aaa42
Step 11/17 : RUN dotnet build "Zhaoxi.AspNetCore31.DockerProject.csproj" -c Release -o /app/build
 ---> Running in cd15be68fdff
Microsoft (R) Build Engine version 16.7.2+b60ddb6f4 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  All projects are up-to-date for restore.
  Zhaoxi.AspNetCore31.DockerProject -> /app/build/Zhaoxi.AspNetCore31.DockerProject.dll
  Zhaoxi.AspNetCore31.DockerProject -> /app/build/Zhaoxi.AspNetCore31.DockerProject.Views.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:10.16
Removing intermediate container cd15be68fdff
 ---> 1951c2f38d5c

Step 12/17 : FROM build AS publish
 ---> 1951c2f38d5c
Step 13/17 : RUN dotnet publish "Zhaoxi.AspNetCore31.DockerProject.csproj" -c Release -o /app/publish
 ---> Running in 1cce27213d16
Microsoft (R) Build Engine version 16.7.2+b60ddb6f4 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  All projects are up-to-date for restore.
  Zhaoxi.AspNetCore31.DockerProject -> /src/Zhaoxi.AspNetCore31.DockerProject/bin/Release/netcoreapp3.1/Zhaoxi.AspNetCore31.DockerProject.dll
  Zhaoxi.AspNetCore31.DockerProject -> /src/Zhaoxi.AspNetCore31.DockerProject/bin/Release/netcoreapp3.1/Zhaoxi.AspNetCore31.DockerProject.Views.dll
  Zhaoxi.AspNetCore31.DockerProject -> /app/publish/
Removing intermediate container 1cce27213d16
 ---> 9f679b2ad71c

Step 14/17 : FROM base AS final
 ---> 6dc19bd71958
Step 15/17 : WORKDIR /app
 ---> Using cache
 ---> 319e614f58ab
Step 16/17 : COPY --from=publish /app/publish .
 ---> Using cache
 ---> ef83756b1408
Step 17/17 : ENTRYPOINT ["dotnet", "Zhaoxi.AspNetCore31.DockerProject.dll"]
 ---> Using cache
 ---> 81434d9699a2

Successfully built 81434d9699a2
Successfully tagged my_aspnetcore_web:dockcompose
WARNING: Image for service service1 was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating docker-compose_service1_1 ... done
Creating docker-compose_service2_1 ... done
Creating docker-compose_nginx_1    ... done
Creating docker-compose_redis_1    ... done
Attaching to docker-compose_redis_1, docker-compose_nginx_1, docker-compose_service1_1, docker-compose_service2_1
redis_1     | 1:C 27 Mar 2021 07:59:47.049 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
redis_1     | 1:C 27 Mar 2021 07:59:47.049 # Redis version=6.0.12, bits=64, commit=00000000, modified=0, pid=1, just started
redis_1     | 1:C 27 Mar 2021 07:59:47.049 # Configuration loaded
nginx_1     | /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
nginx_1     | /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
nginx_1     | /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
nginx_1     | 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
nginx_1     | 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
nginx_1     | /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
nginx_1     | /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
nginx_1     | /docker-entrypoint.sh: Configuration complete; ready for start up
redis_1     |                 _._                                                  
redis_1     |            _.-``__ ''-._                                             
redis_1     |       _.-``    `.  `_.  ''-._           Redis 6.0.12 (00000000/0) 64 bit
redis_1     |   .-`` .-```.  ```\/    _.,_ ''-._                                   
redis_1     |  (    '      ,       .-`  | `,    )     Running in standalone mode
redis_1     |  |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
redis_1     |  |    `-._   `._    /     _.-'    |     PID: 1
redis_1     |   `-._    `-._  `-./  _.-'    _.-'                                   
redis_1     |  |`-._`-._    `-.__.-'    _.-'_.-'|                                  
redis_1     |  |    `-._`-._        _.-'_.-'    |           http://redis.io        
redis_1     |   `-._    `-._`-.__.-'_.-'    _.-'                                   
redis_1     |  |`-._`-._    `-.__.-'    _.-'_.-'|                                  
redis_1     |  |    `-._`-._        _.-'_.-'    |                                  
redis_1     |   `-._    `-._`-.__.-'_.-'    _.-'                                   
redis_1     |       `-._    `-.__.-'    _.-'                                       
redis_1     |           `-._        _.-'                                           
redis_1     |               `-.__.-'                                               
redis_1     | 
redis_1     | 1:M 27 Mar 2021 07:59:47.054 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
redis_1     | 1:M 27 Mar 2021 07:59:47.054 # Server initialized
redis_1     | 1:M 27 Mar 2021 07:59:47.054 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
redis_1     | 1:M 27 Mar 2021 07:59:47.054 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo madvise > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to 'madvise' or 'never').
redis_1     | 1:M 27 Mar 2021 07:59:47.056 * Loading RDB produced by version 6.0.12
redis_1     | 1:M 27 Mar 2021 07:59:47.056 * RDB age 2885 seconds
redis_1     | 1:M 27 Mar 2021 07:59:47.056 * RDB memory usage when created 0.93 Mb
redis_1     | 1:M 27 Mar 2021 07:59:47.057 * DB loaded from disk: 0.002 seconds
redis_1     | 1:M 27 Mar 2021 07:59:47.057 * Ready to accept connections
service1_1  | warn: Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository[60]
service1_1  |       Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed.
service2_1  | warn: Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository[60]
service2_1  |       Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed.
service2_1  | warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[35]
service2_1  |       No XML encryptor configured. Key {85e9ce22-c415-4618-b32c-5d56ee07c6f7} may be persisted to storage in unencrypted form.
service1_1  | warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[35]
service1_1  |       No XML encryptor configured. Key {64053644-fdec-4ff9-a5bf-377e352be129} may be persisted to storage in unencrypted form.
service2_1  | info: Microsoft.Hosting.Lifetime[0]
service2_1  |       Now listening on: http://[::]:80
service1_1  | info: Microsoft.Hosting.Lifetime[0]
service1_1  |       Now listening on: http://[::]:80
service1_1  | info: Microsoft.Hosting.Lifetime[0]
service1_1  |       Application started. Press Ctrl+C to shut down.
service1_1  | info: Microsoft.Hosting.Lifetime[0]
service1_1  |       Hosting environment: Production
service1_1  | info: Microsoft.Hosting.Lifetime[0]
service1_1  |       Content root path: /app
service2_1  | info: Microsoft.Hosting.Lifetime[0]
service2_1  |       Application started. Press Ctrl+C to shut down.
service2_1  | info: Microsoft.Hosting.Lifetime[0]
service2_1  |       Hosting environment: Production
service2_1  | info: Microsoft.Hosting.Lifetime[0]
service2_1  |       Content root path: /app

# 
```

启动成功后，查看容器的运行情况：

```shell
[root@centos7 ~]# docker ps 
CONTAINER ID   IMAGE                           COMMAND                  CREATED         STATUS         PORTS                           NAMES
eaae0a6134eb   nginx:latest                    "/docker-entrypoint.…"   4 minutes ago   Up 4 minutes   0.0.0.0:8086->80/tcp            docker-compose_nginx_1
75690fa34afb   my_aspnetcore_web:dockcompose   "dotnet Zhaoxi.AspNe…"   4 minutes ago   Up 4 minutes   443/tcp, 0.0.0.0:8081->80/tcp   docker-compose_service1_1
42d1b37944b9   redis:6.0                       "docker-entrypoint.s…"   4 minutes ago   Up 4 minutes   0.0.0.0:8085->6379/tcp          docker-compose_redis_1
680cd9bd0156   my_aspnetcore_web:dockcompose   "dotnet Zhaoxi.AspNe…"   4 minutes ago   Up 4 minutes   443/tcp, 0.0.0.0:8082->80/tcp   docker-compose_service2_1

```

>- 容器名自动加了前缀`docker-compose_`和后缀`_1`
>
>- 生成了镜像`my_aspnetcore_web:dockcompose`:
>
>  ```shell
>  [root@centos7 ~]# docker images my_aspnetcore_web
>  REPOSITORY          TAG           IMAGE ID       CREATED        SIZE
>  my_aspnetcore_web   1.0           81434d9699a2   13 hours ago   213MB
>  my_aspnetcore_web   dockcompose   81434d9699a2   13 hours ago   213MB
>  
>  ```
>
>  

测试：

web1：http://192.168.130.129:8081

web2：http://192.168.130.129:8082

Nginx：http://192.168.130.129:8086

Redis：http://192.168.130.129:8082/home/IndexRedis 

是可正常访问，还可查看到redis缓存，如下图所示：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616833223562.png" alt="1616833223562" style="zoom:80%;" />





#### Docker Machine

> 参考资料：
>
> https://www.runoob.com/docker/docker-machine.html

Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。
Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616833438348.png" alt="1616833438348" style="zoom:50%;" />

Docker Machine 管理的虚拟主机可以是机上的，也可以是云供应商，如阿里云，腾讯云，AWS，或 DigitalOcean。

使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。



（基本没人用了）



#### Docker Swarm

>参考资料：
>
>https://www.runoob.com/docker/docker-swarm.html



##### 简介

Docker Swarm 是 Docker 的集群管理工具。它将 Docker 主机池转变为单个虚拟 Docker 主机。 Docker Swarm 提供了标准的 Docker API，所有任何已经与 Docker 守护程序通信的工具都可以使用 Swarm 轻松地扩展到多个主机。

支持的工具包括但不限于以下各项：

- Dokku
- Docker Compose
- Docker Machine
- Jenkins

##### 原理

如下图所示，swarm 集群由管理节点（manager）和工作节点（work node）构成。

- **swarm mananger**：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。
- **work node**：即图中的 available node，主要负责运行相应的服务来执行任务（task）。

 <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/services-diagram.png" alt="img" style="zoom: 80%;" /> 



##### 创建 swarm 集群管理节点（manager）

初始化 swarm 集群，进行初始化的这台机器，就是集群的管理节点。 

系统：CentOS7 

IP:192.168.130.129

```shell
[root@centos7 ~]# docker swarm init --advertise-addr 192.168.130.129
Swarm initialized: current node (hysfcctzxx9ynostnteckbf2d) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-4qfwj1lc6151g3k8fj06x30xnyesb0cn67i601b24dbtgcvmog-4lqo44vt10sqqe8v6mlcwftli 192.168.130.129:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.

[root@centos7 ~]# 

```

 以上输出，证明已经初始化成功。需要把以下这行复制出来，在增加工作节点时会用到： 

```shell
docker swarm join --token SWMTKN-1-4qfwj1lc6151g3k8fj06x30xnyesb0cn67i601b24dbtgcvmog-4lqo44vt10sqqe8v6mlcwftli 192.168.130.129:2377
```

这时候，查看docker的集群信息：

```shell
[root@centos7 ~]# docker info

......
  Swarm: active
  NodeID: hysfcctzxx9ynostnteckbf2d
  Is Manager: true
  ClusterID: txv3ectbjy1i3h7ovws454a6a
  Managers: 1
  Nodes: 1
  Default Address Pool: 10.0.0.0/8  
  SubnetSize: 24
  Data Path Port: 4789
  Orchestration:
   Task History Retention Limit: 5
  Raft:
   Snapshot Interval: 10000
   Number of Old Snapshots to Retain: 0
   Heartbeat Tick: 1
   Election Tick: 10
  Dispatcher:
   Heartbeat Period: 5 seconds
  CA Configuration:
   Expiry Duration: 3 months
   Force Rotate: 0
  Autolock Managers: false
  Root Rotation In Progress: false
  Node Address: 192.168.130.129
  Manager Addresses:
   192.168.130.129:2377


```





##### 创建 swarm 集群工作节点（worker）

在第二台虚拟机创建 swarm 集群工作节点（worker）

系统:CentOS 7 , IP:192.168.130.130, 连接这个台虚拟机：

```shell
[root@centos7 ~]# docker swarm join --token SWMTKN-1-4qfwj1lc6151g3k8fj06x30xnyesb0cn67i601b24dbtgcvmog-4lqo44vt10sqqe8v6mlcwftli 192.168.130.129:2377
Error response from daemon: rpc error: code = Unavailable desc = connection error: desc = "transport: Error while dialing dial tcp 192.168.130.129:2377: connect: no route to host"

```

> https://docs.docker.com/engine/swarm/swarm-tutorial/#open-protocols-and-ports-between-the-hosts
>
> ### Open protocols and ports between the hosts
>
> The following ports must be available. On some systems, these ports are open by default.
>
> - **TCP port 2377** for cluster management communications
> - **TCP** and **UDP port 7946** for communication among nodes
> - **UDP port 4789** for overlay network traffic

所以得在所有的Docker宿主主机上执行：

```shell
firewall-cmd --add-port=2376/tcp --permanent
firewall-cmd --add-port=2377/tcp --permanent
firewall-cmd --add-port=7946/tcp --permanent
firewall-cmd --add-port=7946/udp --permanent
firewall-cmd --add-port=4789/udp --permanent
```

- 192.168.130.129:

  ```shell
  [root@centos7 ~]# firewall-cmd --add-port=2376/tcp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=2377/tcp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=7946/tcp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=7946/udp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=4789/udp --permanent
  success
  
  # 重启防火墙策略
  [root@centos7 ~]# firewall-cmd --reload
  success
  
  ```

  

- 192.168.130.130

  ```shell
  [root@centos7 ~]# firewall-cmd --add-port=2376/tcp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=2377/tcp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=7946/tcp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=7946/udp --permanent
  success
  [root@centos7 ~]# firewall-cmd --add-port=4789/udp --permanent
  success
  
  # 重启防火墙策略
  [root@centos7 ~]# firewall-cmd --reload
  success
  
  # 加入Dcoker的Swarm集群
  [root@centos7 ~]# docker swarm join --token SWMTKN-1-4qfwj1lc6151g3k8fj06x30xnyesb0cn67i601b24dbtgcvmog-4lqo44vt10sqqe8v6mlcwftli 192.168.130.129:2377
  This node joined a swarm as a worker.
  ```



##### 查看Docker Swarm集群信息

在管理节点（192.168.130.129）中查看Docker Swarm集群信息：

```shell
[root@centos7 ~]# docker node ls
ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
hysfcctzxx9ynostnteckbf2d *   centos7.6   Ready     Active         Leader           20.10.5
qcwp4esjjfpd37ve2snjhc8mv     centos7.6   Ready     Active                          20.10.5

```



```shell
[root@centos7 ~]# docker info
Client:
 Context:    default
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)

Server:
 Containers: 13
  Running: 3
  Paused: 0
  Stopped: 10
 Images: 27
 Server Version: 20.10.5
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: true
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: 1
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: active
  NodeID: hysfcctzxx9ynostnteckbf2d
  Is Manager: true
  ClusterID: txv3ectbjy1i3h7ovws454a6a
  Managers: 1
  Nodes: 2
  Default Address Pool: 10.0.0.0/8  
  SubnetSize: 24
  Data Path Port: 4789
  Orchestration:
   Task History Retention Limit: 5
  Raft:
   Snapshot Interval: 10000
   Number of Old Snapshots to Retain: 0
   Heartbeat Tick: 1
   Election Tick: 10
  Dispatcher:
   Heartbeat Period: 5 seconds
  CA Configuration:
   Expiry Duration: 3 months
   Force Rotate: 0
  Autolock Managers: false
  Root Rotation In Progress: false
  Node Address: 192.168.130.129
  Manager Addresses:
   192.168.130.129:2377
 Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 05f951a3781f4f2c1911b05e61c160e9c30eaa8e
 runc version: 12644e614e25b05da6fd08a38ffa0cfe1903fdec
 init version: de40ad0
 Security Options:
  seccomp
   Profile: default
 Kernel Version: 3.10.0-957.el7.x86_64
 Operating System: CentOS Linux 7 (Core)
 OSType: linux
 Architecture: x86_64
 CPUs: 4
 Total Memory: 1.934GiB
 Name: centos7.6
 ID: MSBN:PGVG:P4AS:KINV:TYTE:7DBY:Z3XI:2S2V:J7AL:WV7L:XLYR:VNIP
 Docker Root Dir: /var/lib/docker
 Debug Mode: false
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Live Restore Enabled: false

```

多出了一个节点：

```shell
  Managers: 1
  Nodes: 2
```



##### 部署服务到集群中

> **注意**：跟集群管理有关的任何操作，都是在管理节点上操作的。

以下例子，在一个工作节点上创建一个名为 helloworld 的服务，这里是随机指派给一个工作节点：

```shell
[root@centos7 ~]# docker service create –replicas 1 –name myhelloworld alpine ping docker.com
Error response from daemon: rpc error: code = InvalidArgument desc = ContainerSpec: "–replicas" is not a valid repository/tag
[root@centos7 ~]# docker service create --replicas 1 --name helloworld alpine ping docker.com
yylj6zzfzk8bkdnoi3rguiwur
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================>] 
verify: Service converged 

```

replicas 参数是指运行实例个数 
name 参数指定服务名称 
alpine 指的是使用的镜像名称 
ping docker.com 指的是容器运行的bash

 使用docker service ls命令查看创建出来的服务 

```shell
[root@centos7 ~]# docker service ls
ID             NAME         MODE         REPLICAS   IMAGE           PORTS
yylj6zzfzk8b   helloworld   replicated   1/1        alpine:latest   

```

##### 查看部署情况

 查看 helloworld 服务运行在哪个节点上，可以看到目前是在`centos7.6 (192.168.130.130)`节点： 

```shell
[root@centos7 ~]# docker service ls
ID             NAME         MODE         REPLICAS   IMAGE           PORTS
yylj6zzfzk8b   helloworld   replicated   1/1        alpine:latest   

[root@centos7 ~]# docker service ps helloworld
ID             NAME           IMAGE           NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS
mfltocpqgdut   helloworld.1   alpine:latest   centos7.6   Running         Running 13 minutes ago  
```

 查看 helloworld 部署的具体信息： 

```shell
[root@centos7 ~]# docker service inspect --pretty helloworld

ID:		yylj6zzfzk8bkdnoi3rguiwur
Name:		helloworld
Service Mode:	Replicated
 Replicas:	1
Placement:
UpdateConfig:
 Parallelism:	1
 On failure:	pause
 Monitoring Period: 5s
 Max failure ratio: 0
 Update order:      stop-first
RollbackConfig:
 Parallelism:	1
 On failure:	pause
 Monitoring Period: 5s
 Max failure ratio: 0
 Rollback order:    stop-first
ContainerSpec:
 Image:		alpine:latest@sha256:826f70e0ac33e99a72cf20fb0571245a8fee52d68cb26d8bc58e53bfa65dcdfa
 Args:		ping docker.com 
 Init:		false
Resources:
Endpoint Mode:	vip

```



##### 扩展集群服务

 我们将上述的 helloworld 服务扩展到俩个节点 

```shell
[root@centos7 ~]# docker service scale helloworld=2
helloworld scaled to 2
overall progress: 2 out of 2 tasks 
1/2: running   [==================================================>] 
2/2: running   [==================================================>] 
verify: Service converged 

```

 可以看到已经从一个节点，扩展到两个节点。 

```shell
[root@centos7 ~]# docker service ps helloworld
ID             NAME           IMAGE           NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS
mfltocpqgdut   helloworld.1   alpine:latest   centos7.6   Running         Running 18 minutes ago             
wn03wy76dca1   helloworld.2   alpine:latest   centos7.6   Running         Running 11 seconds ago  
```



##### 滚动升级服务

以下实例，我们将介绍 redis 版本如何滚动升级至更高版本。

创建一个 3.0.6 版本的 redis。

```shell
# 创建一个 3.0.6 版本的 redis
[root@centos7 ~]# docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6
k7qmuho6du8dwigie8xdmpc3p
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================>] 
verify: Service converged 
[root@centos7 ~]# docker service ps redis
ID             NAME      IMAGE         NODE        DESIRED STATE   CURRENT STATE                ERROR     PORTS
dxhieyft4imm   redis.1   redis:3.0.6   centos7.6   Running         Running about a minute ago  

# 滚动升级到3.0.7
[root@centos7 ~]# docker service update --image redis:3.0.7 redis
redis
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================>] 
verify: Service converged 
[root@centos7 ~]# docker service ps redis
ID             NAME          IMAGE         NODE        DESIRED STATE   CURRENT STATE             ERROR     PORTS
ec4d0jibxyqc   redis.1       redis:3.0.7   centos7.6   Running         Running 10 seconds ago  

# 3.0.6版本已经关闭
dxhieyft4imm    \_ redis.1   redis:3.0.6   centos7.6   Shutdown        Shutdown 32 seconds ago   

```

##### 停止某个节点接收新的任务

查看所有节点：

```shell
[root@centos7 ~]# docker service ps redis
ID             NAME          IMAGE         NODE        DESIRED STATE   CURRENT STATE             ERROR     PORTS
ec4d0jibxyqc   redis.1       redis:3.0.7   centos7.6   Running         Running 10 seconds ago              
dxhieyft4imm    \_ redis.1   redis:3.0.6   centos7.6   Shutdown        Shutdown 32 seconds ago             
[root@centos7 ~]# docker node ls
ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
hysfcctzxx9ynostnteckbf2d *   centos7.6   Ready     Active         Leader           20.10.5
qcwp4esjjfpd37ve2snjhc8mv     centos7.6   Ready     Active                          20.10.5


```

可以看到目前所有的节点都是 Active, 可以接收新的任务分配。

停止节点 `qcwp4esjjfpd37ve2snjhc8mv(192.168.130.130)`：

```shell
[root@centos7 ~]# docker node update --availability drain qcwp4esjjfpd37ve2snjhc8mv 
qcwp4esjjfpd37ve2snjhc8mv
[root@centos7 ~]# docker node ls
ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
hysfcctzxx9ynostnteckbf2d *   centos7.6   Ready     Active         Leader           20.10.5
qcwp4esjjfpd37ve2snjhc8mv     centos7.6   Ready     Drain                           20.10.5
```

> 注意：节点 `qcwp4esjjfpd37ve2snjhc8mv(192.168.130.130)` 状态变为 **Drain**。不会影响到集群的服务，只是 swarm-worker1 节点不再接收新的任务，集群的负载能力有所下降。

如果工作节点（192.168.130.130）宕机了,其节点的状态为：`Down `

```shell
[root@centos7 ~]# docker node ls
ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
hysfcctzxx9ynostnteckbf2d *   centos7.6   Ready     Active         Leader           20.10.5
qcwp4esjjfpd37ve2snjhc8mv     centos7.6   Down      Active                          20.10.5

```









##### 激活节点

  可以通过以下命令重新激活节点:

```shell
[root@centos7 ~]# docker node update --availability active qcwp4esjjfpd37ve2snjhc8mv 
qcwp4esjjfpd37ve2snjhc8mv
[root@centos7 ~]# docker node ls
ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
hysfcctzxx9ynostnteckbf2d *   centos7.6   Ready     Active         Leader           20.10.5
qcwp4esjjfpd37ve2snjhc8mv     centos7.6   Ready     Active                          20.10.5

```



### Kubernetes

K8S，就是基于容器的集群管理平台



### Windows容器

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/1616781486886.png" alt="1616781486886" style="zoom:80%;" />



