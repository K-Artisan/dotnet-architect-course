[TOC]

[TOC]

# 1.论架构师的思维转变

## 1.1 到底什么是架构师

### 输出价值

架构师就是那个能把十强完整的做出来的人，能真正输出价值的那个人



### 组织业务

优秀的架构的衡量标准是解决业务问题的能力、支撑业务增长的能力



### 组织技术

追逐技术的深度，拓展技术的宽度

跟进最新的技术，从根本上明白技术是解决什么问题的



### 组织人力

团队分工协作、部门协调沟通、需要高情商



### 组织全局、对外输出

最终，是靠架构师去规划、安排、协调，把一件事能从无到有的推动，

从需求、研发、上线、运营全过程的把握。

是真正负责一件事的人。

## 1.2 向前一步，你就是架构师

不要因为是开发人员，就不去关注软件运维，

不要因为是开发人员，就不去关注测试，

不要因为是开发人员，就不去关注运营，

关注越多，越能看清全局的价值目标。

试着转变思维，从架构师的角度思考价值问题，

看看能否将技术贯穿到业务、用户、最终的价值，

做一个真正解决问题的人。

### 发现问题

### 对待问题

### 解决问题



## 1.3 架构师的思维

### 技术的深度

 做到知其所然，知其所以然

### 技术的广度

跳出舒适区去学习新的技术

### 系统思维

不仅是解决宴请的问题，而是解决问题的根源

### 体系思维

一个人是打不赢一场战争的



# 2.CLR核心机制

## 2.1 什么是堆栈

**栈**和**堆**（托管堆）都是存在于进程的虚拟内存中，为程序运行提供存储空间。

- 栈（Stack）是操作系统在建立线程时，为这个线程建立的存储区域。

- 堆（Heap）是应用程序在运行时请求操作系统分配给自己的内存，是申请给予的过程。

  由于从操作系统管理的内存分配，分配和销毁时都占用时间，所以使用堆效率低

### 栈(Stack）

- 栈中存储值类型
- 栈是先进后出
- 栈是自维护，党员数不再被使用会被抛弃
- 栈空间较小，访问速度快

### 堆(Heap）

- 存储引用类型
- 受垃圾处理器GC管理
- 没有访问限制，按地址索引
- 控件较大，访问速度没有栈快

## 2.2 C#堆栈如何分配

- 值类型分配在栈上

- 引用类型分配在堆上

- 值类型里面的引用类型？-->引用类型一定在堆里

- 引用类型里面的值类型？-->值类型会随着对象而存在



## 2.3 引用类型new对象是发生了什么？

1. 调用new的时候 就会去栈上面开辟内存，创建实例
2. 把实例的引用传递给构造函数
3. 执行构造函数
4. 返回引用



## 2.4 IL解析



| **Nop**      | **如果修补操作码，则填充空间。尽管可能消耗处理周期，但未执行任何有意义的操作。** |
| ------------ | ------------------------------------------------------------ |
| **Ret**      | 从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。 |
| **Ldstr**    | 推送对元数据中存储的字符串的新对象引用。                     |
| **Ldloca**   | 将位于特定索引处的局部变量的地址加载到计算堆栈上。           |
| **Ldloca.S** | 将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。 |
| **Ldc.I4.S** | 将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。      |
| **Stfld**    | 用新值替换在对象引用或指针的字段中存储的值。                 |
| **Ldloc.0**  | 将索引 0 处的局部变量加载到计算堆栈上。                      |
| **Ldfld**    | 查找对象中其引用当前位于计算堆栈的字段的值。                 |
| **Ldflda**   | 查找对象中其引用当前位于计算堆栈的字段的地址。               |
| **Stloc**    | 从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。 |

```C#
    public class Student
    {
        public string Name { get; private set; }

        public int Tag;// { get; set; }

        public Student(string name)
        {
            this.Name = name;
        }
        public void Show()
        {
            int iNum = 0;
            Console.WriteLine($"This is {this.Name} {iNum} show!");
        }
    }
```



```C#
    public class StackHeapTest
    {
        ......
        private static void Show2()
        {
            Student student = new Student("晓风灿月");
            //1 先声明  晓风灿月
            //2 计算空间-开辟空间-
            //3 返回引用地址，通过地址就可以操作对象(才有this)
            //4 才是调用构造函数--构造函数只是为了初始化的
            //5 构造函数返回引用
            student.Tag = 2;
            student.Show();
        }
        ......
```

通过反编译工具[ILSpy](https://github.com/icsharpcode/ILSpy)，查看上述的**C#**代码被编译成**IL**语言如下：

```IL
	.method private hidebysig static 
		void Show2 () cil managed 
	{
		// Method begins at RVA 0x21fc
		// Code size 27 (0x1b)
		.maxstack 2
		.locals init (
			[0] class Zhaoxi.ArchitectBattalion.CLRDemo.Student student
		)

		// {
		IL_0000: nop
		// Student student = new Student("晓风灿月");
		IL_0001: ldstr "晓风灿月"
		IL_0006: newobj instance void Zhaoxi.ArchitectBattalion.CLRDemo.Student::.ctor(string)
		IL_000b: stloc.0
		// student.Tag = 2;
		IL_000c: ldloc.0
		IL_000d: ldc.i4.2
		IL_000e: stfld int32 Zhaoxi.ArchitectBattalion.CLRDemo.Student::Tag
		// student.Show();
		IL_0013: ldloc.0
		IL_0014: callvirt instance void Zhaoxi.ArchitectBattalion.CLRDemo.Student::Show()
		// }
		IL_0019: nop
		IL_001a: ret
	} // end of method StackHeapTest::Show2
```



## 2.5 装箱和拆箱

```C#
       private static void Show4()
        {
            int i = 3;
            object k = i;
            int m = (int)k;

            Console.WriteLine($"{i} {k} {m}");
        }
```

IL:

```C#
	.method private hidebysig static 
		void Show4 () cil managed 
	{
		// Method begins at RVA 0x2250
		// Code size 47 (0x2f)
		.maxstack 4
		.locals init (
			[0] int32 i,
			[1] object k,
			[2] int32 m
		)

		// {
		IL_0000: nop
		// int num = 3;
		IL_0001: ldc.i4.3
		IL_0002: stloc.0
		// object obj = num;
		IL_0003: ldloc.0
		IL_0004: box [System.Runtime]System.Int32
		IL_0009: stloc.1
		// int num2 = (int)obj;
		IL_000a: ldloc.1
		IL_000b: unbox.any [System.Runtime]System.Int32
		IL_0010: stloc.2
		// Console.WriteLine($"{num} {obj} {num2}");
		IL_0011: ldstr "{0} {1} {2}"
		IL_0016: ldloc.0
		IL_0017: box [System.Runtime]System.Int32
		IL_001c: ldloc.1
		IL_001d: ldloc.2
		IL_001e: box [System.Runtime]System.Int32
		IL_0023: call string [System.Runtime]System.String::Format(string, object, object, object)
		IL_0028: call void [System.Console]System.Console::WriteLine(string)
		// }
		IL_002d: nop
		IL_002e: ret
	} // end of method StackHeapTest::Show4
```

装箱拆箱消耗性能



## 2.6 字符串

```c#
        private static void Show5()
        {
            string student = "到下个路口";//堆里面
            string studentCopy = student;

            string people = "到下个路口";//堆里面
            Console.WriteLine(object.ReferenceEquals(student, studentCopy));
            Console.WriteLine(object.ReferenceEquals(student, people));
            //2个答案  T/F T/F        TT  C#内存分配的享元模式

            studentCopy = "love佳";
            Console.WriteLine($"{student} {people}");
            //2个答案   路口  佳佳    都是路口  字符串不可变性，不会修改只会新增

            //引用类型在堆上面---堆的空间有限---连续摆放---字符串长短--都会导致大量内存移动--而且要锁定线程---成本太高---OCP---进而就可以享元模式了--节约空间
        }
```

```C#
        private static void Show6()
        {
            string student1 = "雷电法王";
            string student2 = "雷电法王";
            string student3 = "雷电" + "法王";
            string part = "法王";
            string student31 = "雷电" + part;
            string student4 = string.Format("雷电{0}", "法王");
            StringBuilder sb = new StringBuilder();
            sb.Append("雷电");
            sb.Append("法王");
            string student5 = sb.ToString();
            string student6 = $"{"雷电"}{"法王"}";
            string student7 = $"{"雷电"}{part}";
            Console.WriteLine($"{object.ReferenceEquals(student1, student2)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student3)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student31)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student4)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student5)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student6)}");
            Console.WriteLine($"{object.ReferenceEquals(student1, student7)}");
            //6个答案   T /F     TTFFFTF
        }
```



## 2.7 垃圾回收GC

内存是有上限的，不可能无止境的分配空间，
因此就产生了GC(Garbage Collector)的需求 .

1. 提高了软件开发的抽象度；
2. 程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；
   可以使模块的接口更加的清晰，减小模块间的偶合；
3. 大大减少了内存人为管理不当所带来的Bug；
4. 使内存管理更加高效。

总的说来就是GC可以使程序员可以从复杂的内存问题中摆脱出来，从而提高了软件开发的速度、质量和安全性。



### 2.7.1 什么样的对象需要垃圾回收

1 托管资源
2 存在堆里(含值类型+引用类型)

**托管资源**一般是指被CLR控制的内存资源,这些资源的管理可以由CLR来控制,例如程序中分配的对象,作用域内的变量等，大部分对象都是托管资源。

**非托管资源**是CLR不能控制或者管理的部分，这些资源有很多，比如文件流，数据库的连接，系统的窗口句柄，打印机资源，需要调用Dispose方法

### 2.7.2 堆资源是怎么分配的

![image-20201119022100760](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119022100760.png)



###  2.7.3 Mark-Compact 标记压缩算法

**阶段1**: Mark-Sweep 标记清除阶段，先假设堆（heap）中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；

**阶段2:** Compact 压缩阶段，对象回收之后堆（heap）内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。

![image-20201119022153102](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119022153102.png)



### 2.7.4 Timer怪事

只有显示释放计时器，才能活到被释放的那一刻！

```C#
    public class GCTest
    {
        public static void Show()
        {
            System.Threading.Timer timer1 = new System.Threading.Timer(Timer_Elapsed_Thread, null, 0, 2000);
            //System.Timers.Timer timer = new System.Timers.Timer(1000 * 10);
            //timer.Elapsed += Timer_Elapsed;
            //timer.Start();
            Console.WriteLine("输入任意字符结束timer！");
            Console.Read();
        }
        private static void Timer_Elapsed_Thread(object sender)
        {
            Thread.Sleep(100);
            Console.WriteLine($"This is Timer_Thread Invoke....{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff")}");
            GC.Collect(0);//后面大家都研究下，为什么GC时，timer1没有被回收！ 可以在旧版本也试试---大家一起动手
        }

        private static void Timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            Thread.Sleep(100);
            Console.WriteLine($"This is Timer Invoke....{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss fff")}");
            GC.Collect();
        }
    }
```



### 2.7.5 三个假设

对象越新，生存期越短；
对象越老，生存期越长；
回收部分资源，快过全部回收。



### 2.7.6 分代策略

![image-20201119023836762](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119023836762.png)

第1次，遍历全部对象，找出没有引用的，删除，剩下1代
第2次，遍历0代对象，找出没有引用的，删除，剩下升级1代
             如果还不够空间，才会遍历1代，没有引用的删除，
             还在被使用的，升级为2代。都不够才会检查2代

  

**各代空间大小？**

实际上是没有具体值的，由CLR管理。
初始化时就会给出0代/1代的预算，然后动态调节！
GC后，对象几乎没有留存，那么就会减小预算，
加快回收频率，每次速度快

如果GC后有很多对象留存，那么就会增加预算，
降低回收频率，每次回收内容多

如果空间不够，就会全面回收，再不够就OutOfMemory了



### 2.7.7 什么时候GC

new对象时--临界点
Windows报告内存不够
GC.Collect 强制GC
程序退出或者卸载AppDomain



### 2.7.8 怎么用GC. Collect

大多数情况下，应该让GC自己决定回收时间，以更好的控制各代预算，也避免GC降低响应

如果知道大量对象无效，可以手动GC，尤其是2代



### 2.7.9 大对象策略

85000字节为限
独立的地址空间
不会移动压缩大对象，成本高，但也造成了碎片
大对象总是2代对象



### 2.7.10 垃圾回收模式

- 工作站：单线程回收

- 服务器：多区域并行回收



![image-20201119025151433](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119025151433.png)



# 3.O/RM 探究

## 3.1 什么是O/RM

对象-关系映射（OBJECT/RELATION MAPPING）

对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。



## 3.2 O/RM框架

![image-20201119030935104](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119030935104.png)



## 3.3 O/RM的基本功能

- CRUD的API：通用增删改查
- 自定义查询：表达式目录树
- MAPPING METADATA：自动映射实现机制
- 事务、延迟、缓存等：O/RM进阶特性实现



## 3.4 手写O/RM简易框架

### 通用查询

`SqlHelper.cs`

```c#
        public T Find<T>(int id)
        {
            Type type = typeof(T);

            string columsString = string.Join(",", type.GetProperties().Select(p => $"[{p.Name}]"));
            string sql = $"select {columsString} from [{type.Name}] where id={id}";
            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.Name]);
                    }

                    return t;
                }
            }

            return default(T);
        }
    }
```



### 配置文件管理

`ConfigurationManager.cs`

```c#
using Microsoft.Extensions.Configuration;
using System.IO;

namespace Orm.Common
{
    public class ConfigurationManager
    {
        private static string _sqlConnectionString = null;
        public static string SqlConnectionString
        {
            get
            {
                return _sqlConnectionString;
            }
        }

        static ConfigurationManager()
        {
            var builder = new ConfigurationBuilder()
                       .SetBasePath(Directory.GetCurrentDirectory())
                       .AddJsonFile("appsettings.json");

            IConfigurationRoot configuration = builder.Build();
            _sqlConnectionString = configuration["connectionString"];

        }
    }
}
```



### 用特性(Attribute)作数据库映射

#### 定义映射特性

`MappingAttribute.cs`

```c#
    public class MappingAttribute : Attribute
    {
        private string _Name = null;
        public MappingAttribute(string name)
        {
            this._Name = name;
        }

        public string GetName()
        {
            return this._Name;
        }
    }
```

`TableAttribute.cs`

```C#
    /// <summary>
    /// 做表名称的别名
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public class TableAttribute : MappingAttribute
    {
        public TableAttribute(string tableName) : base(tableName)
        {

        }
    }
```



`ColumAttribute.cs`

```C#
    public class ColumnAttribute : MappingAttribute
    {
        public ColumnAttribute(string columnName) : base(columnName)
        {

        }
    }
```



`MappingExtend.cs`

```C#
    public static class MappingExtend
    {
        public static string GetTableName(this Type type)
        {
            if (type.IsDefined(typeof(TableAttribute), true))
            {
                TableAttribute attribute = type.GetCustomAttribute<TableAttribute>();
                return attribute.GetName();
            }
            else
            {
                return type.Name;
            }
        }

        public static string GetMappingName(this MemberInfo member)
        {
            if (member.IsDefined(typeof(MappingAttribute), true))
            {
                MappingAttribute attribute = member.GetCustomAttribute<MappingAttribute>();
                return attribute.GetName();
            }
            else
            {
                return member.Name;
            }
        }

        public static string GetColumnName(this PropertyInfo prop)
        {
            if (prop.IsDefined(typeof(ColumnAttribute), true))
            {
                ColumnAttribute attribute = prop.GetCustomAttribute<ColumnAttribute>();
                return attribute.GetName();
            }
            else
            {
                return prop.Name;
            }
        }
    }
```

#### 使用映射特性

`Company.cs`

```C#
    /// <summary>
    /// 数据库中表名Company  但是程序是CompanyModel
    /// </summary>
    [Table("Company")]
    public class CompanyModel : BaseEntity
    {
        [Column("Name")]
        public string CompanyName { get; set; }

        ......
    }
```



#### 改造查询语句

`SqlHelper.cs`

```C#
    public class SqlHelper
    {
        public T Find<T>(int id)  where T : BaseEntity
        {
            Type type = typeof(T);

            string columsString = string.Join(",", type.GetProperties().Select(p => $"[{p.GetColumnName()}]"));
            string sql = $"select {columsString} from [{type.GetTableName()}] where id={id}";
            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {      ......
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                   ......
            }
           ......
        }
    }
```

- `type.GetTableName()`获取映射的数据库**表名**
- `p.GetColumnName()`获取映射的数据库**列名**

### 查询部分字段

要实现如下查询：

```c#
UserDto userDto = helper.Find<User, UserDto>(1);
```

其中，`UserDto`只包含`User`类的部分字段，并且`User`中的`Name`字段对应`UserDto`中的`UserName`字段

```c#
    public class UserDto
    {
        public int id { get; set; }

        [Column("Name")]
        public string UserName { get; set; }

    }
```

`SqlHelper.cs`

```c#
        /// <summary>
        /// 查询部分字段
        /// </summary>
        /// <typeparam name="E">数据库映射Model类</typeparam>
        /// <typeparam name="D">Dto类型</typeparam>
        /// <param name="id">id</param>
        /// <returns>Dto类型</returns>
        public D Find<E,D>(int id) where E : BaseEntity
        {
            Type modleType = typeof(E);
            Type dtoType = typeof(D);

            string columsString = string.Join(",", dtoType.GetProperties().Select(p => $"[{p.GetColumnName()}]"));
            string sql = $"select {columsString} from [{modleType.GetTableName()}] where id={id}";

            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectiongString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    D dto = (D)Activator.CreateInstance<D>();
                    foreach (var prop in dtoType.GetProperties())
                    {
                        prop.SetValue(dto, reader[prop.GetColumnName()]);
                    }

                    return dto;
                }
            }

            return default(D);
        }
```



### 插入

实现如下插入操作：

```C#
   CompanyModel company1 = helper.Find<CompanyModel>(1);
   helper.Insert<CompanyModel>(company1);
```

```c#
        public bool Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T);
         /*
            string columnsString = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"[{p.GetMappingName()}]"));
            string valuesString = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"@{p.GetMappingName()}"));
            var insertSql = $"INSERT INTO [{type.GetMappingName()}] ({columnsString}) VALUES({valuesString});";
         */
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            using (SqlConnection conn = new SqlConnection(ConfigurationManager.SqlConnectionString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                int iResult = command.ExecuteNonQuery();
                return iResult == 1;
            }
        }
```

```c#
    public static class FilterExtend
    {
        /// <summary>
        /// 过滤掉主键 返回全部属性
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static IEnumerable<PropertyInfo> GetPropertiesWithoutKey(this Type type)
        {
            return type.GetProperties().Where(p => !p.IsDefined(typeof(KeyAttribute), true));
        }
    }
```

### 更新

```c#
        public int Update<T>(T t) where T : BaseModel, new()
        {
            if (!t.Validate<T>())
            {
                throw new Exception("数据校验没有通过");//大家可以再返回点提示信息
            }

            Type type = t.GetType();
            string stringSet = string.Join(",", type.GetPropertiesWithoutKey().Select(p => $"{p.GetMappingName()}=@{p.Name}"));
            string sql = $"UPDATE [{type.GetMappingName()}] SET {stringSet} WHERE Id=@Id;";
            //string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(p => new SqlParameter($"@{p.Name}", p.GetValue(t) ?? DBNull.Value)).ToArray();

            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                return command.ExecuteNonQuery();
            }
        }

        //按需更新--界面上只修改了几个字段--大家有什么思路，可以自己动手，然后show出来
        //1 传递一个列表---实体三个属性  字段名称--操作符--值
        //2 改造成json---{"Name":"zzzz","Password":"123245"}
        public int Update<T>(string json, int id) where T : BaseModel, new()
        {
            Type type = typeof(T);
            T t = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(json);//JObject
            string stringSet = string.Join(",", type.GetPropertiesInJson(json).Select(p => $"{p.GetMappingName()}=@{p.Name}"));
            string sql = $"UPDATE {type.GetMappingName()} SET {stringSet} WHERE Id=@Id;";

            var paraArray = type.GetPropertiesInJson(json).Select(p => new SqlParameter($"@{p.Name}", p.GetValue(t) ?? DBNull.Value)).Append(new SqlParameter("@Id", id)).ToArray();
            
            //return type.GetProperties().Where(p => json.Contains($"'{p.Name}':") || json.Contains($"\"{p.Name}\":"));
            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                return command.ExecuteNonQuery();
            }
        }
```

#### 部分更新

```C#
               SqlHelper helper = new SqlHelper();
                string updateJson = Newtonsoft.Json.JsonConvert.SerializeObject(
                        new
                        {
                            CompanyName = "kkk",
                            LastModifyTime = DateTime.Now
                        }
                    ); ;
     
                helper.Update<CompanyModel>(updateJson, 5);
```



#### 数据校验

- 定义数据校验特性，抽象基类`ValidateAttribute : Attribute`：

```C#
    [AttributeUsage(AttributeTargets.Property)]
    public abstract class ValidateAttribute : Attribute
    {
        public abstract bool Validate(object oValue);
    }
```

- int类型值范围

`IntAttribute`.cs

```C#
        private int _Min = 0;
        private int _Max = 0;
        public IntAttribute(int min, int max)
        {
            this._Min = min;
            this._Max = max;
        }

        public override bool Validate(object oValue)
        {
            return oValue != null
                && oValue.ToString().Length >= this._Min
                && oValue.ToString().Length <= this._Max;
        }
    }
```

- 长度

  ```C#
      public class LengthAttribute : ValidateAttribute
      {
          private int _Min = 0;
          private int _Max = 0;
          public LengthAttribute(int min, int max)
          {
              this._Min = min;
              this._Max = max;
          }
  
          public override bool Validate(object oValue)
          {
              return oValue != null
                  && oValue.ToString().Length >= this._Min
                  && oValue.ToString().Length <= this._Max;
          }
      }
  ```

  

- 值不能为Null

  ```C#
      public class RequiredAttribute : ValidateAttribute
      {
          public override bool Validate(object oValue)
          {
              return oValue != null && !string.IsNullOrWhiteSpace(oValue.ToString());
          }
      }
  ```

 

- 数据扩展方法

  ```C#
   public static class ValidateExtend
      {
          public static bool Validate<T>(this T t)
          {
              Type type = t.GetType();
              foreach (var prop in type.GetProperties())
              {
                  if (prop.IsDefined(typeof(ValidateAttribute), true))
                  {
                      object oValue = prop.GetValue(t);
                      var attributeArray = prop.GetCustomAttributes<ValidateAttribute>();
                      foreach (var attribute in attributeArray)
                      {
                          if (attribute.Validate(oValue))
                          {
                              //继续
                          }
                          else
                          {
                              return false;
                          }
                      }
                  }
              }
              return true;
          }
      }
  ```

- 使用校验特性

  ```c#
  using Orm.Framework.SqlDataValidate;
  using Orm.Framework.SqlMapping;
  using System;
  
  namespace Orm.Model
  {
      [Table("Company")]
      public class CompanyModel : BaseEntity
      {
          [Column("Name")]
          [Required, Length(4, 14)]
          public string CompanyName { get; set; }
  
          public DateTime CreateTime { get; set; }
  
          [Int(1, 999999999)]
          public int CreatorId { get; set; }
  
          public Nullable<int> LastModifierId { get; set; }
  
          public DateTime? LastModifyTime { get; set; }
      }
  }
  ```

  

- 在插入或更新时，使用校验

```C#
        public int Update<T>(T t) where T : BaseEntity, new()
        {
            if (!t.Validate<T>())
            {
                throw new Exception("数据校验没有通过");//大家可以再返回点提示信息
            }
            ......
        }
```

- `main.cs`

  ```C#
                  SqlHelper helper = new SqlHelper();
                  CompanyModel company = helper.Find<CompanyModel>(1);
                  company.CompanyName = "";
                  helper.Update<CompanyModel>(company);
  ```

  输出：

  ```md
  "数据校验没有通过"
  ```

  

###  删除

```c#
        public bool Delete<T>(T t) where T : BaseModel, new()
        {
            Type type = t.GetType();
            string sql = $"DELETE FROM [{type.GetMappingName()}] WHERE Id=@Id;";
            var paraArray = new SqlParameter[] { new SqlParameter("@Id", t.Id) };

            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                //var trans = conn.BeginTransaction();
                //trans.Commit();
                //trans.Rollback();
                return 1 == command.ExecuteNonQuery();
            }
        }
```



### 条件查询

实现如下查询：

```c#
     SqlHelper helper = new SqlHelper();
     var companys = helper.FindCondition<CompanyModel>(c => c.Id > 10);
```

使用表达式树解析出`sql`的中`where`语句，做法如下：

```C#
        public IList<T> FindCondition<T>(Expression<Func<T, bool>> func) where T : BaseEntity, new()
        {
            Type type = typeof(T);
            string columnsString = string.Join(",", type.GetProperties().Select(p => $"[{p.GetMappingName()}]"));
            string where = func.ToWhere<T>(out List<SqlParameter> parameters);
            string sql = $"SELECT {columnsString} FROM [{type.GetMappingName()}] WHERE {where}";
            string connString = SqlConnectionPool.GetConnectionString(SqlConnectionPool.SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connString}");
            using (SqlConnection conn = new SqlConnection(connString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(parameters.ToArray());
                conn.Open();
                var reader = command.ExecuteReader();
                IList<T> result = new List<T>();
                while (reader.Read())
                {
                    T t = new T();
                    foreach (var prop in type.GetProperties())
                    {
                        string propName = prop.GetMappingName();
                        prop.SetValue(t, reader[propName] is DBNull ? null : reader[propName]);
                    }
                    result.Add(t);
                }
                return result;
            }
        }
```

其中，关键语句如下，

```C#
 string where = func.ToWhere<T>(out List<SqlParameter> parameters);
```

将`Larmda`表达式解析为`wher`语句并获取参数列表



`ExpressionHelper.cs`

```c
    public static class ExpressionHelper
    {
        public static string ToWhere<T>(this Expression<Func<T, bool>> expression, out List<SqlParameter> sqlParameters)
        {
            CustomExpressionVisitor visitor = new CustomExpressionVisitor();
            visitor.Visit(expression);
            string where = visitor.GetWhere(out sqlParameters);
            return where;
        }
    }
```

`CustomExpressionVisitor.cs`

```c#
public class CustomExpressionVisitor : ExpressionVisitor
    {
        private Stack<string> ConditionStack = new Stack<string>();
        //id>10    id>@Id    sqlparameter(@id,10)
        private List<SqlParameter> _SqlParameterList = new List<SqlParameter>();
        private object _TempValue = null;


        public string GetWhere(out List<SqlParameter> sqlParameters)
        {
            string where = string.Concat(this.ConditionStack.ToArray());
            this.ConditionStack.Clear();
            sqlParameters = _SqlParameterList;
            return where;
        }


        public override Expression Visit(Expression node)
        {
            Console.WriteLine($"Visit入口：{node.NodeType} {node.Type} {node.ToString()}");
            return base.Visit(node);
        }

        protected override Expression VisitBinary(BinaryExpression node)
        {
            Console.WriteLine($"VisitBinary：{node.NodeType} {node.Type} {node.ToString()}");
            this.ConditionStack.Push(" ) ");
            base.Visit(node.Right);
            this.ConditionStack.Push(node.NodeType.ToSqlOperator());
            base.Visit(node.Left);
            this.ConditionStack.Push(" ( ");
            return node;
        }

        protected override Expression VisitConstant(ConstantExpression node)
        {
            Console.WriteLine($"VisitConstant：{node.NodeType} {node.Type} {node.ToString()}");
            //this.ConditionStack.Push($"'{node.Value.ToString()}'");
            this._TempValue = node.Value;
            //栈里面不要值，要的是@PropertyName,但是从后往前，先有值再有属性--但是二者是连续的
            return node;
        }

        protected override Expression VisitMember(MemberExpression node)
        {
            Console.WriteLine($"VisitMember：{node.NodeType} {node.Type} {node.ToString()}");
            //this.ConditionStack.Push($"{node.Member.GetMappingName()}");
            if (node.Expression is ConstantExpression)
            {
                var value1 = this.InvokeValue(node);
                var value2 = this.ReflectionValue(node);
                //this.ConditionStack.Push($"'{value1}'");
                this._TempValue = value1;
            }
            else
            {
                //this.ConditionStack.Push($"{node.Member.Name}");
                //this.ConditionStack.Push($"{node.Member.GetMappingName()}");//映射数据
                if (this._TempValue != null)
                {
                    string name = node.Member.GetMappingName();
                    string paraName = $"@{name}{this._SqlParameterList.Count}";
                    string sOperator = this.ConditionStack.Pop();
                    this.ConditionStack.Push(paraName);
                    this.ConditionStack.Push(sOperator);
                    this.ConditionStack.Push(name);

                    var tempValue = this._TempValue;
                    this._SqlParameterList.Add(new SqlParameter(paraName, tempValue));
                    this._TempValue = null;
                }
            }
            return node;
        }

        private object InvokeValue(MemberExpression member)
        {
            var objExp = Expression.Convert(member, typeof(object));//struct需要
            return Expression.Lambda<Func<object>>(objExp).Compile().Invoke();
        }

        private object ReflectionValue(MemberExpression member)
        {
            var obj = (member.Expression as ConstantExpression).Value;
            return (member.Member as FieldInfo).GetValue(obj);
        }

        protected override Expression VisitMethodCall(MethodCallExpression m)
        {
            if (m == null) throw new ArgumentNullException("MethodCallExpression");

            this.Visit(m.Arguments[0]);
            string format;
            switch (m.Method.Name)
            {
                case "StartsWith":
                    format = "({0} LIKE {1}+'%')";
                    break;

                case "Contains":
                    format = "({0} LIKE '%'+{1}+'%')";
                    break;

                case "EndsWith":
                    format = "({0} LIKE '%'+{1})";
                    break;

                default:
                    throw new NotSupportedException(m.NodeType + " is not supported!");
            }
            this.ConditionStack.Push(format);
            this.Visit(m.Object);
            string left = this.ConditionStack.Pop();
            format = this.ConditionStack.Pop();
            string right = this.ConditionStack.Pop();
            this.ConditionStack.Push(String.Format(format, left, right));

            return m;
        }
    }
```

#### 表达式树

[表达式树 (C#)](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/)

[修改表达式树](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-modify-expression-trees)

[如何使用表达式树来生成动态查询 (C#)](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-use-expression-trees-to-build-dynamic-queries)

https://www.cnblogs.com/wolf-sun/p/4234747.html#t1

https://www.cnblogs.com/snailblog/p/11521043.html

#### ExpressionVisitor抽象类源码

此类继承自`ExpressionVisitor`类，此类是`expression`表达式的工具类，可对`expression`表达式内部的成员进行替换

[修改表达式树](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/how-to-modify-expression-trees)

```C#

//http://blogs.msdn.com/b/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx
public abstract class ExpressionVisitor
    {
        protected virtual Expression Visit(Expression exp)
        {
            if (exp == null)
                return exp;
            switch (exp.NodeType)
            {
                case ExpressionType.Negate:
                case ExpressionType.NegateChecked:
                case ExpressionType.Not:
                case ExpressionType.Convert:
                case ExpressionType.ConvertChecked:
                case ExpressionType.ArrayLength:
                case ExpressionType.Quote:
                case ExpressionType.TypeAs:
                    return this.VisitUnary((UnaryExpression)exp);
                case ExpressionType.Add:
                case ExpressionType.AddChecked:
                case ExpressionType.Subtract:
                case ExpressionType.SubtractChecked:
                case ExpressionType.Multiply:
                case ExpressionType.MultiplyChecked:
                case ExpressionType.Divide:
                case ExpressionType.Modulo:
                case ExpressionType.And:
                case ExpressionType.AndAlso:
                case ExpressionType.Or:
                case ExpressionType.OrElse:
                case ExpressionType.LessThan:
                case ExpressionType.LessThanOrEqual:
                case ExpressionType.GreaterThan:
                case ExpressionType.GreaterThanOrEqual:
                case ExpressionType.Equal:
                case ExpressionType.NotEqual:
                case ExpressionType.Coalesce:
                case ExpressionType.ArrayIndex:
                case ExpressionType.RightShift:
                case ExpressionType.LeftShift:
                case ExpressionType.ExclusiveOr:
                    return this.VisitBinary((BinaryExpression)exp);
                case ExpressionType.TypeIs:
                    return this.VisitTypeIs((TypeBinaryExpression)exp);
                case ExpressionType.Conditional:
                    return this.VisitConditional((ConditionalExpression)exp);
                case ExpressionType.Constant:
                    return this.VisitConstant((ConstantExpression)exp);
                case ExpressionType.Parameter:
                    return this.VisitParameter((ParameterExpression)exp);
                case ExpressionType.MemberAccess:
                    return this.VisitMemberAccess((MemberExpression)exp);
                case ExpressionType.Call:
                    return this.VisitMethodCall((MethodCallExpression)exp);
                case ExpressionType.Lambda:
                    return this.VisitLambda((LambdaExpression)exp);
                case ExpressionType.New:
                    return this.VisitNew((NewExpression)exp);
                case ExpressionType.NewArrayInit:
                case ExpressionType.NewArrayBounds:
                    return this.VisitNewArray((NewArrayExpression)exp);
                case ExpressionType.Invoke:
                    return this.VisitInvocation((InvocationExpression)exp);
                case ExpressionType.MemberInit:
                    return this.VisitMemberInit((MemberInitExpression)exp);
                case ExpressionType.ListInit:
                    return this.VisitListInit((ListInitExpression)exp);
                default:
                    throw new Exception(string.Format("Unhandled expression type: '{0}'", exp.NodeType));
            }
        }

        protected virtual MemberBinding VisitBinding(MemberBinding binding)
        {
            switch (binding.BindingType)
            {
                case MemberBindingType.Assignment:
                    return this.VisitMemberAssignment((MemberAssignment)binding);
                case MemberBindingType.MemberBinding:
                    return this.VisitMemberMemberBinding((MemberMemberBinding)binding);
                case MemberBindingType.ListBinding:
                    return this.VisitMemberListBinding((MemberListBinding)binding);
                default:
                    throw new Exception(string.Format("Unhandled binding type '{0}'", binding.BindingType));
            }
        }

        protected virtual ElementInit VisitElementInitializer(ElementInit initializer)
        {
            ReadOnlyCollection<Expression> arguments = this.VisitExpressionList(initializer.Arguments);
            if (arguments != initializer.Arguments)
            {
                return Expression.ElementInit(initializer.AddMethod, arguments);
            }
            return initializer;
        }

        protected virtual Expression VisitUnary(UnaryExpression u)
        {
            Expression operand = this.Visit(u.Operand);
            if (operand != u.Operand)
            {
                return Expression.MakeUnary(u.NodeType, operand, u.Type, u.Method);
            }
            return u;
        }

        protected virtual Expression VisitBinary(BinaryExpression b)
        {
            Expression left = this.Visit(b.Left);
            Expression right = this.Visit(b.Right);
            Expression conversion = this.Visit(b.Conversion);
            if (left != b.Left || right != b.Right || conversion != b.Conversion)
            {
                if (b.NodeType == ExpressionType.Coalesce && b.Conversion != null)
                    return Expression.Coalesce(left, right, conversion as LambdaExpression);
                else
                    return Expression.MakeBinary(b.NodeType, left, right, b.IsLiftedToNull, b.Method);
            }
            return b;
        }

        protected virtual Expression VisitTypeIs(TypeBinaryExpression b)
        {
            Expression expr = this.Visit(b.Expression);
            if (expr != b.Expression)
            {
                return Expression.TypeIs(expr, b.TypeOperand);
            }
            return b;
        }

        protected virtual Expression VisitConstant(ConstantExpression c)
        {
            return c;
        }

        protected virtual Expression VisitConditional(ConditionalExpression c)
        {
            Expression test = this.Visit(c.Test);
            Expression ifTrue = this.Visit(c.IfTrue);
            Expression ifFalse = this.Visit(c.IfFalse);
            if (test != c.Test || ifTrue != c.IfTrue || ifFalse != c.IfFalse)
            {
                return Expression.Condition(test, ifTrue, ifFalse);
            }
            return c;
        }

        protected virtual Expression VisitParameter(ParameterExpression p)
        {
            return p;
        }

        protected virtual Expression VisitMemberAccess(MemberExpression m)
        {
            Expression exp = this.Visit(m.Expression);
            if (exp != m.Expression)
            {
                return Expression.MakeMemberAccess(exp, m.Member);
            }
            return m;
        }

        protected virtual Expression VisitMethodCall(MethodCallExpression m)
        {
            Expression obj = this.Visit(m.Object);
            IEnumerable<Expression> args = this.VisitExpressionList(m.Arguments);
            if (obj != m.Object || args != m.Arguments)
            {
                return Expression.Call(obj, m.Method, args);
            }
            return m;
        }

        protected virtual ReadOnlyCollection<Expression> VisitExpressionList(ReadOnlyCollection<Expression> original)
        {
            List<Expression> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                Expression p = this.Visit(original[i]);
                if (list != null)
                {
                    list.Add(p);
                }
                else if (p != original[i])
                {
                    list = new List<Expression>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(p);
                }
            }
            if (list != null)
            {
                return list.AsReadOnly();
            }
            return original;
        }

        protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
        {
            Expression e = this.Visit(assignment.Expression);
            if (e != assignment.Expression)
            {
                return Expression.Bind(assignment.Member, e);
            }
            return assignment;
        }

        protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
        {
            IEnumerable<MemberBinding> bindings = this.VisitBindingList(binding.Bindings);
            if (bindings != binding.Bindings)
            {
                return Expression.MemberBind(binding.Member, bindings);
            }
            return binding;
        }

        protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding binding)
        {
            IEnumerable<ElementInit> initializers = this.VisitElementInitializerList(binding.Initializers);
            if (initializers != binding.Initializers)
            {
                return Expression.ListBind(binding.Member, initializers);
            }
            return binding;
        }

        protected virtual IEnumerable<MemberBinding> VisitBindingList(ReadOnlyCollection<MemberBinding> original)
        {
            List<MemberBinding> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                MemberBinding b = this.VisitBinding(original[i]);
                if (list != null)
                {
                    list.Add(b);
                }
                else if (b != original[i])
                {
                    list = new List<MemberBinding>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(b);
                }
            }
            if (list != null)
                return list;
            return original;
        }

        protected virtual IEnumerable<ElementInit> VisitElementInitializerList(ReadOnlyCollection<ElementInit> original)
        {
            List<ElementInit> list = null;
            for (int i = 0, n = original.Count; i < n; i++)
            {
                ElementInit init = this.VisitElementInitializer(original[i]);
                if (list != null)
                {
                    list.Add(init);
                }
                else if (init != original[i])
                {
                    list = new List<ElementInit>(n);
                    for (int j = 0; j < i; j++)
                    {
                        list.Add(original[j]);
                    }
                    list.Add(init);
                }
            }
            if (list != null)
                return list;
            return original;
        }

        protected virtual Expression VisitLambda(LambdaExpression lambda)
        {
            Expression body = this.Visit(lambda.Body);
            if (body != lambda.Body)
            {
                return Expression.Lambda(lambda.Type, body, lambda.Parameters);
            }
            return lambda;
        }

        protected virtual NewExpression VisitNew(NewExpression nex)
        {
            IEnumerable<Expression> args = this.VisitExpressionList(nex.Arguments);
            if (args != nex.Arguments)
            {
                if (nex.Members != null)
                    return Expression.New(nex.Constructor, args, nex.Members);
                else
                    return Expression.New(nex.Constructor, args);
            }
            return nex;
        }

        protected virtual Expression VisitMemberInit(MemberInitExpression init)
        {
            NewExpression n = this.VisitNew(init.NewExpression);
            IEnumerable<MemberBinding> bindings = this.VisitBindingList(init.Bindings);
            if (n != init.NewExpression || bindings != init.Bindings)
            {
                return Expression.MemberInit(n, bindings);
            }
            return init;
        }

        protected virtual Expression VisitListInit(ListInitExpression init)
        {
            NewExpression n = this.VisitNew(init.NewExpression);
            IEnumerable<ElementInit> initializers = this.VisitElementInitializerList(init.Initializers);
            if (n != init.NewExpression || initializers != init.Initializers)
            {
                return Expression.ListInit(n, initializers);
            }
            return init;
        }

        protected virtual Expression VisitNewArray(NewArrayExpression na)
        {
            IEnumerable<Expression> exprs = this.VisitExpressionList(na.Expressions);
            if (exprs != na.Expressions)
            {
                if (na.NodeType == ExpressionType.NewArrayInit)
                {
                    return Expression.NewArrayInit(na.Type.GetElementType(), exprs);
                }
                else
                {
                    return Expression.NewArrayBounds(na.Type.GetElementType(), exprs);
                }
            }
            return na;
        }

        protected virtual Expression VisitInvocation(InvocationExpression iv)
        {
            IEnumerable<Expression> args = this.VisitExpressionList(iv.Arguments);
            Expression expr = this.Visit(iv.Expression);
            if (args != iv.Arguments || expr != iv.Expression)
            {
                return Expression.Invoke(expr, args);
            }
            return iv;
        }
    }
```





## 3.6 数据库事务

### 3.6.1 ACID

**A**  原子性--要么都成功 要么 都是失败，不会出现中间情况
		
**C**  一致性--数据在执行前后得满足一致性状态，数据得都是有效合法
	
**I**   隔离性--多个事务直接是互不影响的，看不到中间状态
		
**D**  持久性--只要成功了，就一定会固化下来



### 3.6.2 事务实现

- `SqlHelperDelay.cs`

```c#
    /// <summary>
    /// 实现延迟提交，模拟DbConte
    /// </summary>
    public class SqlHelperDelay : IDisposable
    {
        private IList<SqlCommand> _sqlCommandLIist = new List<SqlCommand>();
        
        public void Insert<T>(T entity) where T : BaseEntity
        {
            Type type = typeof(T);
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ).ToArray();

            SqlCommand command = new SqlCommand(sql);
            command.Parameters.AddRange(paraArray);

            _sqlCommandLIist.Add(command);
        }
        
        public void SaveChange()
        {
            string connectString = GetConnectionString(SqlConnectionType.Write);

            if (_sqlCommandLIist.Any())
            {
                using (SqlConnection conn = new SqlConnection(connectString))
                {
                    conn.Open();

                    using (SqlTransaction trans = conn.BeginTransaction())
                    {
                        try
                        {
                            foreach (var command in _sqlCommandLIist)
                            {
                                command.Connection = conn;
                                command.Transaction = trans;
                                command.ExecuteNonQuery();
                            }

                            trans.Commit();
                        }
                        catch (Exception)
                        {
                            trans.Rollback();
                            throw;
                        }
                        finally
                        {
                            _sqlCommandLIist.Clear();
                        }
                    }
                }
            }
        }
        
        public void Dispose()
        {
            _sqlCommandLIist.Clear();
        }
    }
```



1. 使用`private IList<SqlCommand> _sqlCommandLIist = new List<SqlCommand>();`存储的所有command`;

2. 然后在`SaveChange()`中使用同一个连接`conn`的同一个事务里面统一提交;

   

- 测试用例：

```c#
        [TestMethod]
        public void TestSaveChange_Transations_Exception()
        {
            try
            {
                using (SqlHelperDelay sqlHelperDelay = new SqlHelperDelay())
                {
                    var company1 = sqlHelperDelay.Find<CompanyModel>(1);
                    var company2 = sqlHelperDelay.Find<CompanyModel>(2);
                    
                    //字符串超过数据库字段长度，抛出异常
                    company2.CompanyName += "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);" +
                        "  var company2 = sqlHelperDelay.Find<CompanyModel>(2);";

                    sqlHelperDelay.Insert(company1);
                    sqlHelperDelay.Insert(company2);
                    sqlHelperDelay.SaveChange();
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

        }
```

- 局限性

  该示例的局限性是只能在同一个`SqlHelperDelay`实例对象（同一个连接）中才能确保事务的统一性



## 3.7 Uow（工作单元）

**3.6.2 事务实现**中的示例的局限性是只能在同一个`SqlHelperDelay`实例对象中（多个连接）才能确保事务，

如果要实现**多个实例的事务**，就要使用Uow实现



### 3.7.1 单数据库多个数据库连接对象事务

如下示例，使用**Uow** 实现了，**单数据库多个数据库连接对象（connection）**的事务

- `IUnitOfWork`

  ```C#
      public interface IUnitOfWork : IDisposable
      {
          void Invoke(Action action);
      }
  ```

  

- `UnitOfWork`

  ```C#
          /// <summary>
          /// 提供事务
          /// </summary>
          /// <param name="action">多个数据操作</param>
          public void Invoke(Action action)
          {
              using(var trans = new TransactionScope())
              {
                  action.Invoke();
                  trans.Complete();
              }
  
          }
  
          public void Dispose()
          {
          }
  ```

  

- 测试用例

  ```c#
          [TestMethod]
          public void TestUnitOfWork_Exception()
          {
              using (var uow = new UnitOfWork())
              {
                  SqlHelper sqlHelper = new SqlHelper();
                  var company1 = sqlHelper.Find<CompanyModel>(1);
                  var company2 = sqlHelper.Find<CompanyModel>(2);
  
                  uow.Invoke(() => {
                      sqlHelper.Insert(company1);
                      sqlHelper.Insert(company2);
                      throw new Exception("Exception in Uow!!!");
                  });
              }
          }
  
          [TestMethod]
          public void TestUnitOfWork_Ok()
          {
              using (var uow = new UnitOfWork())
              {
                  SqlHelper sqlHelper = new SqlHelper();
                  var company1 = sqlHelper.Find<CompanyModel>(1);
                  var company2 = sqlHelper.Find<CompanyModel>(2);
  
                  uow.Invoke(() => {
                      sqlHelper.Insert(company1);
                      sqlHelper.Insert(company2);
                  });
              }
          }
  ```

  

## 3.8 分布式事务：多数据库事务

### 3.8.1 MSDTC

为了实现该示例，需要从数据`Architect_Customers`复制出一个新的数据库`Architect_Customers_Other`

在配置文件中新增新的数据库连接`Other`：

```json
{
  "ConnectionStrings": {
    "Write": "...",
    "Read": [ ...
    ],
    "Other": "Data Source=.; Database=Architect_Customers_Other; User ID=sa; Password=123456; MultipleActiveResultSets=True"
  }
}

```

新建一个对应新数据库的查询帮助类`SqlHelperOther `,与`SqlHelper`一样，只是替换了连接字符串的获取方法`GetOtherDbConnectionString()`

```c#
 public class SqlHelperOther
    {
        public T Find<T>(int id) where T : BaseEntity
        {
            Type type = typeof(T);

            string sql = $"{SqlBuilder<T>.GetFindSql()}{id}";
            string connectString = GetOtherDbConnectionString(SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connectString}");
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                    }

                    return t;
                }
            }

            return default(T);
        }


        public int Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T);

            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            string connectString = GetOtherDbConnectionString(SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                object id = command.ExecuteScalar();
                return Convert.ToInt32(id);
            }
        }

```



执行如下可是代码：

```C#
            using (var uow = new UnitOfWork())
            {
                SqlHelper sqlHelper = new SqlHelper();
                var company1 = sqlHelper.Find<CompanyModel>(1);
                company1.CompanyName += "多数据事务";

                SqlHelperOther sqlHelperOther = new SqlHelperOther();
                var company2 = sqlHelperOther.Find<CompanyModel>(1);
                company2.CompanyName += "多数据事务";

                uow.Invoke(() => {
                    sqlHelper.Insert(company1);
                    sqlHelperOther.Insert(company2);
                });
            }
```



```md
System.Data.SqlClient.SqlException:“服务器 'DESKTOP-LDDT7JH' 上的 MSDTC 不可用。”
```

要解决该问题，需要打开windows系统的**DTC**（Distributed Transaction Coordinator）服务，将其设置为**启动**

> MSDTC:
>
> 协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。



启动`MS DTC`服务后，还是会抛出异常：

```md
System.PlatformNotSupportedException:“This platform does not support distributed transactions.”
```

这是在**`.net core 2.1`后就不支持`MSDTC`**了

**同样的代码，`.net framework`中，MSDTC确实可以保证多个数据库间完成事务操作**

#### 3.8.1.1 拓展：局域网MSDTC配置

![image-20201123172107878](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172107878.png)

![image-20201123172136720](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172136720.png)



### 3.8.3 CAP

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123172544672.png" alt="image-20201123172544672" style="zoom:80%;" />



P:是一定会发生的，

CAP定理：CAP是不可能同时满足的

目前的分布式往AP方向走 ，C(一致性)延缓，最终一致性



### 3.8.4 DTC-2PC

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201123175936640.png" alt="image-20201123175936640" style="zoom:80%;" />



**DTC-2PC** 追求可用性，放弃了可用性



### 3.8.5 数据库事务解决

- .Net Core目前暂未提供简单易用的2PC分布式事务

- Try Confirm Cancel
- 本地消息表



## 3.9 条件查询





# 4. 读写分离



读写分离，主库做增删改，从库只读。

大部分的数据库压力，都是由查询引起的，读写分离可以减轻数据库的压力。

1、在(主)数据库上对需要同步的数据进行发布（创建发布服务）。

2、在(从)数据库上对(主)数据库的发布进行订阅。

![image-20201119193930302](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201119193930302.png)



**注意事项**

- 查询服务器的名称和实际计算机的名称，如果两者不一致，就需要修改。

     ```sql
use master
 go
 select @@servername;
 select serverproperty('servername')
     ```



- 将"服务器名", 修改为正确的计算机名

  ```sql
  EXEC sp_dropserver 'aaaaa';      -- 原服务器名
  GO
  EXEC sp_addserver 'aaaaa', 'local'; -- 新服务器名
  ```



**参考**

https://blog.csdn.net/qq_32343577/article/details/82423393



## 4.1 设置发布服务器

- 在设置发布服务器前，先确保服务【SQL Server代理（MSSQL SEVER）】是启动，并且启动模式必须是“自动”

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081423600.png" alt="image-20201122081423600" style="zoom:33%;" />

- 打开【SqlSever管理器】

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122075520349.png" alt="image-20201122075520349" style="zoom:40%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122075538469.png" alt="image-20201122075538469" style="zoom:50%;" />

​    

  实测中直接使用物理路径`E:\ProgramData\SqlServerDatas\snapshot`

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080642440.png" alt="image-20201122080642440" style="zoom:50%;" />





<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080815062.png" alt="image-20201122080815062" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080855479.png" alt="image-20201122080855479" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122080945839.png" alt="image-20201122080945839" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081147364.png" alt="image-20201122081147364" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122081229813.png" alt="image-20201122081229813" style="zoom:50%;" />

生成的脚本的`ConfigureDistribution-server.sql`：

```sql
/****** 正在编写复制配置的脚本。脚本日期: 2020/11/22 8:12:19 ******/
/****** 请注意: 出于安全原因，所有密码参数均使用 NULL 或空字符串代替。******/

/****** 正在将服务器作为分发服务器安装。脚本日期: 2020/11/22 8:12:19 ******/
use master
exec sp_adddistributor @distributor = N'DESKTOP-LDDT7JH', @password = N''
GO
exec sp_adddistributiondb @database = N'distribution-server', @data_folder = N'E:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\Data', @log_folder = N'E:\Program Files\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\Data', @log_file_size = 2, @min_distretention = 0, @max_distretention = 72, @history_retention = 48, @security_mode = 1
GO

use [distribution-server] 
if (not exists (select * from sysobjects where name = 'UIProperties' and type = 'U ')) 
	create table UIProperties(id int) 
if (exists (select * from ::fn_listextendedproperty('SnapshotFolder', 'user', 'dbo', 'table', 'UIProperties', null, null))) 
	EXEC sp_updateextendedproperty N'SnapshotFolder', N'\\DESKTOP-LDDT7JH\snapshot', 'user', dbo, 'table', 'UIProperties' 
else 
	EXEC sp_addextendedproperty N'SnapshotFolder', N'\\DESKTOP-LDDT7JH\snapshot', 'user', dbo, 'table', 'UIProperties'
GO

exec sp_adddistpublisher @publisher = N'DESKTOP-LDDT7JH', @distribution_db = N'distribution-server', @security_mode = 0, @login = N'sa', @password = N'', @working_directory = N'\\DESKTOP-LDDT7JH\snapshot', @trusted = N'false', @thirdparty_flag = 0, @publisher_type = N'MSSQLSERVER'
GO

```



## 4.2 设置发布

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082141699.png" alt="image-20201122082141699" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082216245.png" alt="image-20201122082216245" style="zoom:50%;" />

选择“事件发布”

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082257246.png" alt="image-20201122082257246" style="zoom:50%;" />

1. 快照复制：变化频率低，变化数据大
2. 事务复制：同步效率高，变化频繁，每个步骤都包含
3. 合并复制：通常用于服务器到客户端的环境中，会冲突



选择要发布的表，如果实际过程中有新增表，得重新设置

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082435803.png" alt="image-20201122082435803" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082537091.png" alt="image-20201122082537091" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082630428.png" alt="image-20201122082630428" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082816786.png" alt="image-20201122082816786" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122082846659.png" alt="image-20201122082846659" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083024014.png" alt="image-20201122083024014" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083037511.png" alt="image-20201122083037511" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083244203.png" alt="image-20201122083244203" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083319892.png" alt="image-20201122083319892" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083614013.png" alt="image-20201122083614013" style="zoom:50%;" />



生成的脚本`CreatePublication.sql`：

```sql
use [Architect_Customers]
exec sp_replicationdboption @dbname = N'Architect_Customers', @optname = N'publish', @value = N'true'
GO
-- 添加事务发布
use [Architect_Customers]
exec sp_addpublication @publication = N'Architect_Customers', @description = N'来自发布服务器“DESKTOP-LDDT7JH”的数据库“Architect_Customers”的事务发布。', @sync_method = N'concurrent', @retention = 0, @allow_push = N'true', @allow_pull = N'true', @allow_anonymous = N'true', @enabled_for_internet = N'false', @snapshot_in_defaultfolder = N'true', @compress_snapshot = N'false', @ftp_port = 21, @ftp_login = N'anonymous', @allow_subscription_copy = N'false', @add_to_active_directory = N'false', @repl_freq = N'continuous', @status = N'active', @independent_agent = N'true', @immediate_sync = N'true', @allow_sync_tran = N'false', @autogen_sync_procs = N'false', @allow_queued_tran = N'false', @allow_dts = N'false', @replicate_ddl = 1, @allow_initialize_from_backup = N'false', @enabled_for_p2p = N'false', @enabled_for_het_sub = N'false'
GO

exec sp_addpublication_snapshot @publication = N'Architect_Customers', @frequency_type = 1, @frequency_interval = 0, @frequency_relative_interval = 0, @frequency_recurrence_factor = 0, @frequency_subday = 0, @frequency_subday_interval = 0, @active_start_time_of_day = 0, @active_end_time_of_day = 235959, @active_start_date = 0, @active_end_date = 0, @job_login = null, @job_password = null, @publisher_security_mode = 0, @publisher_login = N'sa', @publisher_password = N''

use [Architect_Customers]
exec sp_addarticle @publication = N'Architect_Customers', @article = N'Company', @source_owner = N'dbo', @source_object = N'Company', @type = N'logbased', @description = null, @creation_script = null, @pre_creation_cmd = N'drop', @schema_option = 0x000000000803509F, @identityrangemanagementoption = N'manual', @destination_table = N'Company', @destination_owner = N'dbo', @vertical_partition = N'false', @ins_cmd = N'CALL sp_MSins_dboCompany', @del_cmd = N'CALL sp_MSdel_dboCompany', @upd_cmd = N'SCALL sp_MSupd_dboCompany'
GO

use [Architect_Customers]
exec sp_addarticle @publication = N'Architect_Customers', @article = N'User', @source_owner = N'dbo', @source_object = N'User', @type = N'logbased', @description = null, @creation_script = null, @pre_creation_cmd = N'drop', @schema_option = 0x000000000803509F, @identityrangemanagementoption = N'manual', @destination_table = N'User', @destination_owner = N'dbo', @vertical_partition = N'false', @ins_cmd = N'CALL sp_MSins_dboUser', @del_cmd = N'CALL sp_MSdel_dboUser', @upd_cmd = N'SCALL sp_MSupd_dboUser'
GO

```

## 4.3 设置订阅

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122083855378.png" alt="image-20201122083855378" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084015688.png" alt="image-20201122084015688" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084034540.png" alt="image-20201122084034540" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084140790.png" alt="image-20201122084140790" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084250306.png" alt="image-20201122084250306" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084308266.png" alt="image-20201122084308266" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084445213.png" alt="image-20201122084445213" style="zoom:50%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084502836.png" alt="image-20201122084502836" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084521236.png" alt="image-20201122084521236" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084549029.png" alt="image-20201122084549029" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084604953.png" alt="image-20201122084604953" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084633245.png" alt="image-20201122084633245" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084642516.png" alt="image-20201122084642516" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084658900.png" alt="image-20201122084658900" style="zoom:50%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122084825532.png" alt="image-20201122084825532" style="zoom:50%;" />

生成的订阅脚本`NewSubscription.sql`:

```sql
-----------------开始: 要在发布服务器“DESKTOP-LDDT7JH”上运行的脚本-----------------
use [Architect_Customers]
exec sp_addsubscription @publication = N'Architect_Customers', @subscriber = N'DESKTOP-LDDT7JH', @destination_db = N'Architect_Customers_01', @subscription_type = N'Push', @sync_type = N'automatic', @article = N'all', @update_mode = N'read only', @subscriber_type = 0
exec sp_addpushsubscription_agent @publication = N'Architect_Customers', @subscriber = N'DESKTOP-LDDT7JH', @subscriber_db = N'Architect_Customers_01', @job_login = null, @job_password = null, @subscriber_security_mode = 0, @subscriber_login = N'sa', @subscriber_password = null, @frequency_type = 64, @frequency_interval = 0, @frequency_relative_interval = 0, @frequency_recurrence_factor = 0, @frequency_subday = 0, @frequency_subday_interval = 0, @active_start_time_of_day = 0, @active_end_time_of_day = 235959, @active_start_date = 20201122, @active_end_date = 99991231, @enabled_for_syncmgr = N'False', @dts_package_location = N'Distributor'
GO
-----------------结束: 要在发布服务器“DESKTOP-LDDT7JH”上运行的脚本-----------------
```

重复上述步骤，再创建一个从库`Architect_Customers_02`



## 4.4 验证是否同步

修改主库`Architect_Customers`都某个字段，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122095423352.png" alt="image-20201122095423352" style="zoom:50%;" />



## 4.5 应用程序读写分离

### 修改获取配置连接字符串的方式

`appsettings.json`

```json
{
  "ConnectionStrings": {
    "Write": "Data Source=.; Database=Architect_Customers; User ID=sa; Password=123456; MultipleActiveResultSets=True",
    "Read": [
      "Data Source=.; Database=Architect_Customers_01; User ID=sa; Password=123456; MultipleActiveResultSets=True",
      "Data Source=.; Database=Architect_Customers_02; User ID=sa; Password=123456; MultipleActiveResultSets=True",
      "Data Source=.; Database=Architect_Customers_03; User ID=sa; Password=123456; MultipleActiveResultSets=True"
    ]
  }
}
```

`SqlConnectionPool.cs`

```c#
public class SqlConnectionPool
    {
        public static string GetConnectionString(SqlConnectionType sqlConnectionType)
        {
            string conn = null;
            switch (sqlConnectionType)
            {
                case SqlConnectionType.Read:
                    conn = Dispatcher(ConfigurationManager.SqlConnectionStringRead);
                    break;
                case SqlConnectionType.Write:
                    conn = ConfigurationManager.SqlConnectionStringWrite;
                    break;
                default:
                    throw new Exception("wrong sqlConnectionType");
            }
            return conn;
        }
        private static int _Seed = 0;
        /// <summary>
        /// 调度分配--随机就是平均
        /// </summary>
        /// <param name="connectionStrings"></param>
        /// <returns></returns>
        private static string Dispatcher(string[] connectionStrings)
        {
            //string conn = connectionStrings[new Random(_Seed++).Next(0, connectionStrings.Length)];//平均策略
            string conn = connectionStrings[_Seed++ % connectionStrings.Length];//轮询--seed需要线程安全
            //能不能根据数据库的状况
            //权重--就是配置文件加点料  
            //2  3  4     9次请求  [1,1,2,2,2,3,3,3,3] 去平均
            return conn;
        }

        public enum SqlConnectionType
        {
            Read,
            Write
        }
    }
```

### 修改读写操作

`SqlHelper.cs`

使用` string connectString = GetConnectionString(SqlConnectionType.Read);`来获取连接字符串

```c#
   public class SqlHelper
    {
        public T Find<T>(int id) where T : BaseEntity
        {
            Type type = typeof(T);
            string sql = $"{SqlBuilder<T>.GetFindSql()}{id}";
            string connectString = GetConnectionString(SqlConnectionType.Read);
            Console.WriteLine($"当前查询的字符串为{connectString}");
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                conn.Open();
                var reader = command.ExecuteReader();
                if (reader.Read())
                {
                    T t = (T)Activator.CreateInstance<T>();
                    foreach (var prop in type.GetProperties())
                    {
                        prop.SetValue(t, reader[prop.GetColumnName()]);
                    }

                    return t;
                }
            }

            return default(T);
        }
       
        public int Insert<T>(T entity) where T: BaseEntity
        {
            Type type = typeof(T)
            //返回Id的insert语句
            //  _InsertSql = $"INSERT INTO [{type.GetMappingName()}] ({columnsString})                   VALUES({valuesString}) Select @@Identity ;";
            string sql = SqlBuilder<T>.GetInsertSql();
            var paraArray = type.GetProperties().Select(
                   p => new SqlParameter($"@{p.GetMappingName()}", p.GetValue(entity) ?? DBNull.Value)
               ) .ToArray();

            string connectString = GetConnectionString(SqlConnectionType.Write);
            using (SqlConnection conn = new SqlConnection(connectString))
            {
                SqlCommand command = new SqlCommand(sql, conn);
                command.Parameters.AddRange(paraArray);
                conn.Open();
                object id = command.ExecuteScalar();
                return Convert.ToInt32(id);
            }
        }
    }
```



### 检验同步所用时间

`main.js`

```c#
        static void Main(string[] args)
        {
            try
            {
                SqlHelper helper = new SqlHelper();
                CompanyModel company1 = helper.Find<CompanyModel>(1);
                company1.CreateTime = DateTime.Now;
                company1.CompanyName += "-Administrator";
                int id = helper.Insert<CompanyModel>(company1);
                Console.WriteLine($"新增的CompanyId={id}");
                for (int i = 0; i < 100; i++)
                {
                    Console.WriteLine($"------------------开始查询------------------");
                    CompanyModel companyNew = helper.Find<CompanyModel>(id);
                    if (companyNew == null)
                    {
                        Console.WriteLine($"未同步到读库，继续{i}");
                    }
                    else
                    {
                        Console.WriteLine($"第{i}*500ms = {i*500/1000}s 同步到从库成功");
                        break;
                    }
                    Console.WriteLine(" ");

                    Thread.Sleep(500);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            Console.ReadLine();
        }
    }
```

输出：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201122133936096.png" alt="image-20201122133936096" style="zoom:50%;" />



# 5. Asp.NetCore（3.1,5.0）

[Asp.Net Core 源码地址](https://github.com/aspnet/AspNetCore)

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-5.0)

## 5.1 扩展

扩展的两种方式：

1. Program
2. Startup

## 5.2 日志

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0)



### 第三方日志

[适用于 ASP.NET Core 的第三方日志记录框架](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#third-party-logging-providers)



### 5.2.1 log4Net

#### 使用步骤：

1. 安装包`Microsoft.Extensions.Logging.Log4Net.AspNetCore`

2. 添加`log4Net`日志组件

   - 方式一：在`Program`类中添加

   ```c#
           public static IHostBuilder CreateHostBuilder(string[] args) =>
               Host.CreateDefaultBuilder(args)
                   .ConfigureLogging(loggingBuilder => 
                   {
                       loggingBuilder.AddLog4Net();
                   })
                   .ConfigureWebHostDefaults(webBuilder =>
                   {
                       webBuilder.UseStartup<Startup>();
                   });
   ```

   其中， 方法`loggingBuilder.AddLog4Net()`默认读取项目更目录的配置文件`log4net.Config`

   - 方式二：在`Startup`类中添加

     ```C#
             public void Configure(......, ILoggerFactory loggerFactory)
             {
                 loggerFactory.AddLog4Net();
                 ......
             }
     ```

     

3. 添加`log4Net`组件的配置文件

   在项目的的根目录下，添加配置文件`log4net.Config`

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <log4net>
   	<!-- Define some output appenders -->
   	<appender name="rollingAppender" type="log4net.Appender.RollingFileAppender">
   		<file value="log\log.txt" />
   		<!--追加日志内容-->
   		<appendToFile value="true" />
   
   		<!--防止多线程时不能写Log,官方说线程非安全-->
   		<lockingModel type="log4net.Appender.FileAppender+MinimalLock" />
   
   		<!--可以为:Once|Size|Date|Composite-->
   		<!--Composite为Size和Date的组合-->
   		<rollingStyle value="Composite" />
   
   		<!--当备份文件时,为文件名加的后缀-->
   		<datePattern value="yyyyMMdd.TXT" />
   
   		<!--日志最大个数,都是最新的-->
   		<!--rollingStyle节点为Size时,只能有value个日志-->
   		<!--rollingStyle节点为Composite时,每天有value个日志-->
   		<maxSizeRollBackups value="20" />
   
   		<!--可用的单位:KB|MB|GB-->
   		<maximumFileSize value="3MB" />
   
   		<!--置为true,当前最新日志文件名永远为file节中的名字-->
   		<staticLogFileName value="true" />
   
   		<!--输出级别在INFO和ERROR之间的日志-->
   		<filter type="log4net.Filter.LevelRangeFilter">
   			<param name="LevelMin" value="ALL" />
   			<param name="LevelMax" value="FATAL" />
   		</filter>
   		<layout type="log4net.Layout.PatternLayout">
   			<conversionPattern value="%date [%thread] %-5level %logger - %message%newline"/>
   		</layout>
   	</appender>
   	<root>
   		<priority value="ALL"/>
   		<level value="ALL"/>
   		<appender-ref ref="rollingAppender" />
   	</root>
   </log4net>
   
   ```

   

4. 使用日志组件，比如在控制器中使用

   ```C#
       public class FirstController : Controller
       {
           private ILogger<FirstController> _logger;
           public FirstController(ILogger<FirstController> logger)
           {
               _logger = logger;
           }
   
           public IActionResult Index()
           {
               _logger.LogInformation("log in FirstController");
               return View();
           }
       }
   ```

5. 在`bin\log`文件夹中生成日志文件`log.txt`：

访问页面`https://localhost:5001/First`,日志文件追加输入如下日志

```md
2020-11-28 18:10:56,034 [4] INFO  AspNetCore31.Jumpstart.Controllers.FirstController - log in FirstController
```



#### ILoggerFactory： 日志的另一种使用方式

1. 依赖注入

   ```C#
       public class FirstController : Controller
       {
           private ILoggerFactory _loggerFactory;
   
           public FirstController(ILoggerFactory loggerFactory)
           {
               _loggerFactory = loggerFactory;
           }
       }
   ```

   

2. 使用：

   ```C#
           public IActionResult Index()
           {
               _loggerFactory.CreateLogger<FirstController>().LogInformation("log in FirstController");
               
               return View();
           }
   ```

   

## 5.3 部署项目

### 5.3.1 部署项目--命令行篇

可以用一个cmd—控制台进程—托管了网站

```md
dotnet AspNetCore31.Jumpstart.dll --urls="http://*:5177" --ip="127.0.0.1" --port=5177
```

需要copy 静态资源(wwwroot文件夹等)
控制台调试



### 5.3.2 部署项目--IIS篇

1. 该发布项目方式，相较于命令行发布，多生成了一个`web.config文件`

   ```xml
   <?xml version="1.0" encoding="utf-8"?>
   <configuration>
     <location path="." inheritInChildApplications="false">
       <system.webServer>
         <handlers>
           <add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModuleV2" resourceType="Unspecified" />
         </handlers>
         <aspNetCore processPath="dotnet" arguments=".\AspNetCore31.Jumpstart.dll" stdoutLogEnabled="false" stdoutLogFile=".\logs\stdout" hostingModel="inprocess" />
       </system.webServer>
     </location>
   </configuration>
   <!--ProjectGuid: 30ba1a71-73cf-43a5-a764-a7052a609a84-->
   ```

   

2. 安装**AspNetCoreModuleV2**

   NetCore + ASP.NET Core Module支持进程内托管模型

3. IIS只是起到反向代理的作用

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201128201809683.png" alt="image-20201128201809683" style="zoom:80%;" />



IIS部署时，其实是把请求交给ModuleV2处理—转给dotnet—启动命令行那一套(IIS没有处理，只是一个代理)



### 5.3.3 理解Kestrel

- Kestrel就是一个简化版IIS web服务器：负责监听请求—转发到代码---完成响应
- Asp.NetCore本质是个控制台：运行起来是个网站---内置了一个Kestral（IIS服务器---所以来能脱离对IIS的依赖，所以才能做到跨平台）
- 有了kestrel，Asp.NetCore才能真正做到跨平台！

## 5.4 依赖注入

[ASP.NET Core 依赖注入](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0)



### 理解IOC&DI

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201129053949370.png" alt="image-20201129053949370" style="zoom:80%;" />



- 控制反转(Inversion of Control，IOC)是一种目标，让程序解耦，可以屏蔽细节
- 依赖倒置（Dependence Inversion Principle，DI），
- DI依赖注入是实现IOC的手段，

### 生命周期

```C#
  services.AddTransient<ITestServiceA, TestServiceA>();//瞬时,每次使用都创建一个实例
  services.AddSingleton<ITestServiceB, TestServiceB>();//单例
  services.AddScoped<ITestServiceC, TestServiceC>();//作用域单例,一次请求只创建一个实例
```



### Autofac

[github](https://github.com/autofac/Autofac)

[英文文档](https://autofaccn.readthedocs.io/en/latest/)

[中文文档](https://autofaccn.readthedocs.io/zh/latest/integration/aspnetcore.html)



[AspNetCore集成示例](https://github.com/autofac/Examples/tree/master/src/AspNetCoreExample)

#### 使用入门

- 安装

  在nuget中安装依赖包：`Autofac.Extensions.DependencyInjection`

  

- 添加`Autoface`组件

  每个版本的添加方式不同：

  - ASP.NET Core 1.1-2.2使用：

  ```C#
    public static void Main(string[] args)
    {
      // ASP.NET Core 1.1 - 2.2:
      // The ConfigureServices call here allows for
      // ConfigureContainer to be supported in Startup with
      // a strongly-typed ContainerBuilder.
      // AddAutofac() is a convenience method for
      // services.AddSingleton<IServiceProviderFactory<ContainerBuilder>>(new AutofacServiceProviderFactory())
      var host = new WebHostBuilder()
          .UseKestrel()
          .ConfigureServices(services => services.AddAutofac())
          .UseContentRoot(Directory.GetCurrentDirectory())
          .UseIISIntegration()
          .UseStartup<Startup>()
          .Build();
  
      host.Run();
    }
  ```

  - 下面是**ASP.NET Core 3+** 和 .NET Core 3+ generic hosting support的集成方式:

  ```C#
   .UseServiceProviderFactory(new AutofacServiceProviderFactory())//设置工厂来替换实例
  ```

  ```C#
          public static IHostBuilder CreateHostBuilder(string[] args) =>
              Host.CreateDefaultBuilder(args)
                  .ConfigureLogging(loggingBuilder => 
                  {
                      loggingBuilder.AddLog4Net();
                  })
                  .UseServiceProviderFactory(new AutofacServiceProviderFactory())//设置工厂来替换实例
                  .ConfigureWebHostDefaults(webBuilder =>
                  {
                      webBuilder.UseStartup<Startup>();
                  });
  ```

  

- 依赖注入

  `Startup类`

  在你的`Startup`类中 (各版本ASP.NET Core基本一致) 你可以使用 `ConfigureContainer` 访问 Autofac container builder 并且直接使用Autofac注册东西.

  ```C#
     public class Startup
      {
          //Asp.Net框架自身会调用该方法
          public void ConfigureContainer(ContainerBuilder containerBuilder)
          {
              // Add any Autofac modules or registrations.
              // This is called AFTER ConfigureServices so things you
              // register here OVERRIDE things registered in ConfigureServices.
              //
              // You must have the call to AddAutofac in the Program.Main
              // method or this won't be called.
              containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
          }
         ......
     }
  ```

   

#### 实例分析

`Startup.cs`

```C#
    public class Startup
    {
        //......
        public void ConfigureServices(IServiceCollection services)
        {
            //......
            services.AddTransient<ITestServiceA, TestServiceA>();//瞬时
            services.AddSingleton<ITestServiceB, TestServiceB>();//单例
            services.AddScoped<ITestServiceC, TestServiceC>();//作用域单例--一次请求一个实例
        }

        public void ConfigureContainer(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterType<TestServiceE>().As<ITestServiceE>().SingleInstance();
        }

```

`FirstController.cs`

```C#
    public class FirstController : Controller
    {
        //.....
        private readonly ITestServiceA _iTestServiceA;
        private readonly ITestServiceB _iTestServiceB;
        private readonly ITestServiceC _iTestServiceC;

        public FirstController(ILogger<FirstController> logger, ILoggerFactory loggerFactory, 
            ITestServiceA iTestServiceA,
            ITestServiceB iTestServiceB,
            ITestServiceC iTestServiceC)
        {
            // ....
            _iTestServiceA = iTestServiceA;
            _iTestServiceB = iTestServiceB;
            _iTestServiceC = iTestServiceC;

        }

        public IActionResult Index()
        {
            Console.WriteLine($"A:{_iTestServiceA.GetHashCode()}");
            Console.WriteLine($"B:{_iTestServiceB.GetHashCode()}");
            
            Console.WriteLine($"C:{_iTestServiceC.GetHashCode()}");
            Console.WriteLine($"C:{_iTestServiceC.GetHashCode()}");
            
            return View();
        }
    }
```

第一次访问`https://localhost:5001/First`输出：

```md
A:65718035
B:37901460
C:57733168
C:57733168
```

第二次访问`https://localhost:5001/First`输出：

```md
A:65718035
B:37901460
C:41149443
C:41149443
```

呈现的结果表明：

​    `ITestServiceA`--单例，被`Autoface`注册为单例覆盖了

​    `ITestServiceB`--单例，使用`IServiceCollection`注册为单例

   `ITestServiceC`--Scoped ,`IServiceCollection`注册为Scoped ,一个请求，共用一个实例

说明：

1. **Autoface与内置的`IServiceCollection`可共存**

2. **在`Autoface`的注册将覆盖在`IServiceCollection`的注册**

   因为使用Autoface的方法`ConfigureContainer()`

   ```c#
           public void ConfigureContainer(ContainerBuilder containerBuilder)
           {
               // Add any Autofac modules or registrations.
               // This is called AFTER ConfigureServices so things you
               // register here OVERRIDE things registered in ConfigureServices.
               //
               // You must have the call to AddAutofac in the Program.Main
               // method or this won't be called.
               containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
           }
   ```

   是在`ConfigureServices`方法之后调用的

   

#### Autofac.Module

`Startup.cs`

```c#
    public class Startup
    {
        //......
        
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllersWithViews();
        }

        //Asp.Net框架自身会调用该方法
        public void ConfigureContainer(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterModule<CustomAutofacModule>();
        }
```

自定一个类`CustomAutofacModule`,继承自`Autofac.Module`

```c#
public class CustomAutofacModule : Autofac.Module
    {
        protected override void Load(ContainerBuilder containerBuilder)
        {
            containerBuilder.RegisterType<TestServiceA>().As<ITestServiceA>().SingleInstance();
            containerBuilder.RegisterType<TestServiceC>().As<ITestServiceC>();
            containerBuilder.RegisterType<TestServiceB>().As<ITestServiceB>();
            containerBuilder.RegisterType<TestServiceD>().As<ITestServiceD>();
            containerBuilder.RegisterType<TestServiceE>().As<ITestServiceE>();
        }

    }
```





## 5.4 中间件

[ASP.NET Core 中间件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#create-a-middleware-pipeline-with-iapplicationbuilder)



### 什么是中间件

中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件：

- 选择是否将请求传递到管道中的下一个组件。
- 可在管道中的下一个组件前后执行工作。

请求委托用于生成请求管道。 请求委托处理每个 HTTP 请求。

使用 [Run](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.runextensions.run)[Map](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map) 和 [Use](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use) 扩展方法来配置请求委托。 可将一个单独的请求委托并行指定为匿名方法（称为并行中间件），或在可重用的类中对其进行定义。 这些可重用的类和并行匿名方法即为中间件，也叫中间件组件。



### 使用 IApplicationBuilder 创建中间件管道

ASP.NET Core 请求管道包含一系列请求委托，依次调用。 下图演示了这一概念。 沿黑色箭头执行。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/request-delegate-pipeline.png" alt="request-delegate-pipeline" style="zoom:100%;" />

#### Use

用 [Use](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use) 将多个请求委托链接在一起，

```c#
            app.Use(next =>
            {
                Console.WriteLine("This is middleware 1");
                return new RequestDelegate(
                    async context =>
                    {
                        await next.Invoke(context);
                    });
            });

            app.Use(next =>
            {
                Console.WriteLine("This is middleware 2");
                return new RequestDelegate(
                    async context =>
                    {
                        await next.Invoke(context);
                    });
            });
```

输出：

```md
This is middleware 2
This is middleware 1
```

注意，执行上述的代码后发现，中间件**执行顺序与加入管道的顺序相反**，原因，看源码[ApplicationBuilder](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Http/src/Builder/ApplicationBuilder.cs)：

```C#

namespace Microsoft.AspNetCore.Builder
{
    public class ApplicationBuilder : IApplicationBuilder
    {
        
        private readonly IList<Func<RequestDelegate, RequestDelegate>> _components = new List<Func<RequestDelegate, RequestDelegate>>();
        
        //......
       
       public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
        {
            _components.Add(middleware);
            return this;
        }

        public RequestDelegate Build()
        {  
            //声明一个RequestDelegate，默认处理步骤
            //默认最起始的委托（404中间件）
            RequestDelegate app = context =>
            {
                ......
                context.Response.StatusCode = StatusCodes.Status404NotFound;
                return Task.CompletedTask;    
            }; 

            foreach (var component in _components.Reverse())//集合反转 123进来  321执行--
            {
                //Func<RequestDelegate,RequestDelegate> 是321的顺序
                app = component(app);
                //404--->middleware3-->middleware2-->middleware1  最终的结果Application其实就是middleware1
            }

            return app;
        }
    }
}
```

其中，

```C#

            foreach (var component in _components.Reverse())//集合反转 123进来  321执行--
            {
                //Func<RequestDelegate,RequestDelegate> 是321的顺序
                app = component(app);
                //404--->middleware3-->middleware2-->middleware1  最终的结果Application其实就是middleware1
            }
```

反转中间件集合，反向执行，



##### UseExtensions

`IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware);`使用有点复杂

故，有一个扩展方法，[UseExtensions](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Http.Abstractions/src/Extensions/UseExtensions.cs) 如下：

```c#
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;

namespace Microsoft.AspNetCore.Builder
{
    /// <summary>
    /// Extension methods for adding middleware.
    /// </summary>
    public static class UseExtensions
    {
        /// <summary>
        /// Adds a middleware delegate defined in-line to the application's request pipeline.
        /// </summary>
        /// <param name="app">The <see cref="IApplicationBuilder"/> instance.</param>
        /// <param name="middleware">A function that handles the request or calls the given next function.</param>
        /// <returns>The <see cref="IApplicationBuilder"/> instance.</returns>
        public static IApplicationBuilder Use(this IApplicationBuilder app, Func<HttpContext, Func<Task>, Task> middleware)
        {
            return app.Use(next =>
            {
                return context =>
                {
                    Func<Task> simpleNext = () => next(context);
                    return middleware(context, simpleNext);
                };
            });
        }
    }
}
```

使用如下，

```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
            app.Use(async (context, next) =>
            {
                Console.WriteLine("app.Use(async (context, next) => This is middleware 1--start");
                await next.Invoke();
                Console.WriteLine("app.Use(async (context, next) => This is middleware 1--end");
            });

            app.Use(async (context, next) =>
            {
                Console.WriteLine("app.Use(async (context, next) => This is middleware 2--start");
                await next.Invoke();
                Console.WriteLine("app.Use(async (context, next) => This is middleware 2--end");
            });
    }
}
```

,其中`next` 参数表示管道中的下一个委托。 可通过不调用 next 参数使管道短路

执行上述代码，输出：

```md
app.Use(async (context, next) => This is middleware 1--start
app.Use(async (context, next) => This is middleware 2--start
app.Use(async (context, next) => This is middleware 2--end
app.Use(async (context, next) => This is middleware 1--end
```

这个执行顺序和加入顺序一致，从这个角度看，比使用`app.Use(next =>{})`好理解多了



#### Run

[Run](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.runextensions.run) 委托不会收到 `next` 参数，

第一个 `Run` 委托**始终为终端**，**用于终止管道**。 **`Run` 是一种约定**。

```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.Use(async (context, next) =>
        {
            // Do work that doesn't write to the Response.
            await next.Invoke();
            // Do logging or other work that doesn't write to the Response.
        });

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from 2nd delegate.");
        });
    }
}
```



### 中间件顺序

下图显示了 ASP.NET Core MVC 和 Razor Pages 应用的完整请求处理管道。 你可以在典型应用中了解现有中间件的顺序，以及在哪里添加自定义中间件。 你可以完全控制如何重新排列现有中间件，或根据场景需要注入新的自定义中间件。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/middleware-pipeline.svg" alt="middleware-pipeline" style="zoom:80%;" />

上图中的“终结点”中间件为相应的应用类型（MVC 或 Razor Pages）执行筛选器管道。 



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/mvc-endpoint.svg" alt="mvc-endpoint" style="zoom:80%;" />

下面的 `Startup.Configure` 方法按照建议的顺序增加与安全相关的中间件组件：

```C#
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseDatabaseErrorPage();
    }
    else
    {
        app.UseExceptionHandler("/Error");
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();
    // app.UseCookiePolicy();

    app.UseRouting();
    // app.UseRequestLocalization();
    // app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();
    // app.UseSession();
    // app.UseResponseCaching();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
        endpoints.MapControllerRoute(
            name: "default",
            pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
```



### 对中间件管道进行分支

#### Map扩展

[Map](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapextensions.map) 扩展用作约定来创建管道分支。 `Map` 基于给定请求路径的匹配项来创建请求管道分支。 如果请求路径以给定路径开头，则执行分支。

```c#
public class Startup
{
    private static void HandleMapTest1(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            await context.Response.WriteAsync("Map Test 1");
        });
    }

    private static void HandleMapTest2(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            await context.Response.WriteAsync("Map Test 2");
        });
    }

    public void Configure(IApplicationBuilder app)
    {
        app.Map("/map1", HandleMapTest1);

        app.Map("/map2", HandleMapTest2);

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from non-Map delegate. <p>");
        });
    }
}
```

#### MapWhen

 [MapWhen](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mapwhenextensions.mapwhen) 基于给定谓词的结果创建请求管道分支。

`Func<HttpContext, bool>` 类型的任何谓词均可用于将请求映射到管道的新分支。

```C#
public class Startup
{
    private static void HandleBranch(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            var branchVer = context.Request.Query["branch"];
            await context.Response.WriteAsync($"Branch used = {branchVer}");
        });
    }

    public void Configure(IApplicationBuilder app)
    {
        app.MapWhen(context => context.Request.Query.ContainsKey("branch"),
                               HandleBranch);

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from non-Map delegate. <p>");
        });
    }
}
```

| 请求                          | 响应                         |
| :---------------------------- | :--------------------------- |
| localhost:1234                | Hello from non-Map delegate. |
| localhost:1234/?branch=master | Branch used = master         |



#### UseWhen

[UseWhen](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.usewhenextensions.usewhen) 也基于给定谓词的结果创建请求管道分支。 与 `MapWhen` 不同的是，如果这个分支不发生短路或包含终端中间件，则会重新加入主管道：

```C#
public class Startup
{
    private void HandleBranchAndRejoin(IApplicationBuilder app, ILogger<Startup> logger)
    {
        app.Use(async (context, next) =>
        {
            var branchVer = context.Request.Query["branch"];
            logger.LogInformation("Branch used = {branchVer}", branchVer);

            // Do work that doesn't write to the Response.
            await next();
            // Do other work that doesn't write to the Response.
        });
    }

    public void Configure(IApplicationBuilder app, ILogger<Startup> logger)
    {
        app.UseWhen(context => context.Request.Query.ContainsKey("branch"),
                               appBuilder => HandleBranchAndRejoin(appBuilder, logger));

        app.Run(async context =>
        {
            await context.Response.WriteAsync("Hello from main pipeline.");
        });
    }
}
```

在前面的示例中，响应 "Hello from main pipeline." 是为所有请求编写的。 如果请求中包含查询字符串变量 `branch`，则在重新加入主管道之前会记录其值。



###  内置中间件

ASP.NET Core 附带以下中间件组件。 “顺序”列提供备注，以说明中间件在请求处理管道中的放置，以及中间件可能会终止请求处理的条件。 如果中间件让请求处理管道短路，并阻止下游中间件进一步处理请求，它被称为“终端中间件”。 若要详细了解短路，请参阅[使用 IApplicationBuilder 创建中间件管道](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#create-a-middleware-pipeline-with-iapplicationbuilder)部分。

| 中间件                                                       | 描述                                                         | 顺序                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| [身份验证](https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/identity?view=aspnetcore-5.0) | 提供身份验证支持。                                           | 在需要 `HttpContext.User` 之前。 OAuth 回叫的终端。          |
| [授权](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.authorizationappbuilderextensions.useauthorization) | 提供身份验证支持。                                           | 紧接在身份验证中间件之后。                                   |
| [Cookie 策略](https://docs.microsoft.com/zh-cn/aspnet/core/security/gdpr?view=aspnetcore-5.0) | 跟踪用户是否同意存储个人信息，并强制实施 cookie 字段（如 `secure` 和 `SameSite`）的最低标准。 | 在发出 cookie 的中间件之前。 示例：身份验证、会话、MVC (TempData)。 |
| [CORS](https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-5.0) | 配置跨域资源共享。                                           | 在使用 CORS 的组件之前。 由于[此错误](https://github.com/dotnet/aspnetcore/issues/23218)，`UseCors` 当前必须在 `UseResponseCaching` 之前运行。 |
| [诊断](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/error-handling?view=aspnetcore-5.0) | 提供新应用的开发人员异常页、异常处理、状态代码页和默认网页的几个单独的中间件。 | 在生成错误的组件之前。 异常终端或为新应用提供默认网页的终端。 |
| [转接头](https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-5.0) | 将代理标头转发到当前请求。                                   | 在使用已更新字段的组件之前。 示例：方案、主机、客户端 IP、方法。 |
| [运行状况检查](https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-5.0) | 检查 ASP.NET Core 应用及其依赖项的运行状况，如检查数据库可用性。 | 如果请求与运行状况检查终结点匹配，则为终端。                 |
| [标头传播](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-5.0#header-propagation-middleware) | 将 HTTP 标头从传入的请求传播到传出的 HTTP 客户端请求中。     |                                                              |
| [HTTP 方法重写](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.httpmethodoverrideextensions) | 允许传入 POST 请求重写方法。                                 | 在使用已更新方法的组件之前。                                 |
| [HTTPS 重定向](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0#require-https) | 将所有 HTTP 请求重定向到 HTTPS。                             | 在使用 URL 的组件之前。                                      |
| [HTTP 严格传输安全性 (HSTS)](https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-5.0#http-strict-transport-security-protocol-hsts) | 添加特殊响应标头的安全增强中间件。                           | 在发送响应之前，修改请求的组件之后。 示例：转接头、URL 重写。 |
| [MVC](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/overview?view=aspnetcore-5.0) | 用 MVC/Razor Pages 处理请求。                                | 如果请求与路由匹配，则为终端。                               |
| [OWIN](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/owin?view=aspnetcore-5.0) | 与基于 OWIN 的应用、服务器和中间件进行互操作。               | 如果 OWIN 中间件处理完请求，则为终端。                       |
| [响应缓存](https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware?view=aspnetcore-5.0) | 提供对缓存响应的支持。                                       | 在需要缓存的组件之前。 `UseCORS` 必须在 `UseResponseCaching` 之前。 |
| [响应压缩](https://docs.microsoft.com/zh-cn/aspnet/core/performance/response-compression?view=aspnetcore-5.0) | 提供对压缩响应的支持。                                       | 在需要压缩的组件之前。                                       |
| [请求本地化](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/localization?view=aspnetcore-5.0) | 提供本地化支持。                                             | 在对本地化敏感的组件之前。                                   |
| [终结点路由](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-5.0) | 定义和约束请求路由。                                         | 用于匹配路由的终端。                                         |
| [SPA](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.spaapplicationbuilderextensions.usespa) | 通过返回单页应用程序 (SPA) 的默认页面，在中间件链中处理来自这个点的所有请求 | 在链中处于靠后位置，因此其他服务于静态文件、MVC 操作等内容的中间件占据优先位置。 |
| [会话](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/app-state?view=aspnetcore-5.0) | 提供对管理用户会话的支持。                                   | 在需要会话的组件之前。                                       |
| [静态文件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-5.0) | 为提供静态文件和目录浏览提供支持。                           | 如果请求与文件匹配，则为终端。                               |
| [URL 重写](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/url-rewriting?view=aspnetcore-5.0) | 提供对重写 URL 和重定向请求的支持。                          | 在使用 URL 的组件之前。                                      |
| [WebSockets](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-5.0) | 启用 WebSockets 协议。                                       | 在接受 WebSocket 请求所需的组件之前。                        |



### 自定义中间件

[编写中间件](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/write?view=aspnetcore-5.0)



编写一个中间件：通过传入区域性测试中间件。 例如，请求 `https://localhost:5001/?culture=no`。

#### 定义中间件类

```C#
using Microsoft.AspNetCore.Http;
using System.Globalization;
using System.Threading.Tasks;

namespace Culture
{
    public class RequestCultureMiddleware
    {
        private readonly RequestDelegate _next;

        public RequestCultureMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var cultureQuery = context.Request.Query["culture"];
            if (!string.IsNullOrWhiteSpace(cultureQuery))
            {
                var culture = new CultureInfo(cultureQuery);

                CultureInfo.CurrentCulture = culture;
                CultureInfo.CurrentUICulture = culture;

            }

            // Call the next delegate/middleware in the pipeline
            await _next(context);
        }
    }
}

```

中间件类必须包括：

- 具有类型为 [RequestDelegate](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.requestdelegate) 的参数的公共构造函数。

- 名为 `Invoke` 或 `InvokeAsync` 的公共方法。

  此方法必须：

  - 返回 `Task`。
  - 接受类型 [HttpContext](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.httpcontext) 的第一个参数。



#### 中间件扩展方法

以下通过 [IApplicationBuilder](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder)的扩展方法 公开中间件：

定义一个扩展方法，封装`builder.UseMiddleware<RequestCultureMiddleware>()`，

```C#
using Microsoft.AspNetCore.Builder;

namespace Culture
{
    public static class RequestCultureMiddlewareExtensions
    {
        public static IApplicationBuilder UseRequestCulture(
            this IApplicationBuilder builder)
        {
            return builder.UseMiddleware<RequestCultureMiddleware>();
        }
    }
}
```

#### 使用中间件

以下代码通过 `Startup.Configure` 调用中间件：


```C#
public class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.UseRequestCulture();

        app.Run(async (context) =>
        {
            await context.Response.WriteAsync(
                $"Hello {CultureInfo.CurrentCulture.DisplayName}");
        });
    }
}
```



## 5.5 筛选器(Filter)

[官方文档](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#dependency-injection)



### 筛选器类型

每种筛选器类型都在筛选器管道中的不同阶段执行：

- [授权筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#authorization-filters)最先运行，用于确定是否已针对请求为用户授权。 如果请求未获授权，授权筛选器可以让管道短路。
- [资源筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#resource-filters)：
  - 授权后运行。
  - [OnResourceExecuting](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iresourcefilter.onresourceexecuting) 在筛选器管道的其余阶段之前运行代码。 例如，`OnResourceExecuting` 在模型绑定之前运行代码。
  - [OnResourceExecuted](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iresourcefilter.onresourceexecuted) 在管道的其余阶段完成之后运行代码。
- [操作筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#action-filters)：
  - 在调用操作方法之前和之后立即运行代码。
  - 可以更改传递到操作中的参数。
  - 可以更改从操作返回的结果。
  - 页面 **不** 支持 Razor 。
- [异常筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#exception-filters)在向响应正文写入任何内容之前，对未经处理的异常应用全局策略。
- [结果筛选器](https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0#result-filters)在执行操作结果之前和之后立即运行代码。 仅当操作方法成功执行时，它们才会运行。 对于必须围绕视图或格式化程序的执行的逻辑，它们很有用。

下图展示了筛选器类型在筛选器管道中的交互方式。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/filter-pipeline-2.png" alt="filter-pipeline-2" style="zoom:75%;" />

多种筛选器接口具有相应属性，这些属性可用作自定义实现的基类。

筛选器属性：

- [ActionFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.actionfilterattribute)
- [ExceptionFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.exceptionfilterattribute)
- [ResultFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resultfilterattribute)
- [FormatFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.formatfilterattribute)
- [ServiceFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.servicefilterattribute)
- [TypeFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.typefilterattribute)



### Filter的示例

通过这个示例，串讲`Filte`的相关知识点。

自定义一个`Filter`,名为`CustomExceptionFilterAttribute`，继承自` ExceptionFilterAttribute`

`CustomEceptionFilterAttribute.cs`完整代码：

```C#
    public class CustomExceptionFilterAttribute : ExceptionFilterAttribute
    {
        private readonly ILogger<CustomExceptionFilterAttribute> _logger;
        private readonly IModelMetadataProvider _modelMetadataProvider;
        public CustomExceptionFilterAttribute(ILogger<CustomExceptionFilterAttribute> logger
            , IModelMetadataProvider modelMetadataProvider)
        {
            this._modelMetadataProvider = modelMetadataProvider;
            this._logger = logger;
        }

        /// <summary>
        /// 异常发生，但是没有处理时
        /// 异常之后得写日志
        /// </summary>
        /// <param name="context"></param>
        public override void OnException(ExceptionContext context)
        {
            if (!context.ExceptionHandled)
            {
                this._logger.LogError($"{context.HttpContext.Request.RouteValues["controller"]} is Error");
                if (this.IsAjaxRequest(context.HttpContext.Request))//header看看是不是XMLHttpRequest
                {
                    context.Result = new JsonResult(new
                    {
                        Result = false,
                        Msg = context.Exception.Message
                    });//中断式---请求到这里结束了，不再继续Action
                }
                else
                {
                    var result = new ViewResult { ViewName = "~/Views/Shared/Error.cshtml" };
                    result.ViewData = new ViewDataDictionary(_modelMetadataProvider, context.ModelState);
                    result.ViewData.Add("Exception", context.Exception);
                    context.Result = result;
                }
                context.ExceptionHandled = true;
            }
        }

        private bool IsAjaxRequest(HttpRequest request)
        {
            string header = request.Headers["X-Requested-With"];
            return "XMLHttpRequest".Equals(header);
        }
    }
```



#### 取消和设置短路

通过设置提供给筛选器方法的 [ResourceExecutingContext](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resourceexecutingcontext) 参数上的 [Result](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.resourceexecutingcontext.result#Microsoft_AspNetCore_Mvc_Filters_ResourceExecutingContext_Result) 属性，可以使筛选器管道短路。 例如，以下资源筛选器将阻止执行管道的其余阶段：

```C#
                if (this.IsAjaxRequest(context.HttpContext.Request))//header看看是不是XMLHttpRequest
                {
                    context.Result = new JsonResult(new
                    {
                        Result = false,
                        Msg = context.Exception.Message
                    });//中断式---请求到这里结束了，不再继续Action
                }
```



#### 错误页

如何在错误页面提供异常信息呢？

```c#
        var result = new ViewResult { ViewName = "~/Views/Shared/Error.cshtml" };
        result.ViewData = new ViewDataDictionary(_modelMetadataProvider, context.ModelState);
        result.ViewData.Add("Exception", context.Exception);
        context.Result = result;
```

关键代码：

```c#
       result.ViewData.Add("Exception", context.Exception);
```

在`Error.cshtml`显示异常信息：

```C#
//.......

@{
    Exception exception = base.ViewData["Exception"] as Exception;
}
//.....

<h2>@exception.Message</h2>
```



#### 依赖注入

我们注意到，`CustomExceptionFilterAttribute`需要某些服务，

```C#
    public class CustomExceptionFilterAttribute : ExceptionFilterAttribute
    {
        private readonly ILogger<CustomExceptionFilterAttribute> _logger;
        private readonly IModelMetadataProvider _modelMetadataProvider;
        
        public CustomExceptionFilterAttribute(ILogger<CustomExceptionFilterAttribute> logger
            , IModelMetadataProvider modelMetadataProvider)
        {
            this._modelMetadataProvider = modelMetadataProvider;
            this._logger = logger;
        }
       
        // ......
    }
```

如果在控制器或及其方法中使用：

```C#
    [CustomExceptionFilterAttribute]//语法错误，无法编译
    public IActionResult Exce()
    {
        throw new Exception("my Exce");
        return View();
    }
```

上述代码直接使用`[CustomExceptionFilterAttribute]`是无法编译通过的，



官方解释：

>  如果将筛选器作为属性实现并直接添加到控制器类或操作方法中，则该筛选器不能由[依赖关系注入](https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0) (DI) 提供构造函数依赖项。 无法由 DI 提供构造函数依赖项，因为：
>
> - 属性在应用时必须提供自己的构造函数参数。
> - 这是属性工作原理上的限制。
>
> **以下筛选器支持从 DI 提供的构造函数依赖项：**
>
> - **[ServiceFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.servicefilterattribute)**
> - **[TypeFilterAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.typefilterattribute)**
> - **在属性上实现 [IFilterFactory](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory)。**



如何为`CustomExceptionFilterAttribute`实现依赖注入呢？，请看下一节【Filter的依赖注入】

### Filter的依赖注入

`Filter`需要某个服务，怎么去获取呢？全程是依赖注入的，怎么为Filte进行依赖注入呢？

##### Filter特性的四种注入方式

###### 全局注册

全局的注册不需要添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
         services.AddControllersWithViews(options => { //定义全局的Filters， 所有的控制器、操作都使用
                options.Filters.Add(typeof(CustomExceptionFilterAttribute));
            });
```



###### ServiceFilter

第一步：添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Add service filters.
    services.AddScoped<CustomExceptionFilterAttribute>();
}
```

第二步：`ServiceFilter` 属性将从 DI 中检索 `CustomExceptionFilterAttribute` 的实例

```c#
        [ServiceFilter(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



###### TypeFilter

使用`TypeFilter`,不需要添加`CustomExceptionFilterAttribute`到 DI 容器中，只是使用`TypeFilter(typeof())`即可

```C#
        [TypeFilter(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



###### IFilterFactory

 就是Filter的工厂，任何环节都可以用工厂代替Filter，`IFilterFactory`里面有ServiceProvider,所以可以IOC了

第一步：

定义一个名为`CustomIOCFilterFactoryAttribute`的特性，继承接口`IFilterFactory`

```C#
    /// <summary>
    /// 基于完成Filter的依赖注入
    /// </summary>
    public class CustomIOCFilterFactoryAttribute : Attribute, IFilterFactory
    {
        private readonly Type _FilterType = null;

        public CustomIOCFilterFactoryAttribute(Type type)
        {
            this._FilterType = type;
        }
        public bool IsReusable => true;

        public IFilterMetadata CreateInstance(IServiceProvider serviceProvider)
        {
            return (IFilterMetadata)serviceProvider.GetService(this._FilterType);
        }
    }
```

第二步：

添加`CustomExceptionFilterAttribute`到 DI 容器中

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Add service filters.
    services.AddScoped<CustomExceptionFilterAttribute>();
}
```

第三步：

使用`[CustomIOCFilterFactory(typeof())]`特性

```C#
        [CustomIOCFilterFactory(typeof(CustomExceptionFilterAttribute))]
        public IActionResult Exce()
        {
            throw new Exception("my Exce");
            return View();
        }
```



### 筛选器作用域

可以将筛选器添加到管道中的以下三个 *范围* 之一：

- 在控制器操作上使用属性。 筛选器属性不能应用于 Razor 页面处理程序方法。

  如以下代码所示， 控制器`FilterController`的`Exce()`操作使用了使用筛选器`CustomExceptionFilterAttribute`

  ```C#
      public class FilterController : Controller
      {
          //[CustomExceptionFilterAttribute]//语法错误，无法编译
          [ServiceFilter(typeof(CustomExceptionFilterAttribute))]
          public IActionResult Exce()
          {
              throw new Exception("my Exce");
              return View();
          }
      }
  ```

  

- 在控制器或页上使用特性 Razor 。

- 针对所有控制器、操作和页面全局 Razor 显示，

  如以下代码所示， 所有的控制器、操作都将使用筛选器`CustomExceptionFilterAttribute`

  ```C#
  public void ConfigureServices(IServiceCollection services)
  {
      services.AddControllersWithViews(options => //定义全局的Filters， 所有的控制器、操作都使用
     {
          options.Filters.Add(typeof(CustomExceptionFilterAttribute));
      });
  }
  ```





### 筛选器执行顺序

当管道的某个特定阶段有多个筛选器时，作用域可确定筛选器执行的默认顺序。 全局筛选器涵盖类筛选器，类筛选器又涵盖方法筛选器。



在筛选器嵌套模式下，筛选器的 after 代码会按照与 before 代码相反的顺序运行。 筛选器序列：

- 全局筛选器的 before 代码。
  - 控制器 *before* 和 Razor 页面筛选器的前代码。
    - 操作方法筛选器的 before 代码。
    - 操作方法筛选器的 after 代码。
  - 控制器 *after* 和 Razor 页面筛选器后的代码。
- 全局筛选器的 after 代码。



执行顺序还跟筛选器的类型有关

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/filter-pipeline-2.png" alt="filter-pipeline-2" style="zoom:75%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/image-20201129153951272.png" alt="image-20201129153951272" style="zoom:75%;" />



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF/mvc-endpoint.svg" alt="mvc-endpoint" style="zoom:80%;" />

#### 示例代码

##### Action级Filter

定义一个`CustomActionFilterAttribute` , 继承自`CustomActionFilterAttribute`

```C#
    public class CustomActionFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnActionExecuted->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomActionFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
    }
```

抽象类`ActionFilterAttribute`实现的接口如下：

```C#
public abstract class ActionFilterAttribute : Attribute, IActionFilter, IFilterMetadata, IAsyncActionFilter, IAsyncResultFilter, IOrderedFilter, IResultFilter
```

在控制器的方法中是使用该`Filter`:

```c#
  public class FilterController : Controller
    {
        //......
      
        [CustomActionFilterAttribute]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
    }
```

`ExcOrder.cshtml`

```cshtml
@{
    ViewData["Title"] = "Filter执行顺序";
    Console.WriteLine($"This is FilterController View Info");
}
<h4>Filter执行顺序</h4>
```

访问页面:`https://localhost:5001/filter/excorder`, 控制台输出：

```md
//......
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
//......
```



##### Contronller级Filter

再一个`Filter`:`CustomControllerFilterAttribute`, 将其使用在`Controller`上

```
    public class CustomControllerFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnActionExecuted ->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomControllerFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
```

```C#
    [CustomControllerFilter]
    public class FilterController : Controller
    {
         //......
        [CustomActionFilterAttribute]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
        //......
    }
```

控制台输出：

```md
//......
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
This CustomControllerFilterAttribute OnResultExecuted->Order:0
//......
```



##### 全局Filter

再一个`Filter`:CustomGlobalFilterAttribute, 将其注册为全局Filter

````C#
   public class CustomGlobalFilterAttribute : ActionFilterAttribute
    {
        public override void OnActionExecuted(ActionExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnActionExecuted->Order:{this.Order}");
        }
        public override void OnActionExecuting(ActionExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnActionExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnResultExecuting->Order:{this.Order}");
        }
        public override void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine($"This {nameof(CustomGlobalFilterAttribute)} OnResultExecuted->Order:{this.Order}");
        }
````

```C#
        public void ConfigureServices(IServiceCollection services)
        {
             //......
            services.AddControllersWithViews(options => { //定义全局的Filters， 所有的控制器、操作都使用
                options.Filters.Add(typeof(CustomGlobalFilterAttribute));
            });
            //......
        }
```

控制台输出：

```md
//......
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This CustomActionFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomActionFilterAttribute OnActionExecuted->Order:0
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This CustomActionFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomActionFilterAttribute OnResultExecuted->Order:0
This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
//......
```

修饰下输出，方便对调用顺序查看：

```C#
//......
//以下为ActionFilter
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
	This CustomControllerFilterAttribute OnActionExecuting->Order:0
		This CustomActionFilterAttribute OnActionExecuting->Order:0
			This is FilterController aciton： ExcOrder
		This CustomActionFilterAttribute OnActionExecuted->Order:0
	This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
    
    
//以下为OnResultFilter
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
	This CustomControllerFilterAttribute OnResultExecuting->Order:0
		This CustomActionFilterAttribute OnResultExecuting->Order:0
			This is FilterController View ExcOrder
		This CustomActionFilterAttribute OnResultExecuted->Order:0
	This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
//......
```



### 重写默认顺序

可以通过实现 [IOrderedFilter](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter) 来重写默认执行序列。 `IOrderedFilter` 公开了 [Order](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.filters.iorderedfilter.order#Microsoft_AspNetCore_Mvc_Filters_IOrderedFilter_Order) 属性来确定执行顺序，该属性优先于作用域。 具有较低的 `Order` 值的筛选器：

- 在具有较高的 `Order` 值的筛选器之前运行 before 代码。
- 在具有较高的 `Order` 值的筛选器之后运行 after 代码。

使用构造函数参数设置了 `Order` 属性,



通俗来讲，就是

- **`Order`属性值默认值为：0；**
- **`Order`属性值越小的`filter`，越先执行。**

用上一讲的示例，来验证下，把`CustomActionFilterAttribute `的属性值变成`-1`,

    [CustomControllerFilter]
    public class FilterController : Controller
    {
         //......
        [CustomActionFilterAttribute(Order = -1)]
        public IActionResult ExcOrder()
        {
            Console.WriteLine($"This is {nameof(FilterController)} aciton： ExcOrder ");
            return View();
        }
        //......
    }
控制台输出：

```c#
//......
This CustomActionFilterAttribute OnActionExecuting->Order:-1
This CustomGlobalFilterAttribute OnActionExecuting->Order:0
This CustomControllerFilterAttribute OnActionExecuting->Order:0
This is FilterController aciton： ExcOrder
This CustomControllerFilterAttribute OnActionExecuted ->Order:0
This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnActionExecuted->Order:-1
This CustomActionFilterAttribute OnResultExecuting->Order:-1
This CustomGlobalFilterAttribute OnResultExecuting->Order:0
This CustomControllerFilterAttribute OnResultExecuting->Order:0
This is FilterController View ExcOrder
This CustomControllerFilterAttribute OnResultExecuted->Order:0
This CustomGlobalFilterAttribute OnResultExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuted->Order:-1
//......
```

美化后的输出格式：

```md
//......
//以下为ActionFilter
This CustomActionFilterAttribute OnActionExecuting->Order:-1
	This CustomGlobalFilterAttribute OnActionExecuting->Order:0
		This CustomControllerFilterAttribute OnActionExecuting->Order:0
			This is FilterController aciton： ExcOrder
		This CustomControllerFilterAttribute OnActionExecuted ->Order:0
	This CustomGlobalFilterAttribute OnActionExecuted->Order:0
This CustomActionFilterAttribute OnActionExecuted->Order:-1

//以下为OnResultFilter
This CustomActionFilterAttribute OnResultExecuting->Order:-1
	This CustomGlobalFilterAttribute OnResultExecuting->Order:0
		This CustomControllerFilterAttribute OnResultExecuting->Order:0
			This is FilterController View ExcOrder
		This CustomControllerFilterAttribute OnResultExecuted->Order:0
	This CustomGlobalFilterAttribute OnResultExecuted->Order:0
This CustomActionFilterAttribute OnResultExecuted->Order:-1
//......
```



### Q&A

- **Q:那什么时候用中间件？什么时候用Filter？**

  **A**：粒度不同的

  ​       Filter是MVC的，中间件能知道action controller，中间件是全部请求都要通过的，Filter可以针对方法/controller，合适选择



## 5.6 认证

[Asp.net MVC中使用Cookie认证](https://www.cnblogs.com/iampkm/p/4699788.html)

[cookie不使用身份验证ASP.NET Core Identity](https://docs.microsoft.com/zh-CN/aspnet/core/security/authentication/cookie?view=aspnetcore-5.0)

### 5.6.1 基于Session传统的认证

#### 登录

`AccountController.cs`

```C#
    /// <summary>
    /// 登录---常规登录靠的是Cookie/Session
    /// </summary>
    public class AccountController : Controller
    {
        private readonly ILogger<AccountController> _logger;
        public AccountController(ILogger<AccountController> logger)
        {
            _logger = logger; ;
        }

        public IActionResult Index()
        {
            return View();
        }

        [HttpGet]//响应get请求
        public ViewResult Login()
        {
            return View();
        }

        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Login(string name, string password, string verify)
        {
            string verifyCode = base.HttpContext.Session.GetString("CheckCode");
            if (verifyCode != null && verifyCode.Equals(verify, StringComparison.CurrentCultureIgnoreCase))
            {
                if ("KKK".Equals(name) && "123456".Equals(password))
                {
                    CurrentUser currentUser = new CurrentUser()
                    {
                        Id = 123,
                        Name = "KKK",
                        Account = "Administrator",
                        Email = "57265177",
                        Password = "123456",
                        LoginTime = DateTime.Now
                    };

                    base.HttpContext.Session.SetString("CurrentUser", Newtonsoft.Json.JsonConvert.SerializeObject(currentUser));
             
                    return base.Redirect("/Home/Index");
                }
                else
                {
                    base.ViewBag.Msg = "账号密码错误";
                }
            }
            else
            {
                base.ViewBag.Msg = "验证码错误";
            }
            return View();
        }

        public ActionResult VerifyCode()
        {
            string code = "";
            Bitmap bitmap = VerifyCodeHelper.CreateVerifyCode(out code);
            base.HttpContext.Session.SetString("CheckCode", code);
            MemoryStream stream = new MemoryStream();
            bitmap.Save(stream, ImageFormat.Gif);
            return File(stream.ToArray(), "image/gif");
        }

        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Logout()
        {
            #region Cookie
            base.HttpContext.Response.Cookies.Delete("CurrentUser");
            #endregion Cookie

            #region Session
            CurrentUser sessionUser = base.HttpContext.GetCurrentUserBySession();
            if (sessionUser != null)
            {
                this._logger.LogDebug(string.Format("用户id={0} Name={1}退出系统", sessionUser.Id, sessionUser.Name));
            }
            base.HttpContext.Session.Remove("CurrentUser");
            base.HttpContext.Session.Clear();
            #endregion Session

            #region MyRegion
            //HttpContext.User.Claims//其他信息
            HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme).Wait();
            #endregion
            return RedirectToAction("Index", "Home"); ;
        }
    }
```

`CookieSessionHelper`

```c#
 public static class CookieSessionHelper
    {
        public static void SetCookies(this HttpContext httpContext, string key, string value, int minutes = 30)
        {
            httpContext.Response.Cookies.Append(key, value, new CookieOptions
            {
                Expires = DateTime.Now.AddMinutes(minutes)
            });
        }
        public static void DeleteCookies(this HttpContext httpContext, string key)
        {
            httpContext.Response.Cookies.Delete(key);
        }

        public static string GetCookiesValue(this HttpContext httpContext, string key)
        {
            httpContext.Request.Cookies.TryGetValue(key, out string value);
            return value;
        }

        public static CurrentUser GetCurrentUserBySession(this HttpContext context)
        {
            string sUser = context.Session.GetString("CurrentUser");
            if (sUser == null)
            {
                return null;
            }
            else
            {
                CurrentUser currentUser = Newtonsoft.Json.JsonConvert.DeserializeObject<CurrentUser>(sUser);
                return currentUser;
            }
        }
    }
```

`VerifyCodeHelper.cs`

```c#
public class VerifyCodeHelper
    {
        public static Bitmap CreateVerifyCode(out string code)
        {
            //建立Bitmap对象，绘图
            Bitmap bitmap = new Bitmap(200, 60);
            Graphics graph = Graphics.FromImage(bitmap);
            graph.FillRectangle(new SolidBrush(Color.White), 0, 0, 200, 60);
            Font font = new Font(FontFamily.GenericSerif, 48, FontStyle.Bold, GraphicsUnit.Pixel);
            Random r = new Random();
            string letters = "ABCDEFGHIJKLMNPQRSTUVWXYZ0123456789";

            StringBuilder sb = new StringBuilder();

            //添加随机的五个字母
            for (int x = 0; x < 5; x++)
            {
                string letter = letters.Substring(r.Next(0, letters.Length - 1), 1);
                sb.Append(letter);
                graph.DrawString(letter, font, new SolidBrush(Color.Black), x * 38, r.Next(0, 15));
            }
            code = sb.ToString();

            //混淆背景
            Pen linePen = new Pen(new SolidBrush(Color.Black), 2);
            for (int x = 0; x < 6; x++)
                graph.DrawLine(linePen, new Point(r.Next(0, 199), r.Next(0, 59)), new Point(r.Next(0, 199), r.Next(0, 59)));
            return bitmap;
        }
    }
```

`Login.cshtml`

```cshtml
@model AspNetCore31.Jumpstart.Models.CurrentUser
@{
    ViewBag.Title = "登录";
}

<h2>@ViewBag.Title。</h2>
<div class="row">
    <div class="col-md-8">
        <section id="loginForm">
            @using (Html.BeginForm("Login", "Account", new { sid = "123", Account = "Eleven" },
               FormMethod.Post, true, new { @class = "form-horizontal", role = "form" }))
            {
                @Html.AntiForgeryToken()
                <h4>使用本地帐户登录。</h4>
                <hr />
                @Html.ValidationSummary(true)
                <div class="form-group">
                    @Html.LabelFor(m => m.Name, new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.TextBoxFor(m => m.Name, new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    @Html.LabelFor(m => m.Password, new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.PasswordFor(m => m.Password, new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    @Html.Label("VerifyCode", "VerifyCode", new { @class = "col-md-2 control-label" })
                    <div class="col-md-10">
                        @Html.TextBox("verify", "", new { @class = "form-control" })
                    </div>
                </div>
                <div class="form-group">
                    <div class="col-md-10">
                        <img id="img_code" alt="验证码图片" class="img"  src="/Account/VerifyCode" title="点击刷新">
                    </div>
                </div>
                <div class="form-group">
                    <div class="col-md-offset-2 col-md-10">
                        <input type="submit" value="登录" class="btn btn-default" />
                        @base.ViewBag.Msg
                    </div>
                </div>
            }
        </section>
    </div>
</div>
```

`_LoginPartial.cshtml`

```cshtml
@using AspNetCore31.Jumpstart.Models;
@using AspNetCore31.Jumpstart.Utility;
@{
    CurrentUser currentUser = base.Context.GetCurrentUserBySession();
    /*var currentUser = base.Context.User.Identity.Name == null ? null : new CurrentUser()
    {
        Name = base.Context.User.Identity.Name
    };*/
}
@if (currentUser != null)
{
    using (Html.BeginForm("Logout", "Account", FormMethod.Post, new { id = "logoutForm", @class = "navbar-right" }))
    {
        @Html.AntiForgeryToken()

        <ul class="nav navbar-nav navbar-right">
            <li>
                @Html.ActionLink("你好 " + currentUser.Name + "!", "Index", "Home", routeValues: null, htmlAttributes: new { title = currentUser.Name })
            </li>
            <li><a href="javascript:document.getElementById('logoutForm').submit()">注销</a></li>
        </ul>
    }
}
else
{
    <ul class="nav navbar-nav navbar-right">
        <li>@Html.ActionLink("登录", "Login", "Account", routeValues: null, htmlAttributes: new { id = "loginLink" })</li>
    </ul>
}

```



#### 校验

传统的登录校验的方式是：

- 在登录成功后，把当前用户信息存储在`Cookie`或`Session`中

  本例是放在`Session`中

  ```C#
  public ActionResult Login(string name, string password, string verify){
   
      //校验用户名和密码正确后，把用户信息存储在Cookie或Session中 
      CurrentUser currentUser = new CurrentUser()
                  {
                      Id = 123,
                      Name = "KKK",
                      Account = "Administrator",
                      Email = "57265177",
                      Password = "123456",
                      LoginTime = DateTime.Now
                  };
                   base.HttpContext.Session.SetString("CurrentUser"
                     ,JsonConvert.SerializeObject(currentUser));
                  }
  ```

  

- 创建一个Filter（本例为：`CustomCheckLoginActionFilter`），用于检测是否登录，如果未登录，跳转至登录页

  ```C#
      public class CustomCheckLoginActionFilter : ActionFilterAttribute
      {
          #region Identity
          private readonly ILogger<CustomCheckLoginActionFilter> _logger;
          private readonly IModelMetadataProvider _modelMetadataProvider;
          public CustomCheckLoginActionFilter(Microsoft.Extensions.Logging.ILogger<CustomCheckLoginActionFilter> logger
              )
          {
              this._logger = logger;
          }
          #endregion
  
          public override void OnActionExecuting(ActionExecutingContext context)
          {
              CurrentUser currentUser = context.HttpContext.GetCurrentUserBySession();
              if (currentUser == null)
              {
                  //if (this.IsAjaxRequest(context.HttpContext.Request))
                  //{ }
                  context.Result = new RedirectResult("~/Account/Login");
              }
              else
              {
                  this._logger.LogDebug($"{currentUser.Name} 访问系统");
              }
          }
          private bool IsAjaxRequest(HttpRequest request)
          {
              string header = request.Headers["X-Requested-With"];
              return "XMLHttpRequest".Equals(header);
          }
      }
  ```

- 在需要登录才能访问的`Controller`或`Action`放置`CustomCheckLoginActionFilter`

  ```C#
      [TypeFilter(typeof(CustomCheckLoginActionFilter))]
      public class NeedLoginController : Controller
      {
          public IActionResult Index()
          {
              return View();
          }
      }
  ```

   

### 5.6.2 Asp.Net Core的认证模型

《Asp.Net Core 3 框架揭秘》第19章

> 认证是一个旨在确认请求访问这真实身份的过程，与认证相关的还有其它两个基本的操作--登录和注销。要真正理解认证、登录和注销这个3个核心的操作本，就需要对Asp.Net Core 采用的基本“票据”的认证机制有基本的了解。
>
> Asp.Net Core应用的认证实现在一个名为`AuthenticationMiddleware`的中间件中，该中间件在处理分发给它的请求时，会按照指定的认证方案(Authentication Scheme）从请求中提取能够验证用户真实身份的数据，我们一般将该数据成为安全令牌（Security Token）。Asp.Net Core 应用下的安全令牌被称为认证票据（Authentiaction Ticket），所以Asp.Net Core应用采取的是基于票据的认证方式



#### 基于Cookie的认证

##### 启用认证中间件`AddAuthentication`

下面我们采用Asp.Net Core提供的基于Cookie的认证方案。顾名思义，该认证方案采用Cookie来携带认证票据。

添加`AddAuthentication`认证中间件

并且通过` AuthenticationBuilder`的扩展放`AddCookie`使用`Cookie`认证方案

```C#
 public class Startup
 {
         public void ConfigureServices(IServiceCollection services)
        {
            //........
             
            //添加认证中间件
            services.AddAuthentication(options =>
            {
                //设置默认的认证方案
                options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme; //"返回Cookes，Cookie认证方案的默认方案名称"
            }).AddCookie(options => //使用Cookie认证方案
            {
                options.LoginPath = new PathString("/Account/Login"); // 登录地址
                options.AccessDeniedPath = new PathString("/Home/Privacy"); //没有授权跳转页面
            });
             
            //......
```

使用认证中间件

```C#
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
        {
            //......
            app.UseRouting();
            app.UseAuthentication(); //认证：检测是否登录、登录者是谁？并赋值给HttpContext.User
            //......
```

##### 登录

检测用户和和密码都正确后，使用`HttpContext.SignInAsync()`方法进行登录操作

```C#
    public class AccountController : Controller
    {        public ActionResult Login(string name, string password, string verify)
        {
            string verifyCode = base.HttpContext.Session.GetString("CheckCode");
            if (verifyCode != null && verifyCode.Equals(verify, StringComparison.CurrentCultureIgnoreCase))
            {
                if ("KKK".Equals(name) && "123456".Equals(password))
                {
                    var claims = new List<Claim>()
                                        {
                                            new Claim(ClaimTypes.Name,name),
                                            new Claim("password",password),//可以写入任意数据
                                            new Claim("Account","Administrator")
                                        };
                    var userPrincipal = new ClaimsPrincipal(new ClaimsIdentity(claims, "Customer"));

                    //cookie认证方案:CookieAuthenticationDefaults.AuthenticationScheme
                    //--用户信息:userPrincipal
                    //---过期时间:ExpiresUtc
                    HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, userPrincipal, new AuthenticationProperties
                    {
                        ExpiresUtc = DateTime.UtcNow.AddMinutes(30),
                    }).Wait();//没用await

                    return base.Redirect("/Home/Index");
                }
                else
                {
                    base.ViewBag.Msg = "账号密码错误";
                }
            }
            else
            {
                base.ViewBag.Msg = "验证码错误";
            }
            return View();
        }
```

上述代码，创建一个类型为`ClaimsPrincipal`的对象，用于存储基于声明（Claim）的用户信息，

```C#
               var claims = new List<Claim>()
                                        {
                                            new Claim(ClaimTypes.Name,name),
                                            new Claim("password",password),//可以写入任意数据
                                            new Claim("Account","Administrator")
                                        };
                var userPrincipal = new ClaimsPrincipal(new ClaimsIdentity(claims, "Customer"));
```

在登录时，在`HttpContext.SignInAsync()`方法中传入,因为在之前使用了认证中间

```C#
app.UseAuthentication(); //认证：检测是否登录、登录者是谁？并赋值给HttpContext.User
```

认证中间件会将其自动将用户信息保存在`HttpContext.User.Identity`,

登录成功后，可以通过

```c#
     var currUser = HttpContext.User.Identity;
```

获取当前用户的信息，

##### 使用认证

**授权通过`[Authorize]`属性控制，当没有任何参数时，它只检查用户身份通过身份认证（Authentication）**

```C#
//[TypeFilter(typeof(CustomCheckLoginActionFilter))]
[Authorize]
public class NeedLoginController : Controller
{
    public IActionResult Index()
    {
        var currUser = HttpContext.User.Identity.Name;
        return View();
    }
} 
```


##### 注销

注销操作使用的是` HttpContext.SignOutAsync()`方法：

```C#
        [HttpPost]
        //[CustomAllowAnonymous]
        public ActionResult Logout()
        {
            //HttpContext.User.Claims//其他信息
            HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme).Wait();
            return RedirectToAction("Index", "Home"); 
        }
```

其中，第一个参数需要传入认证方案的名称，即：字符串常量`CookieAuthenticationDefaults.AuthenticationScheme`（字符串为：Cookies）



### 5.6.3 基于Session、Cookie认证的局限性

基于Session、Cookie的认证无做跨多个实例进行身份认证，即：无法做分布式认证。

解决方案是：使用Token模式

从一个认证服务器中获取token，再使用token访问站点的多个实例。



## 5.7 EntityFrameworkCore

### 5.7.1 使用方式

#### 常规使用new 

在方法`OnConfiguring`中配置连接字符串

```C#
    public partial class JDDbContext : DbContext
    {
        public JDDbContext()
        {
        }
        
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            var builder = new Microsoft.Extensions.Configuration.ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile("appsettings.json");
            var configuration = builder.Build();
            var conn = configuration.GetConnectionString("JDDbConnection");
            
            optionsBuilder.UseSqlServer(conn);
         }
    }

```

使用

```C#
            using (JDDbContext context = new JDDbContext())
            {
                var user = context.Set<User>().First(u => u.Id > 1);
                base.ViewBag.UserName = user.Name;
            }

```



#### DI容器注入

- 定义

```C#
        public JDDbContext(DbContextOptions options) : base(options)
        {
            Console.WriteLine("This is JDDbContext DbContextOptions");
        }
```

**注意：重点指定DbContextOptions有外部配置**

- 使用

> AddDbContext:
>
> Registers the given context as a service in the Microsoft.Extensions.DependencyInjection.IServiceCollection.
>  You use this method when using dependency injection in your application, such
>   as with ASP.NET. For more information on setting up dependency injection, see
>    http://go.microsoft.com/fwlink/?LinkId=526890.

```C#
        public void ConfigureServices(IServiceCollection services)
        {
              //...
            
              services.AddEntityFrameworkSqlServer()
                  .AddDbContext<JDDbContext>(options =>
                  {
                      //读取配置文件中的链接字符串
                      options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection")
                          );  
                  });
        }
```

或

- 定义

```c #
        public JDDbContext(DbContextOptions<JDDbContext> options) : base(options)
        {
            Console.WriteLine("This is JDDbContext DbContextOptions");
        }
```

注意：参数是泛型参数`DbContextOptions<JDDbContext> options`

- 依赖注入

`AddDbContext()`

```C#
            services.AddDbContext<JDDbContext>(options =>
            {
                options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection"));
            });
```

或者`AddDbContextPool()`提供线程池

```c#
            //提供了数据库连接池（DbContextPool）,推荐使用
            services.AddDbContextPool<JDDbContext>(options =>
            {
                options.UseSqlServer(Configuration.GetConnectionString("JDDbConnection"));
            });
```



- 使用

  ```C#
      public class NeedLoginController : Controller
      {
          private readonly JDDbContext _dbContext ;
          public NeedLoginController(JDDbContext jdDbContext)
          {
              _dbContext = jdDbContext;
          }
  
          public IActionResult Index()
          {
              ...
              var user = _dbContext.Set<User>().First(u => u.Id > 1);
  
              return View();
          }
      }
  ```

  

# 6.微服务架构

## 6.1 单体架构

单体应用时代：应用程序就是一个项目，在一个进程里面运行

### 优点

- 开发简单，集中管理，没有分布式的损耗

### 缺点

- 不好维护，升级困难，无法快捷迭代
- 稳定性差



## 6.2 微服务架构

微服务架构（Microservice Architecture）是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。

概念：把一个大型的单个应用程序和服务拆分为数个甚至数十个的支持微服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。

定义：围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

本质：用一些功能比较明确、业务比较精练的服务去解决更大、更实际的问题。



说到微服务架构，就是网关必须有



## 6.3 跨域

跨域是浏览器的限制行为,后台App直接调用WebApi无跨越问题,即：

跨域问题是前端，后台无跨域一说



### 跨域问题的解决

- UseCors

- 在`Controller`的方法中

  ```C#
     [Route("api/[controller]/[action]")]
      [ApiController]
      public class UsersController : ControllerBase
      {
                   [HttpGet]
  
          public Users GetUserByID(int id)
          {
              c
              //throw new Exception("1234567");
              string idParam = base.HttpContext.Request.Query["id"];
              var user = _userList.FirstOrDefault(users => users.UserID == id);
              if (user == null) 
              {
                  throw new HttpResponseException(HttpStatusCode.NotFound);
              }
              return user;
  
          }
  ```

  在Http请求头添加

  ```C#
  base.HttpContext.Response.Headers.Add("Access-Control-Allow-Origin", "*");//允许跨域
  ```

  

## 6.4 多实例运行

```powershell
dotnet ApsNetCoreWebApi.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet ApsNetCoreWebApi.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet ApsNetCoreWebApi.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```



## 6.5 Consul

课程：[Course 11、12]

多个服务实例运行后，如何管理？服务注册和发现

- Nginx

  可以屏蔽服务实例细节
  单纯是负载均衡
  **被动获取实例，有变化是不知道**

  

- Consul

  负载均衡(屏蔽实例细节)
  **服务注册与发现**
  健康检查

### 下载运行

官网：https://www.consul.io/

命令行启动：

在cmd（powershell不行）

```powershell
consul_1.6.2.exe agent –dev
```

浏览器访问：
http://localhost:8500



### WebAPI进行注册

Nuget安装 Consul 包，然后进行服务注册

```C#
    public void ConfigureServices(IServiceCollection services)
    {
        this.Configuration.ConsulRegist(); //实例启动时执行，且只执行一次
    }
```

`ConsulHelper.cs`

```C#
    /// <summary>
    /// 自己封装的注册类
    /// </summary>
    public static class ConsulHelper
    {
        public static void ConsulRegist(this IConfiguration configuration)
        {
            ConsulClient client = new ConsulClient(c =>
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);//命令行参数必须传入
            //int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
            client.Agent.ServiceRegister(new AgentServiceRegistration()
            {
                ID = $"serive:{port}", //"service" + Guid.NewGuid(),//唯一的
                Name = "ZhaoxiUserService",//组名称-Group
                Address = ip,//其实应该写ip地址
                Port = port,//不同实例
                //Tags = new string[] { weight.ToString() },//标签
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
            });
            Console.WriteLine($"http://{ip}:{port}完成注册");
        }
    }
```

其中，

配置心跳地址：

```C#
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
```



参数`HTTP`设置心跳地址，即会定时访问`HealthController`的`Index`方法:

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class HealthController : ControllerBase
    { 
        private readonly ILogger<HealthController> _logger;
        private readonly IConfiguration _iConfiguration;
        public HealthController(ILogger<HealthController> logger, IConfiguration configuration)
        {
            _logger = logger;
            this._iConfiguration = configuration;
        }

        [HttpGet]
        [Route("Index")]//拼接到控制器上的route
        public IActionResult Index()
        {
            this._logger.LogWarning($"This is HealthController {this._iConfiguration["Port"]}");
            return Ok();//HttpStatusCode--200
        }
    }
```

参数`DeregisterCriticalServiceAfter`是设置无响应后时间后把对应的服务移除



开启多个服务实例：

```powershell
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727
dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728
```

http://localhost:8500/ui/dc1/services



### 客户端发现服务

在客户端web项目中，应用引用`Consual`包。



```C#
    public class TestController : Controller
    {
        public IActionResult Info()
        {
            List<Users> userList = new List<Users>();
            string resultUrl = null;
            
            #region 通过consul去发现这些服务地址
            {
                using (ConsulClient client = new ConsulClient(c =>
                {
                    c.Address = new Uri("http://localhost:8500/");
                    c.Datacenter = "dc1";
                }))
                {
                    var dictionary = client.Agent.Services().Result.Response;
                    string message = "";
                    foreach (var keyValuePair in dictionary)
                    {
                        AgentService agentService = keyValuePair.Value;
                        this._logger.LogWarning($"{agentService.Address}:{agentService.Port} {agentService.ID} {agentService.Service}");//找的是全部服务 全部实例  其实可以通过ServiceName筛选
                        message += $"{agentService.Address}:{agentService.Port};";
                    }
                    //获取当前consul的全部服务
                    base.ViewBag.Message = message;
                }
            }
            #endregion
                  
            base.ViewBag.Users = userList;
            base.ViewBag.Url = resultUrl;
            return View();
    }
```



访问客户端：https://localhost:44360/Test/Info，输出如下：

```html
127.0.0.1:5728;127.0.0.1:5727;127.0.0.1:5726;
```

解决了服务的注册和发现的问题，服务的IP和端口改变了也不会影响到客户端的访问，因为**客户端是通过访问统一的地址**：

```C#
string url = "http://ZhaoxiUserService/api/users/get";
```

来访问API，同时这样也起到的负载均衡的作用:

```C#
        private static int iSeed = 0;//没考虑溢出问题

        public IActionResult Info()
        {
            List<Users> userList = new List<Users>();
            string resultUrl = null;

            #region 调用---负载均衡
            {
                //string url = "http://localhost:5726/api/users/get";
                //string url = "http://localhost:5727/api/users/get";
                //string url = "http://localhost:5728/api/users/get";
                string url = "http://ZhaoxiUserService/api/users/get";
                //consul解决使用服务名字 转换IP:Port----DNS

                Uri uri = new Uri(url);
                string groupName = uri.Host;
                using (ConsulClient client = new ConsulClient(c =>
                {
                    c.Address = new Uri("http://localhost:8500/");
                    c.Datacenter = "dc1";
                }))
                {
                    var dictionary = client.Agent.Services().Result.Response;
                    var list = dictionary.Where(k => k.Value.Service.Equals(groupName, StringComparison.OrdinalIgnoreCase));//获取consul上全部对应服务实例
                    KeyValuePair<string, AgentService> keyValuePair = new KeyValuePair<string, AgentService>();
                    //拿到3个地址，只需要从中选择---可以在这里做负载均衡--
                    //{
                    //    keyValuePair = list.First();//直接拿的第一个
                    //}
                    //{
                    //    var array = list.ToArray();
                    //    //随机策略---平均策略
                    //    keyValuePair = array[new Random(iSeed++).Next(0, array.Length)];
                    //}
                    //{
                    //    var array = list.ToArray();
                    //    //轮询策略---平均策略
                    //    keyValuePair = array[iSeed++ % array.Length];
                    //}
                    {
                        //权重---注册服务时指定权重，分配时获取权重并以此为依据
                        List<KeyValuePair<string, AgentService>> pairsList = new List<KeyValuePair<string, AgentService>>();
                        foreach (var pair in list)
                        {
                            int count = int.Parse(pair.Value.Tags?[0]);
                            for (int i = 0; i < count; i++)
                            {
                                pairsList.Add(pair);
                            }
                        }
                        keyValuePair = pairsList.ToArray()[new Random(iSeed++).Next(0, pairsList.Count())];
                    }
                    resultUrl = $"{uri.Scheme}://{keyValuePair.Value.Address}:{keyValuePair.Value.Port}{uri.PathAndQuery}";
                    string result = WebApiHelperExtend.InvokeApi(resultUrl);
                    userList = Newtonsoft.Json.JsonConvert.DeserializeObject<List<Users>>(result);
                }
            }
            #endregion
            base.ViewBag.Users = userList;
            base.ViewBag.Url = resultUrl;
            return View();
        }
```

访问客户端：https://localhost:44360/Test/Info，

### 权重

API启动时，添加自定义参数 `--weight=8` 增加该服务(端口为：5728）的权重，

```C#
 dotnet Zhaoxi.NetCore31WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728 --weight=8
```

在**API项目**中，Program.cs，

```C#
        public static void Main(string[] args)
        {
            var config = new ConfigurationBuilder()
             .SetBasePath(Directory.GetCurrentDirectory())
             .AddCommandLine(args)//支持命令行
             .Build();

            CreateHostBuilder(args).Build().Run();
        }
```

添加对命令行的支持，以便在`IConfiguration`能根据

```C#
configuration["weight"]
```

获取参数。

在**注册服务**时：

```C#
    public static class ConsulHelper
    {
        public static void ConsulRegist(this IConfiguration configuration)
        {
            ConsulClient client = new ConsulClient(c =>
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);//命令行参数必须传入
            int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
            client.Agent.ServiceRegister(new AgentServiceRegistration()
            {
                ID = $"serive:{port}", //"service" + Guid.NewGuid(),//唯一的
                Name = "ZhaoxiUserService",//组名称-Group
                Address = ip,//其实应该写ip地址
                Port = port,//不同实例
                Tags = new string[] { weight.ToString() },//标签
                Check = new AgentServiceCheck()//配置心跳检查的
                {
                    Interval = TimeSpan.FromSeconds(12),
                    HTTP = $"http://{ip}:{port}/Api/Health/Index",
                    Timeout = TimeSpan.FromSeconds(5),
                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                }
            });
            Console.WriteLine($"http://{ip}:{port}完成注册");
        }
    }
}
```

获取参数`--weigh`,

```C#
int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入
```

**放入`Tags`字段中**

```C#
Tags = new string[] { weight.ToString() },//标签
```



**客户端**调用时，**通过`Tags`获取`--weigh`值**，然后根据该值设置权重策略

```C#
                    //权重---注册服务时指定权重，分配时获取权重并以此为依据
                    List<KeyValuePair<string, AgentService>> pairsList = new List<KeyValuePair<string, AgentService>>();
                    foreach (var pair in list)
                    {
                        int count = int.Parse(pair.Value.Tags?[0]);
                        for (int i = 0; i < count; i++)
                        {
                            pairsList.Add(pair);
                        }
                    }
                    keyValuePair = pairsList.ToArray()[new Random(iSeed++).Next(0, pairsList.Count())];
                    resultUrl = $"{uri.Scheme}://{keyValuePair.Value.Address}:{keyValuePair.Value.Port}{uri.PathAndQuery}";
                    string result = WebApiHelperExtend.InvokeApi(resultUrl);
```



根据权重, 比如，3个API地址权重分别是：1, 1, 8，生成10个`AgentService`,存放在临时列表`pairsList`中，然后取列表下标的随机数。其中有8个端口是5278的服务API，它的命中概率最大，这样就实现权重策略。



## 6.6 Ocelot

课程：[Course12]

### Gateway(网关)



**为什么需要网关？**
        有了Consul，使用服务名即可访问。但手机、web端等外部访问者仍然需要和N多服务器交互，需要记忆他们的服务器地址、端口号等。一旦内部发生修改，很麻烦，而且有时候内部服务器是不希望外界直接访问的—需要路由功能！

​        网关的最核心功能就是路由

**好处**：

- 各个业务系统轻松独立维护服务器；
- 复用权限校验；
- 限流、熔断、降级、收费等。



### Ocelot

Ocelot就是一个提供了请求路由、安全验证等功能的API网关微服务



#### 搭建网关

独立进程，完成网关代请求：

1 独立webapi程序(3.1)
2 nuget-ocelot
3 startup配置中间件
4 配置文件

5.运行

```powershell
dotnet Zhaoxi.AspNetCore31.MicroServiceGateway.dll --urls="http://*:6299" --ip="127.0.0.1" --port=6299
```



新建一个[WebApi]模板项目，添加以下包：

```xml
    <PackageReference Include="Ocelot" Version="13.8.0" />
    <PackageReference Include="Ocelot.Provider.Consul" Version="13.8.0" />
    <PackageReference Include="Ocelot.Provider.Polly" Version="13.8.0" />
```

 替换所有的中间件：

```C#
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddOcelot().AddConsul().AddPolly();
            //services.AddControllers();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            app.UseOcelot();
            //if (env.IsDevelopment())
            //{
            //    app.UseDeveloperExceptionPage();
            //}

            //app.UseHttpsRedirection();

            //app.UseRouting();

            //app.UseAuthorization();

            //app.UseEndpoints(endpoints =>
            //{
            //    endpoints.MapControllers();
            //});
        }
    }
```

配置Ocelot,