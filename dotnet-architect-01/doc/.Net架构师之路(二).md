.Net架构师之路(二)

[TOC]



# 14.RabbitMQ

[Course 49-51]



授课环境

1   Windows10企业版
2   Visual Studio2019  16.5
3   AspNetCore3.1
4   RabbitMQ    3.8.3

## 分布式异步队列



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616951417784.png" alt="1616951417784" style="zoom:80%;" />

分布式：多台服务器合作完成业务处理，一个业务流程中，每一个服务器完成一部分；

异步队列：有一个中间者，服务器和服务器之间的中间者



### 大数据高并发架构图

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616952717064.png" alt="1616952717064" style="zoom:80%;" />



### 同步架构

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616952999299.png" alt="1616952999299" style="zoom:80%;" />

**如果给你500个饺子，你能吃完吗？**
如果说让我一顿吃完，这可定搞不定；
如果是说让我一个月吃完；差不多都能搞定

同步架构是要去你马上去处理完业务



### 分布式异步队列

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616953170515.png" alt="1616953170515" style="zoom:80%;" />

拉长时间来处理业务需求；

以时间换空间

 

#### 分布式异步队列解读

**优点**：

异步处理，响应快，增加了数据库（服务器的承载能力）;
削峰，就是把流量的高峰分解到不同的时间段来处理；
解耦（扩展性就更强），让UI和业务独立演化；
高可用，处理器如果发生故障了，对其他的处理器没有影响；



**缺陷：**
1  增加了复杂性
2  即时性降低了，牺牲了用户的体验---避免不了，业务上也是需要有所牺牲；
3  更加依赖于异步队列了



#### 异步队列应用场景

618抢购，某技术负责人说需要做个需求变更；  UI 和业务逻辑层可以独立演化；
618秒杀，要求只有十件商品参与秒杀 （请求进入队列，取前10个请求，其它作废）



## 常见异步队列组件

ActiveMQ
RocketMQ
Kafka
RabbitMQ
Redis



## RabbitMQ

RabbitMQ是 2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，由Erlang（专门针对于大数据高并发的语言；）语言开发，可复用的企业消息系统，是当前最主流的消息中间件之一。

- 可靠性
- 灵活的路由
- 消息集群简单
- 队列高可用
- 多种协议的支持
- 服务器端用Erlang语言编写
- 管理界面
- 跟踪机制
- 插件机制



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616955108278.png" alt="1616955108278" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616955828420.png" alt="1616955828420" style="zoom:80%;" />



### RabbitMQ进程模型

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616956611776.png" alt="1616956611776" style="zoom:80%;" />![1616956680213](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616956680213.png)



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616964102558.png" alt="1616964102558" style="zoom:80%;" />



### AMQP协议 

**帧组件**

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616956735688.png" alt="1616956735688" style="zoom:80%;" />

1. 帧类型 

   ```shell
   1  协议头帧：指定是某种协议
   2  方法帧：携带发送给rabbitmq或者从rabbitmq接收到rpc请求或者响应
   3  内容帧： 描述一条消息的大小和属性
   4  消息体帧：消息内容
   5  心跳帧：rabbitmq和客户端直接传输的一个种数据类型；
   ```

   

2. 信道编号 

3. 以字节为单位的帧大小 

4. 帧有效载荷payload 

5. 结束字节标志（ASCII值206）



**消息组合**

如下图，一个完整的消息，由3种帧组成

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616957345974.png" alt="1616957345974" style="zoom:80%;" />



### 运行环境

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616957646795.png" alt="1616957646795" style="zoom:80%;" />



#### RabbitMQ 下载

 RabbitMQ包
下载地址： https://www.rabbitmq.com/
 百度云下载地址：链接：https://pan.baidu.com/s/1jmlgh6osLtfkaoNi259dSw 提取码：jskq

rabbitmq-server-windows-3.8.3.zip

https://www.rabbitmq.com/install-windows.html

Github：https://github.com/rabbitmq/

rabbitmq-server发布地址：https://github.com/rabbitmq/rabbitmq-server

>  https://github.com/rabbitmq/rabbitmq-server/releases
>
> ## RabbitMQ 3.8.14
>
> RabbitMQ `3.8.14` is a maintenance release that restores
> Erlang 22.3 compatibility for environments that use [direct reply-to](https://github.com/rabbitmq/rabbitmq-server/blob/v3.8.14/direct-reply-to.html).
>
> ### Erlang/OTP Compatibility Notes
>
> This release [requires Erlang 22.3](https://www.rabbitmq.com/which-erlang.html).
> [Erlang 23](http://blog.erlang.org/OTP-23-Highlights/) is highly recommended
> for best forward compatibility with future RabbitMQ versions.
>
> [Provisioning Latest Erlang Releases](https://www.rabbitmq.com/which-erlang.html#erlang-repositories) explains
>
> <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616995683856.png" alt="1616995683856" style="zoom:50%;" />
>
> 与其对应的Erlang的windows版本下载地址：https://erlang.org/download/otp_versions_tree.html
>
> 
>
> what package repositories and tools can be used to provision a recent version of Erlang `23.x`.
>
> --------





这里下载 [rabbitmq-server-windows-3.8.14.zip](https://github-releases.githubusercontent.com/924551/07175f00-7b7e-11eb-959e-24f9fa2f9dac?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210329%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20210329T050414Z&X-Amz-Expires=300&X-Amz-Signature=a2f64eab21603e20f99f4a09921d75f5b5df13118408a1b1b396edbbee6e55e7&X-Amz-SignedHeaders=host&actor_id=35329755&key_id=0&repo_id=924551&response-content-disposition=attachment%3B filename%3Drabbitmq-server-windows-3.8.14.zip&response-content-type=application%2Foctet-stream) 版本





与Erlang的版本对应关系：

https://www.rabbitmq.com/which-erlang.html



![1616994461706](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616994461706.png)

Erlang的版本仓储： https://www.rabbitmq.com/which-erlang.html#erlang-repositories

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616995683856.png" alt="1616995683856" style="zoom:50%;" />

Erlang的windows版本https://erlang.org/download/otp_versions_tree.html

其实跳转到的下载地址是这里：



https://github.com/erlang/otp/releases



#### Erlang环境

官网：https://www.erlang.org/

下载地址：https://www.erlang.org/downloads

https://erlang.org/download/otp_versions_tree.html

https://github.com/erlang/otp/releases

 Erlang语言运行环境
下载地址：http://www.erlang.org/downloads
 百度云下载地址：https://pan.baidu.com/s/1eHRa6BZZ3UN-Cj4Of8sASA 提取码：ou3k

esl-erlang_22.1_windows_amd64.exe

Github:https://github.com/erlang/otp



我们得下载 22.3~23.x 版本才行

https://www.erlang.org/downloads

![1616997534577](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616997534577.png)

[otp_win64_23.3.exe](http://erlang.org/download/otp_win64_23.3.exe)



#### Windows安装

>参考资料：
>
>https://blog.csdn.net/fisea/article/details/111876676



##### 先安装Erlang

安装 [otp_win64_23.3.exe](http://erlang.org/download/otp_win64_23.3.exe)，安装目录：`C:\Program Files\erl-23.3`

> 其它版本下载：https://www.erlang.org/downloads

然后设置环境变量

**ERLANG_HOME**：C:\Program Files\erl-23.3
**Path**: %ERLANG_HOME%\bin

运行**CMD**:

```shell
C:\Users\wei>erl -v
Eshell V11.2  (abort with ^G)
1>
```

说明安装成功。



##### 安装RabbitMQ

> - 其它版本下载地址：https://github.com/rabbitmq/rabbitmq-server/releases
>
> - 与Erlang的版本对应关系：https://www.rabbitmq.com/which-erlang.html



 解压 [rabbitmq-server-windows-3.8.14.zip](https://github-releases.githubusercontent.com/924551/07175f00-7b7e-11eb-959e-24f9fa2f9dac?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210329%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20210329T050414Z&X-Amz-Expires=300&X-Amz-Signature=a2f64eab21603e20f99f4a09921d75f5b5df13118408a1b1b396edbbee6e55e7&X-Amz-SignedHeaders=host&actor_id=35329755&key_id=0&repo_id=924551&response-content-disposition=attachment%3B filename%3Drabbitmq-server-windows-3.8.14.zip&response-content-type=application%2Foctet-stream) 版本，然后把文件夹`rabbitmq_server-3.8.14`拷贝到`C:\Program Files\`,即最终目录为：

`C:\Program Files\rabbitmq_server-3.8.14`

 以管理员身份运行**CMD**

```powershell
C:\WINDOWS\system32>cd C:\Program Files\rabbitmq_server-3.8.14\sbin

#安装为windows服务
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmq-service install
#安装成功提示
C:\Program Files\erl-23.3\erts-11.2\bin\erlsrv: Service RabbitMQ added to system.
C:\Program Files\rabbitmq_server-3.8.14\sbin>
```

> 这时看注册表：<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617000004830.png" alt="1617000004830" style="zoom:80%;" />
>
> 
>
> 如果之前安装过，再安装，有可能安装失败，可以先如上图的注册表`RabbitMQ`节点删除掉。



接着启用并启动服务

```powershell
#服气启用
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmq-service enable

#服务启动
C:\Program Files\erl-23.3\erts-11.2\bin\erlsrv: Service RabbitMQ enabled.

C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmq-service start
RabbitMQ 服务正在启动 .
RabbitMQ 服务已经启动成功。


C:\Program Files\rabbitmq_server-3.8.14\sbin>
```

查看windows服务：这时多出了一个`RabbitMQ`的windows服务

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617000457654.png" alt="1617000457654" style="zoom:80%;" />

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617000580819.png" alt="1617000580819" style="zoom:80%;" />



查看服务器状态：

```powershell
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmqctl status
Error: unable to perform an operation on node 'rabbit@DESKTOP-E6NOF0N'. Please see diagnostics information and suggestions below.

Most common reasons for this are:

 * Target node is unreachable (e.g. due to hostname resolution, TCP connection or firewall issues)
 * CLI tool fails to authenticate with the server (e.g. due to CLI tool's Erlang cookie not matching that of the server)
 * Target node is not running

In addition to the diagnostics info below:

 * See the CLI, clustering and networking guides on https://rabbitmq.com/documentation.html to learn more
 * Consult server logs on node rabbit@DESKTOP-E6NOF0N
 * If target node is configured to use long node names, don't forget to use --longnames with CLI tools

DIAGNOSTICS
===========

attempted to contact: ['rabbit@DESKTOP-E6NOF0N']

rabbit@DESKTOP-E6NOF0N:
  * connected to epmd (port 4369) on DESKTOP-E6NOF0N
  * epmd reports node 'rabbit' uses port 25672 for inter-node and CLI tool traffic
  * TCP connection succeeded but Erlang distribution failed
  * suggestion: check if the Erlang cookie identical for all server nodes and CLI tools
  * suggestion: check if all server nodes and CLI tools use consistent hostnames when addressing each other
  * suggestion: check if inter-node connections may be configured to use TLS. If so, all nodes and CLI tools must do that
   * suggestion: see the CLI, clustering and networking guides on https://rabbitmq.com/documentation.html to learn more


Current node details:
 * node name: 'rabbitmqcli-369-rabbit@DESKTOP-E6NOF0N'
 * effective user's home directory: C:\Users\wei
 * Erlang cookie hash: WdpOFxVp/R53mEM5zLwTCQ==
```



出现以上的错误，或者其它如下图所示错误：

![1617001252098](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617001252098.png)

解决方法：

将`C:\Users\wei\`目录中的文件`.erlang.cookie`拷贝到如下两个目录：

```powershell
# 这个文件夹已经存在同名文件.erlang.cookie，将其覆盖
C:\Windows\System32\config\systemprofile 
C:\Program Files\rabbitmq_server-3.8.14\sbin
```

然后重启RabbitMQ的windows服务，再不行重启电脑

再查看服务状态：

```shell
# 提示一些错误
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmqctl status
Error: this command requires the 'rabbit' app to be running on the target node. Start it with 'rabbitmqctl start_app'.
Arguments given:
        status

[1mUsage[0m

rabbitmqctl [--node <node>] [--longnames] [--quiet] status [--unit <unit>] [--timeout <timeout>]


# 若还是提示以上些错误，多启动windows服务几次，等待久一点
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmqctl status
Status of node rabbit@DESKTOP-E6NOF0N ...
[1mRuntime[0m

OS PID: 10516
OS: Windows
Uptime (seconds): 246
Is under maintenance?: false
RabbitMQ version: 3.8.14
Node name: rabbit@DESKTOP-E6NOF0N
Erlang configuration: Erlang/OTP 23 [erts-11.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1]
Erlang processes: 308 used, 1048576 limit
Scheduler run queue: 1
Cluster heartbeat timeout (net_ticktime): 60

[1mPlugins[0m

Enabled plugin file: c:/Users/wei/AppData/Roaming/RabbitMQ/enabled_plugins
Enabled plugins:


[1mData directory[0m

Node data directory: c:/Users/wei/AppData/Roaming/RabbitMQ/db/rabbit@DESKTOP-E6NOF0N-mnesia
Raft data directory: c:/Users/wei/AppData/Roaming/RabbitMQ/db/rabbit@DESKTOP-E6NOF0N-mnesia/quorum/rabbit@DESKTOP-E6NOF0N

[1mConfig files[0m


[1mLog file(s)[0m

 * c:/Users/wei/AppData/Roaming/RabbitMQ/log/rabbit@DESKTOP-E6NOF0N.log
 * c:/Users/wei/AppData/Roaming/RabbitMQ/log/rabbit@DESKTOP-E6NOF0N_upgrade.log

[1mAlarms[0m

(none)

[1mMemory[0m

Total memory used: 0.12 gb
Calculation strategy: rss
Memory high watermark setting: 0.4 of available memory, computed to: 6.8238 gb

other_proc: 0.0459 gb (36.07 %)
allocated_unused: 0.031 gb (24.36 %)
code: 0.0293 gb (23.0 %)
other_system: 0.0155 gb (12.19 %)
other_ets: 0.003 gb (2.38 %)
atom: 0.0014 gb (1.07 %)
plugins: 0.0004 gb (0.35 %)
binary: 0.0003 gb (0.27 %)
metrics: 0.0002 gb (0.17 %)
mnesia: 0.0001 gb (0.07 %)
quorum_ets: 0.0 gb (0.04 %)
msg_index: 0.0 gb (0.03 %)
connection_channels: 0.0 gb (0.0 %)
connection_other: 0.0 gb (0.0 %)
connection_readers: 0.0 gb (0.0 %)
connection_writers: 0.0 gb (0.0 %)
mgmt_db: 0.0 gb (0.0 %)
queue_procs: 0.0 gb (0.0 %)
queue_slave_procs: 0.0 gb (0.0 %)
quorum_queue_procs: 0.0 gb (0.0 %)
reserved_unallocated: 0.0 gb (0.0 %)

[1mFile Descriptors[0m

Total: 2, limit: 65439
Sockets: 0, limit: 58893

[1mFree Disk Space[0m

Low free disk space watermark: 0.05 gb
Free disk space: 105.4149 gb

[1mTotals[0m

Connection count: 0
Queue count: 0
Virtual host count: 1

[1mListeners[0m

Interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0
Interface: 0.0.0.0, port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

C:\Program Files\rabbitmq_server-3.8.14\sbin>
```

看到以上输出，说明已经正常启动了

###### 管理界面

> RabbitMQ插件:https://www.rabbitmq.com/management.html



从查看服务运行状态看：

```powershell
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmqctl status

[1mListeners[0m

Interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0
Interface: 0.0.0.0, port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0
```

并没有开启**管理界面插件（插件名：rabbitmq_management ，监听端口为：15672）**，

> 默认的开启的插件，每个版本可能不一样

查看下插件列表：

```powershell
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmq-plugins list
Listing plugins with pattern ".*" ...
 Configured: E = explicitly enabled; e = implicitly enabled
 | Status: * = running on rabbit@DESKTOP-E6NOF0N
 |/
[  ] rabbitmq_amqp1_0                  3.8.14
[  ] rabbitmq_auth_backend_cache       3.8.14
[  ] rabbitmq_auth_backend_http        3.8.14
[  ] rabbitmq_auth_backend_ldap        3.8.14
[  ] rabbitmq_auth_backend_oauth2      3.8.14
[  ] rabbitmq_auth_mechanism_ssl       3.8.14
[  ] rabbitmq_consistent_hash_exchange 3.8.14
[  ] rabbitmq_event_exchange           3.8.14
[  ] rabbitmq_federation               3.8.14
[  ] rabbitmq_federation_management    3.8.14
[  ] rabbitmq_jms_topic_exchange       3.8.14
[  ] rabbitmq_management               3.8.14
[  ] rabbitmq_management_agent         3.8.14
[  ] rabbitmq_mqtt                     3.8.14
[  ] rabbitmq_peer_discovery_aws       3.8.14
[  ] rabbitmq_peer_discovery_common    3.8.14
[  ] rabbitmq_peer_discovery_consul    3.8.14
[  ] rabbitmq_peer_discovery_etcd      3.8.14
[  ] rabbitmq_peer_discovery_k8s       3.8.14
[  ] rabbitmq_prometheus               3.8.14
[  ] rabbitmq_random_exchange          3.8.14
[  ] rabbitmq_recent_history_exchange  3.8.14
[  ] rabbitmq_sharding                 3.8.14
[  ] rabbitmq_shovel                   3.8.14
[  ] rabbitmq_shovel_management        3.8.14
[  ] rabbitmq_stomp                    3.8.14
[  ] rabbitmq_top                      3.8.14
[  ] rabbitmq_tracing                  3.8.14
[  ] rabbitmq_trust_store              3.8.14
[  ] rabbitmq_web_dispatch             3.8.14
[  ] rabbitmq_web_mqtt                 3.8.14
[  ] rabbitmq_web_mqtt_examples        3.8.14
[  ] rabbitmq_web_stomp                3.8.14
[  ] rabbitmq_web_stomp_examples       3.8.14
```

确实没有启用，现在开始启用：

```powershell
#启用插件rabbitmq_management
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmq-plugins enable rabbitmq_management
Enabling plugins on node rabbit@DESKTOP-E6NOF0N:
rabbitmq_management
The following plugins have been configured:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch
Applying plugin configuration to rabbit@DESKTOP-E6NOF0N...
The following plugins have been enabled:
  rabbitmq_management
  rabbitmq_management_agent
  rabbitmq_web_dispatch

started 3 plugins.

# 查看是否启用插件成功
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmq-plugins list rabbitmq_management
Listing plugins with pattern "rabbitmq_management" ...
 Configured: E = explicitly enabled; e = implicitly enabled
 | Status: * = running on rabbit@DESKTOP-E6NOF0N
 |/
[E*] rabbitmq_management       3.8.14
[e*] rabbitmq_management_agent 3.8.14
```

启用插件成功后，访问：http://localhost:15672/

![1617003649133](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617003649133.png)

查看用户列表：

```shell
C:\Program Files\rabbitmq_server-3.8.14\sbin>rabbitmqctl list_users
Listing users ...
user    tags
guest   [administrator]

```

guest是管理员账号，密码是：guest，现在使用其进行登录

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617003849181.png" alt="1617003849181" style="zoom:80%;" />

##### 用户

```powershell
//创建用户testuser密码为123456 
rabbitmqctl  add_user testuser 123456   

//赋予testuser读写所有消息队列的权限
rabbitmqctl  set_permissions testuser ".*"  ".*"  ".*"    

//分配用户组(administrator)
rabbitmqctl  set_user_tags testuser administrator    
```



##### 卸载RabbitMQ 和Erlang环境

1   打开Windows控制面板，双击“程序和功能”。
2   在当前安装的程序列表中，右键单击RabbitMQ Server，然后单击“卸载”。
3   在当前安装的程序列表中，右键单击“Erlang OTP”，然后单击“卸载”。
4   打开Windows任务管理器。
5   在任务管理器中，查找进程epmd.exe。 如果此进程仍在运行，请右键单击该进程，然后单击“结束进程”。
6   删除RabbitMQ和Erlang的所有安装目录。
7   删除文件C：\ Windows \ .erlang.cookie（如果存在）。
8   删除电脑找那个所有的.erlang.cookie。
9   同样在User文件夹中，转到AppData \ Roaming \ RabbitMQ。删除RabbitMQ
10 打开运行cmd->sc delete RabbitMQ。
11 打开运行->regedit 找到RabbitMQ节点，删掉即可



##### 其它设置

 为了方便查找 ， 设置如下环境变量 ，这样可以在任何地方在CMD运行（不行！！！）

**RABBITMQ_SERVER:** C:\Program Files\rabbitmq_server-3.8.14 (根目录)
**Path** ：％RABBITMQ_SERVER％\sbin



#### Docker安装

镜像仓储：https://registry.hub.docker.com/_/rabbitmq/

下载镜像：

```shell
[root@centos7 ~]# docker pull rabbitmq:management
management: Pulling from library/rabbitmq
6e0aa5e7af40: Pull complete 
d47239a868b3: Pull complete 
49cbb10cca85: Pull complete 
b7c2edd50e35: Pull complete 
a6bdd84df6f2: Pull complete 
db4e517e38d3: Pull complete 
b3982db455b0: Pull complete 
9f6708aa7fd0: Pull complete 
21c9ffa1be59: Pull complete 
5c6680e36ae7: Pull complete 
fffa3770b398: Pull complete 
213b533bb8a3: Pull complete 
97df3b39dc36: Pull complete 
Digest: sha256:7ac3902a85940c5c1cf4cdf0f528196b8139344bc79e9b3fa8c9b60c7a4ea293
Status: Downloaded newer image for rabbitmq:management
docker.io/library/rabbitmq:management

```



运行容器：

```shell
[root@centos7 ~]# docker run -di --name myrabitt -e RABBITMQ_DEFAULT_USER=admin  -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management 
4f795f5970b7bf00be344b6b516b7e1c28170210a5cb460d3f70fca2a119be0f
[root@centos7 ~]# docker ps 
CONTAINER ID   IMAGE    COMMAND        CREATED    STATUS       PORTS     NAMES
4f795f5970b7   rabbitmq:management   "docker-entrypoint.s…"   11 seconds ago   Up 6 seconds   4369/tcp, 5671-5672/tcp, 0.0.0.0:1883->1883/tcp, 15671/tcp, 0.0.0.0:15672->15672/tcp, 0.0.0.0:25672->25672/tcp, 0.0.0.0:61613->61613/tcp, 15691-15692/tcp   myrabitt
```

查看日志：

```shell
[root@centos7 ~]#docker logs myrabitt
```

访问：http://192.168.130.130:15672/ 就可以看到一个管理界面

![](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616961355951.png)默认的账号和密码都是admin（创建docker容器时我们指定的）：

```shell
docker run -di --name myrabitt -e RABBITMQ_DEFAULT_USER=admin  -e RABBITMQ_DEFAULT_PASS=admin ......
```

查看RabbitMQ-Docker容器的插件列表和启用的插件：

```shell
[root@centos7 ~]# docker exec -it myrabitt /bin/bash
root@4f795f5970b7:/# rabbitmq-plugins list
Listing plugins with pattern ".*" ...
 Configured: E = explicitly enabled; e = implicitly enabled
 | Status: * = running on rabbit@4f795f5970b7
 |/
[  ] rabbitmq_amqp1_0                  3.8.14
[  ] rabbitmq_auth_backend_cache       3.8.14
[  ] rabbitmq_auth_backend_http        3.8.14
[  ] rabbitmq_auth_backend_ldap        3.8.14
[  ] rabbitmq_auth_backend_oauth2      3.8.14
[  ] rabbitmq_auth_mechanism_ssl       3.8.14
[  ] rabbitmq_consistent_hash_exchange 3.8.14
[  ] rabbitmq_event_exchange           3.8.14
[  ] rabbitmq_federation               3.8.14
[  ] rabbitmq_federation_management    3.8.14
[  ] rabbitmq_jms_topic_exchange       3.8.14
[E*] rabbitmq_management               3.8.14
[e*] rabbitmq_management_agent         3.8.14
[  ] rabbitmq_mqtt                     3.8.14
[  ] rabbitmq_peer_discovery_aws       3.8.14
[  ] rabbitmq_peer_discovery_common    3.8.14
[  ] rabbitmq_peer_discovery_consul    3.8.14
[  ] rabbitmq_peer_discovery_etcd      3.8.14
[  ] rabbitmq_peer_discovery_k8s       3.8.14
[E*] rabbitmq_prometheus               3.8.14
[  ] rabbitmq_random_exchange          3.8.14
[  ] rabbitmq_recent_history_exchange  3.8.14
[  ] rabbitmq_sharding                 3.8.14
[  ] rabbitmq_shovel                   3.8.14
[  ] rabbitmq_shovel_management        3.8.14
[  ] rabbitmq_stomp                    3.8.14
[  ] rabbitmq_top                      3.8.14
[  ] rabbitmq_tracing                  3.8.14
[  ] rabbitmq_trust_store              3.8.14
[e*] rabbitmq_web_dispatch             3.8.14
[  ] rabbitmq_web_mqtt                 3.8.14
[  ] rabbitmq_web_mqtt_examples        3.8.14
[  ] rabbitmq_web_stomp                3.8.14
[  ] rabbitmq_web_stomp_examples       3.8.14
root@4f795f5970b7:/# cat /etc/rabbitmq/enabled_plugins
[rabbitmq_management,rabbitmq_prometheus].

```



#### CentOS安装

##### **CentOS下载**

https://www.rabbitmq.com/download.html

这里我们下载：[CentOS7.x版本](https://github-releases.githubusercontent.com/924551/01217e00-7b7e-11eb-9ba0-11817d4f9778?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20210327%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20210327T161048Z&X-Amz-Expires=300&X-Amz-Signature=b672a597bd510fcac071a09e81bb2cd9dcafa56b69eade8a0d05d46233d7a68e&X-Amz-SignedHeaders=host&actor_id=35329755&key_id=0&repo_id=924551&response-content-disposition=attachment%3B filename%3Drabbitmq-server-3.8.14-1.el7.noarch.rpm&response-content-type=application%2Foctet-stream) ：rabbitmq-server-3.8.14-1.el7.noarch.rpm ，看到文件，知道其版本号为3.814



##### **Erlang**下载

![1616942699992](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1616942699992.png)

https://github.com/rabbitmq/erlang-rpm

https://github.com/rabbitmq/erlang-rpm/releases/tag/v23.3

 Redhat7\CentOS7对应的版本： [erlang-23.3-2.el7.x86_64.rpm](https://github.com/rabbitmq/erlang-rpm/releases/download/v23.3/erlang-23.3-2.el7.x86_64.rpm)



##### 上传安装包

因为现在安装包已经放到了Github上，下载比较慢，故：先下载到本机，在上传到云服务器，可以已使用

Xftp 软件上传



##### 安装Erlang

```shell
[root@centos7 ~]# mkdir -p /usr/rabbitmq
[root@centos7 ~]# cd /usr/rabbitmq/
# 本地上传安装文件
[root@centos7 rabbitmq]# ls
erlang-23.3-2.el7.x86_64.rpm  rabbitmq-server-3.8.14-1.el7.noarch.rpm

# 解压?安装?
[root@centos7 rabbitmq]# rpm -Uvh erlang-23.3-2.el7.x86_64.rpm 
警告：erlang-23.3-2.el7.x86_64.rpm: 头V4 RSA/SHA1 Signature, 密钥 ID 6026dfca: NOKEY
准备中...                          ################################# [100%]
	软件包 erlang-23.3-2.el7.x86_64 已经安装
	
#yum安装
[root@centos7 rabbitmq]# yum install -vy erlang-23.3-2.el7.x86_64
加载 "fastestmirror" 插件
加载 "langpacks" 插件
Adding zh_CN.UTF-8 to language list
Config time: 0.014
Yum version: 3.4.3
rpmdb time: 0.001
设置软件包群集
Loading mirror speeds from cached hostfile
 * base: mirrors.ustc.edu.cn
 * extras: mirrors.ustc.edu.cn
 * updates: mirrors.aliyun.com
base                                                                                                                                                                                      | 3.6 kB  00:00:00     
docker-ce-stable                                                                                                                                                                          | 3.5 kB  00:00:00     
extras                                                                                                                                                                                    | 2.9 kB  00:00:00     
updates                                                                                                                                                                                   | 2.9 kB  00:00:00     
updates/7/x86_64/primary_db                                                                                                                                                               | 6.5 MB  00:00:01     
pkgsack time: 4.825
检测 erlang-23.3-2.el7.x86_64 提供的依赖或文件
无须任何处理

# 检查安装成功
[root@centos7 rabbitmq]# erl -v
Erlang/OTP 23 [erts-11.2] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

```

说明：

rpm命令：https://www.linuxcool.com/rpm

yum 命令：https://www.linuxcool.com/yum



##### 安装socat

安装RabbitMQ过程中要依赖一个插件`socat`，所以先安装socat

```shell
[root@centos7 rabbitmq]# yum install -y socat
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirrors.ustc.edu.cn
 * extras: mirrors.ustc.edu.cn
 * updates: mirrors.aliyun.com
正在解决依赖关系
--> 正在检查事务
---> 软件包 socat.x86_64.0.1.7.3.2-2.el7 将被 安装
--> 解决依赖关系完成

依赖关系解决

=================================================================================================================================================================================================================
 Package                                         架构                                             版本                                                      源                                              大小
=================================================================================================================================================================================================================
正在安装:
 socat                                           x86_64                                           1.7.3.2-2.el7                                             base                                           290 k

事务概要
=================================================================================================================================================================================================================
安装  1 软件包

总下载量：290 k
安装大小：1.1 M
Downloading packages:
socat-1.7.3.2-2.el7.x86_64.rpm                                                                                                                                                            | 290 kB  00:00:00     
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
警告：RPM 数据库已被非 yum 程序修改。
  正在安装    : socat-1.7.3.2-2.el7.x86_64                                                                                                                                                                   1/1 
  验证中      : socat-1.7.3.2-2.el7.x86_64                                                                                                                                                                   1/1 

已安装:
  socat.x86_64 0:1.7.3.2-2.el7                                                                                                                                                                                   

完毕！
```



##### 安装RabbitMQ

这里使用本地上传的安装包安装：

```shell
[root@centos7 rabbitmq]# rpm -Uvh rabbitmq-server-3.8.14-1.el7.noarch.rpm 
警告：rabbitmq-server-3.8.14-1.el7.noarch.rpm: 头V4 RSA/SHA256 Signature, 密钥 ID 6026dfca: NOKEY
准备中...                          ################################# [100%]
正在升级/安装...
   1:rabbitmq-server-3.8.14-1.el7     ################################# [100%]

[root@centos7 rabbitmq]# yum install rabbitmq-server
已加载插件：fastestmirror, langpacks
Loading mirror speeds from cached hostfile
 * base: mirrors.ustc.edu.cn
 * extras: mirrors.ustc.edu.cn
 * updates: mirrors.aliyun.com
无须任何处理

```



##### 启动服务

```shell
#启动服务，停止用：systemctl start rabbitmq-server
[root@centos7 rabbitmq]# systemctl start rabbitmq-server

# 查看服务状态
[root@centos7 rabbitmq]# systemctl status rabbitmq-server
● rabbitmq-server.service - RabbitMQ broker
   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)
   Active: active (running) since 日 2021-03-28 23:24:25 CST; 29s ago
 Main PID: 11372 (beam.smp)
   Status: "Initialized"
    Tasks: 28
   Memory: 75.1M
   CGroup: /system.slice/rabbitmq-server.service
           ├─11372 /usr/lib64/erlang/erts-11.2/bin/beam.smp -W w -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 128000 -sbwt none -sbwtdcpu none -sbw...
           ├─11388 erl_child_setup 32768
           ├─11415 /usr/lib64/erlang/erts-11.2/bin/epmd -daemon
           ├─11440 inet_gethost 4
           └─11486 inet_gethost 4

3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: ##########  Licensed under the MPL 2.0. Website: https://rabbitmq.com
3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: Doc guides: https://rabbitmq.com/documentation.html
3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: Support:    https://rabbitmq.com/contact.html
3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: Tutorials:  https://rabbitmq.com/getstarted.html
3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: Monitoring: https://rabbitmq.com/monitoring.html
3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: Logs: /var/log/rabbitmq/rabbit@centos7.log
3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: /var/log/rabbitmq/rabbit@centos7_upgrade.log
3月 28 23:23:36 centos7.6 rabbitmq-server[11372]: Config file(s): (none)
3月 28 23:24:25 centos7.6 rabbitmq-server[11372]: Starting broker... completed with 0 plugins.
3月 28 23:24:25 centos7.6 systemd[1]: Started RabbitMQ broker.

#开启启动服务
[root@centos7 rabbitmq]# systemctl enable rabbitmq-server
Created symlink from /etc/systemd/system/multi-user.target.wants/rabbitmq-server.service to /usr/lib/systemd/system/rabbitmq-server.service.

```



### 存储

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617029338209.png" alt="1617029338209" style="zoom:80%;" />



### VHost

每个Vhost完全独立



### Channel

#### 何时创建Channel

RabbitMQ的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如果要衡量RabbitMQ当前的QPS只需看队列的即可。在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。

**按照RabbitMQ官方建议，生产者和消费者都应该尝试创建（这里指声明操作）队列。这是一个很好的建议，但不适用于所有的情况**。

如果业务本身在架构设计之初已经充分地预估了队列的使用情况，完全可以在业务程序**上线之前在服务器上创建好**（比如通过页面管理、RabbitMQ命令或者更好的是从配置中心下发），这样业务程序也可以免去声明的过程，直接使用即可。

**预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。**很多时候，由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失；或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。当然可以配合mandatory参数或者备份交换器（来提高程序的健壮性。

与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。**迁移的过程也可以对业务程序完全透明**。此种方法也更有利于开发和运维分工，便于相应资源的管理。

如果集群资源充足，而即**将使用的队列所占用的资源又在可控的范围之内**，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。
至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。





### C#驱动RabbitMQ

- Nuget引入程序包RabbitMQ.Client
- 定义生产者消费者
- 生产消息，写入消息，消费消息



### 单生产者单消费者

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617032188313.png" alt="1617032188313" style="zoom:80%;" />



**一个生产者一个消费者；消息只是被消费一次；**

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617033903085.png" alt="1617033903085" style="zoom:50%;" />

官方示例：https://www.rabbitmq.com/tutorials/tutorial-one-dotnet.html





#### 生产者

主要代码清单：

项目：`AspNetCore.RabbitMQ.MessageProducer`

文件：`MessageProducer/ProductionConsumer.cs`

```C#
 public class ProductionConsumer
    {
        public static void Show()
        {
            ConnectionFactory factory = new ConnectionFactory();
            factory.HostName = "localhost";//RabbitMQ服务在本地运行
            factory.UserName = "guest";//用户名
            factory.Password = "guest";//密码 
            //factory.VirtualHost = "/Richard";
            using (IConnection connection = factory.CreateConnection())
            {  
                using (IModel channel = connection.CreateModel())
                {
                    channel.QueueDeclare(queue: "OnlyProducerMessage", durable: true, exclusive: false, autoDelete: false, arguments: null);


                    channel.ExchangeDeclare(exchange: "OnlyProducerMessageExChange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);

                    channel.QueueBind(queue: "OnlyProducerMessage", exchange: "OnlyProducerMessageExChange", routingKey: string.Empty, arguments: null);
                   

                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("生产者ProducerDemo已准备就绪~~~");
                    int i = 1;
                    {
                        while (true)
                        {
                            IBasicProperties basicProperties = channel.CreateBasicProperties();
                            basicProperties.Persistent = true; 
                            //basicProperties.DeliveryMode = 2;
                            string message = $"消息{i}";
                            byte[] body = Encoding.UTF8.GetBytes(message);
                            channel.BasicPublish(exchange: "OnlyProducerMessageExChange",
                                            routingKey: string.Empty,
                                            basicProperties: basicProperties,
                                            body: body);
                            Console.WriteLine($"消息消息消息消息消息消息消息消息消息消息消息消息消息消息：{message} 已发送~");
                            i++;
                            //Thread.Sleep(10);
                        }
                    }
                }
            }
        }
    }
```



#### 消费者

```C#
    class ProductionConsumer
    {
        public static void Show()
        { 
            var factory = new ConnectionFactory();
            factory.HostName = "localhost";//RabbitMQ服务在本地运行
            factory.UserName = "guest";//用户名
            factory.Password = "guest";//密码 
            using (var connection = factory.CreateConnection())
            {
                using (var channel = connection.CreateModel())
                {
                    {
                        {


                            Console.ForegroundColor = ConsoleColor.Green;
                            try
                            {
                                channel.QueueDeclare(queue: "OnlyProducerMessage", durable: true, exclusive: false, autoDelete: false, arguments: null);
                                channel.ExchangeDeclare(exchange: "OnlyProducerMessageExChange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);
                                channel.QueueBind(queue: "OnlyProducerMessage", exchange: "OnlyProducerMessageExChange", routingKey: string.Empty, arguments: null);

                                var consumer = new EventingBasicConsumer(channel);
                                consumer.Received += (model, ea) =>
                                {
                                    var body = ea.Body;
                                    var message = Encoding.UTF8.GetString(body.ToArray());
                                    Console.WriteLine($"消费者01 接受消息: {message}");
                                };
                                channel.BasicConsume(queue: "OnlyProducerMessage",
                                             autoAck: true,
                                             consumer: consumer);
                                Console.WriteLine(" Press [enter] to exit.");
                                Console.ReadLine();
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine(ex.Message);
                            }
                        }

                    }
                }
            } 
        }
    }
```



### 多生产者多消费者

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617163158300.png" alt="1617163158300" style="zoom:80%;" />





### 互为生产消费者

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617163202465.png" alt="1617163202465" style="zoom:80%;" />





### 优先级队列

优先级队列，顾名思义，具有高优先级的队列具有高的优先权，优先级高的消息具备优先被消费的特权。

默认最低为0，最高为队列设置的最大优先级。优先级高的消息可以被优先消费，

可以通过设置队列的x-max-priority参数来实现。

第一步：设置队列的最大优先级

```C#
channel.QueueDeclare(queue: "PriorityQueue", durable: true, exclusive: false, autoDelete: false, 
                     arguments: new Dictionary<string, object>() {
                         {"x-max-priority",10 } 
                     });
```

第二步：设置消息的优先级

```C#
IBasicProperties props = channel.CreateBasicProperties();
props.DeliveryMode = 2; //消息持久化
props.Priority = 1;
string strMessage = $"消息：{i}";
channel.BasicPublish(exchange: "PriorityQueueExchange",
                     routingKey: "PriorityKey",
                     basicProperties: props,
                     body: Encoding.UTF8.GetBytes(strMessage));
```



这个也是有前提的：如果在消费者的消费速度大于生产者的速度且Broker中没有消息堆积的情况下，对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。



**示例**：



**生产者**

```C#
            ConnectionFactory factory = new ConnectionFactory();
            factory.HostName = "localhost";//RabbitMQ服务在本地运行
            factory.UserName = "guest";//用户名
            factory.Password = "guest";//密码 
            using (IConnection connection = factory.CreateConnection())
            {
                using (IModel channel = connection.CreateModel())
                {
                    //指定队列要支持优先级设置，其最后优先级为10；
                    channel.QueueDeclare(queue: "PriorityQueue", durable: true, exclusive: false, autoDelete: false, 
                        arguments: new Dictionary<string, object>() {
                         {"x-max-priority",10 } 
                       });

                    //声明交换机exchang
                    channel.ExchangeDeclare(exchange: "PriorityQueueExchange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);
                    //绑定exchange和queue
                    channel.QueueBind(queue: "PriorityQueue", exchange: "PriorityQueueExchange", routingKey: "PriorityKey");
                   
                    //一些待发送的消息
                    {
                        IBasicProperties props = channel.CreateBasicProperties();
                        props.DeliveryMode = 2; //消息持久化
                        for (int i = 1; i <= 5; i++)
                        {
                            props.Priority = 1;
                            string strMessage = $"消息：{i }";
                            channel.BasicPublish(exchange: "PriorityQueueExchange",
                                           routingKey: "PriorityKey",
                                           basicProperties: props,
                                           body: Encoding.UTF8.GetBytes(strMessage));
                            Console.WriteLine($"{strMessage} 已发送。。。。");
                            
                        }
                    }
```

**生产者把消息的优先级都设置为：1  ，一个发了5条消息**



**消费者**

```C#
var factory = new ConnectionFactory();
            factory.HostName = "localhost";//RabbitMQ服务在本地运行
            factory.UserName = "guest";//用户名
            factory.Password = "guest";//密码 
            using (var connection = factory.CreateConnection())
            {
                using (IModel channel = connection.CreateModel())
                {
                    #region EventingBasicConsumer
                    //定义消费者                                      
                    var consumer = new EventingBasicConsumer(channel);
                    consumer.Received += (model, ea) =>
                    {
                        string msg = Encoding.UTF8.GetString(ea.Body.ToArray());
                        Console.WriteLine(msg);
                        if (msg.Equals("消息：1"))
                        {
                            //拒绝 消息：1
                            channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false); 

                            ///设置消息优先级最高 重新写入到队列中去
                            IBasicProperties props = channel.CreateBasicProperties(); 
                            props.Priority = 10;
                            channel.BasicPublish(exchange: "PriorityQueueExchange",
                                           routingKey: "PriorityKey",
                                           basicProperties: props,
                                           body: Encoding.UTF8.GetBytes("消息：2->优先级被调整为10后重发"));

                        }
                    };
                    Console.WriteLine("消费者准备就绪....");
                    //处理消息
                    channel.BasicConsume(queue: "PriorityQueue", autoAck: false, consumer: consumer);
                    Console.ReadKey();
                    #endregion
                }
            }
```

如果收到的消息是**消息 ：1**， 

- 拒绝接收
- 提升优先级为：10
- 重新放入 交换机

```c#
                        if (msg.Equals(消息：2"))
                        {
                            //拒绝 消息：2
                            channel.BasicReject(deliveryTag: ea.DeliveryTag, requeue: false); 

                            ///设置消息优先级最高 重新写入到队列中去
                            IBasicProperties props = channel.CreateBasicProperties(); 
                            props.Priority = 10; 
                            channel.BasicPublish(exchange: "PriorityQueueExchange",
                                           routingKey: "PriorityKey",
                                           basicProperties: props,
                                           body: Encoding.UTF8.GetBytes(msg));

                        }
```

由于收到到 **消息：2**， 设置了优先级，



> 在这个示例中, 额外注意：
>
> 存在设置了优先级消息的队列有一个标识`Pri`
>
> <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617192427325.png" alt="1617192427325" style="zoom:80%;" />



##### 优先级的有前提

这个也是有前提的：如果在消费者的消费速度大于生产者的速度且Broker中没有消息堆积的情况下，对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。**如下所示，当只有5条消息（消息很少）时，设置优先级无意义 。**

```powershell
消费者准备就绪....
消息：1
消息：2
消息：3
消息：4
消息：5
消息：->优先级被调整为10后重发
```

要让这个示例有意义，得：

在动态的生成消息中去插队,故使用while循环，而不能使用for(因为预先就设置好了队列顺序),

```C#
while (true)
    //当发送的消息很少（比如：5）时，设置优先级无意义 。
    //动态的生成消息中去插队,故使用while循环，而不能使用for(因为预先就设置好了队列顺序)
    //for (int i = 1; i <= 100; i++)
{
    props.Priority = 1;
    string strMessage = $"消息：{i}";
    channel.BasicPublish(exchange: "PriorityQueueExchange",
                         routingKey: "PriorityKey",
                         basicProperties: props,
                         body: Encoding.UTF8.GetBytes(strMessage));
    Console.WriteLine($"{strMessage} 已发送。。。。");
    i++;
}
```

这时消费者端的输出：

```shell
消费者准备就绪....
消息：1
消息：2
消息：3

......

消息：941
消息：->优先级被调整为10后重发

......
```



### 交换机

**任何消息都先要经过交换机**，为什么要这样做呢？

通过交换机，设置一些队列的策略，比如：转发策略





### 交换机类型

RabbitMQ常用的交换器类型有fanout、direct、topic、headers这四种。AMQP协议里还提到另外两种类型：System和自定义，这里不予描述。对于这四种类型下面一一阐述。

> 交换机分发给多个队列的消息是复制操作，而不是这个消息给了A队列，就不给B队列。
>
> 队列给消费者的消息才是单一性，一个消息只能给一个消费者





#### fanout（广播）

**它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。**



```C#
var factory = new ConnectionFactory();
factory.HostName = "localhost";//RabbitMQ服务在本地运行
factory.UserName = "guest";//用户名
factory.Password = "guest";//密码 
using (var connection = factory.CreateConnection())
{
    using (IModel channel = connection.CreateModel())
    {
        channel.QueueDeclare(queue: "PublishSubscrib01", durable: true, exclusive: false, autoDelete: false, arguments: null);
        channel.QueueDeclare(queue: "PublishSubscrib02", durable: true, exclusive: false, autoDelete: false, arguments: null);
        channel.ExchangeDeclare(exchange: "PublishSubscribExChange", type: ExchangeType.Fanout, durable: true, autoDelete: false, arguments: null);
        channel.QueueBind(queue: "PublishSubscrib01", exchange: "PublishSubscribExChange", routingKey: string.Empty, arguments: null);
        channel.QueueBind(queue: "PublishSubscrib02", exchange: "PublishSubscribExChange", routingKey: string.Empty, arguments: null);
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("开始发布消息~~~~"); 

        for (int i = 1; i <= 2000; i++)
        { 
            string message = $"广播第{i}条消息...";
            byte[] body = Encoding.UTF8.GetBytes(message);
            channel.BasicPublish(exchange: "PublishSubscribExChange",
                                 routingKey: string.Empty,
                                 basicProperties: null,
                                 body: body); 
            Console.WriteLine(message);
            Thread.Sleep(200);
        }
    }
}
```

代码解析：

定义交换机的类型为 **fanout**

```C#
 channel.ExchangeDeclare(exchange: "PublishSubscribExChange", type: ExchangeType.Fanout, durable: true, autoDelete: false, arguments: null);
```

**fanout**类型交换机的类型绑定两个队列：

```c#
channel.QueueBind(queue: "PublishSubscrib01", exchange: "PublishSubscribExChange", routingKey: string.Empty, arguments: null);

channel.QueueBind(queue: "PublishSubscrib02", exchange: "PublishSubscribExChange", routingKey: string.Empty, arguments: null);
```



结果是：

`Fanout`l类型的交换机`PublishSubscribExChange`发送**2000个消息**，与其绑定 的两个队列`PublishSubscrib01` 和`PublishSubscrib02`**都有2000条消息**。而不是平分



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617178224408.png" alt="1617178224408" style="zoom:80%;" />

消费者：

```C#
var factory = new ConnectionFactory();
            factory.HostName = "localhost";//RabbitMQ服务在本地运行
            factory.UserName = "Richard02";//用户名
            factory.Password = "123456";//密码 
            using (var connection = factory.CreateConnection())
            {
                using (var channel = connection.CreateModel())
                { 
                    Console.ForegroundColor = ConsoleColor.Green;

                    Console.WriteLine("订阅者01 已经准备就绪~~");
                    try
                    {
                        var body = ea.Body;
                        var message = Encoding.UTF8.GetString(body.ToArray());
                                Console.WriteLine($"订阅者01从队列【PublishSubscrib01】收到消息:{message} ~");  
                        };
                        //只从队列【PublishSubscrib01】获取消息
                        channel.BasicConsume(queue: "PublishSubscrib01", autoAck: true, consumer: consumer); 
                        Console.ReadLine();
                        Console.ReadLine();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    } 
                }
            }
```

**消费者01只从队列【PublishSubscrib01】获取消息**



##### Fanout 交换机应用场景

观察者模式

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617238854372.png" alt="1617238854372" style="zoom:80%;" />



#### direct （直接）

direct类型的交换器路由规则也很简单，它会把消息路由到那些BindingKey和RoutingKey**完全匹配**的队列中。

直接交换器，工作方式类似于单播，Exchange会将消息发送完全匹配ROUTING_KEY的Queue

**DirectExchange 更像从路由方来筛选消息；**

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617201423513.png" alt="1617201423513" style="zoom:80%;" />

示例：

生产者

```C#
 public class DirectExchange
    {
        public static void Show()
        {
            var factory = new ConnectionFactory();
            factory.HostName = "localhost";//RabbitMQ服务在本地运行
            factory.UserName = "guest";//用户名
            factory.Password = "guest";//密码 
            using (var connection = factory.CreateConnection())
            {
                using (IModel channel = connection.CreateModel())
                {
                    channel.QueueDeclare(queue: "DirectExchangeLogAllQueue", durable: true, exclusive: false, autoDelete: false, arguments: null); 
                    channel.QueueDeclare(queue: "DirectExchangeErrorQueue", durable: true, exclusive: false, autoDelete: false, arguments: null);
                    channel.ExchangeDeclare(exchange: "DirectExChange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);

                    string[] logtypes = new string[] { "debug", "info", "warn", "error" };

                    foreach (string logtype in logtypes)
                    {
                        channel.QueueBind(queue: "DirectExchangeLogAllQueue",
                                exchange: "DirectExChange",
                                routingKey: logtype);
                    } 

                    channel.QueueBind(queue: "DirectExchangeErrorQueue",
                              exchange: "DirectExChange",
                              routingKey: "error");

                    List<LogMsgModel> logList = new List<LogMsgModel>();
                    for (int i = 1; i <=100; i++)
                    {
                        if (i % 4 == 0)
                        {
                            logList.Add(new LogMsgModel() { LogType = "info", Msg = Encoding.UTF8.GetBytes($"info第{i}条信息") });
                        }
                        if (i % 4 == 1)
                        {
                            logList.Add(new LogMsgModel() { LogType = "debug", Msg = Encoding.UTF8.GetBytes($"debug第{i}条信息") });
                        }
                        if (i % 4 == 2)
                        {
                            logList.Add(new LogMsgModel() { LogType = "warn", Msg = Encoding.UTF8.GetBytes($"warn第{i}条信息") });
                        }
                        if (i % 4 == 3)
                        {
                            logList.Add(new LogMsgModel() { LogType = "error", Msg = Encoding.UTF8.GetBytes($"error第{i}条信息") });
                        }
                    }
                     
                    Console.WriteLine("生产者发送100条日志信息");
                    //发送日志信息
                    foreach (var log in logList)
                    {
                        channel.BasicPublish(exchange: "DirectExChange",
                                            routingKey: log.LogType,
                                            basicProperties: null,
                                            body: log.Msg);
                        Console.WriteLine($"{Encoding.UTF8.GetString(log.Msg)}  已发送~~");
                    }
                     
                }
            }
        }


        public class LogMsgModel
        {
            public string LogType { get; set; }

            public byte[] Msg { get; set; }
        }
    }
```

核心代码解析：

```C#

//存放所有类型的消息（日志）
channel.QueueDeclare(queue: "DirectExchangeLogAllQueue", durable: true, exclusive: false, autoDelete: false, arguments: null); 
//存放 Error 类型日志
channel.QueueDeclare(queue: "DirectExchangeErrorQueue", durable: true, exclusive: false, autoDelete: false, arguments: null);
//使用 Direct 类型交换机
channel.ExchangeDeclare(exchange: "DirectExChange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);

string[] logtypes = new string[] { "debug", "info", "warn", "error" };

// 一个队列，绑定多个routerkey
foreach (string logtype in logtypes)
{
    channel.QueueBind(queue: "DirectExchangeLogAllQueue",
                      exchange: "DirectExChange",
                      routingKey: logtype);
}

// 该队列仅仅绑定 routingKey = error
channel.QueueBind(queue: "DirectExchangeErrorQueue",
                  exchange: "DirectExChange",
                  routingKey: "error");
```

运行后：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617202454719.png" alt="1617202454719" style="zoom:80%;" />



**Error 日志消费者**：

```C#
channel.QueueDeclare(queue: "DirectExchangeErrorQueue", durable: true, exclusive: false, autoDelete: false, arguments: null);  

channel.ExchangeDeclare(exchange: "DirectExChange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);
// 绑定 error 类型队列，并指定 routingKey=error
channel.QueueBind(queue: "DirectExchangeErrorQueue",
                  exchange: "DirectExChange",
                  routingKey: "error");

//消费队列中的所有消息；                                   
var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =>
{
    var body = ea.Body;
    var message = Encoding.UTF8.GetString(body.ToArray());
    Console.WriteLine($"【{message}】，已发送邮件通知系统管理员~~");
};
//处理消息
channel.BasicConsume(queue: "DirectExchangeErrorQueue",
                     autoAck: true,
                     consumer: consumer);
Console.ReadLine(); 
```

> 绑定 队列的时候，也必须指明 **routerkey** , 因为 一个队列可能 绑定了多个**routerkey**



**多routerkey的队列中获取某个routerkey的信息**

> 这个做是不行的，实际证明：
>
> **队列绑定过的routerkey，即使是在消费者端重新定义了绑定的routerkey, 不会改变生产者端绑定的routerkey。**



生产者一边定义的队列**DirectExchangeLogAllQueue**绑定是4个routerkey：

```C#
string[] logtypes = new string[] { "debug", "info", "warn", "error" };

// 一个队列，绑定多个routerkey
foreach (string logtype in logtypes)
{
    channel.QueueBind(queue: "DirectExchangeLogAllQueue",
                      exchange: "DirectExChange",
                      routingKey: logtype);
}
```

然后在消费者端重新进行绑定：

```C#
var factory = new ConnectionFactory();
factory.HostName = "localhost";//RabbitMQ服务在本地运行
factory.UserName = "guest";//用户名
factory.Password = "guest";//密码 
using (var connection = factory.CreateConnection())
{
    using (IModel channel = connection.CreateModel())
    {
        channel.QueueDeclare(queue: "DirectExchangeLogAllQueue", durable: true, exclusive: false, autoDelete: false, arguments: null);   
        channel.ExchangeDeclare(exchange: "DirectExChange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); 
        string[] logtypes = new string[] { "debug", "info", "warn", "error" };
        //foreach (string logtype in logtypes)
        //{
        //    channel.QueueBind(queue: "DirectExchangeLogAllQueue",
        //            exchange: "DirectExChange",
        //            routingKey: logtype);
        //}

        channel.QueueBind(queue: "DirectExchangeLogAllQueue",
                          exchange: "DirectExChange",
                          routingKey: "error");


        //消费队列中的所有消息；                                   
        var consumer = new EventingBasicConsumer(channel); 
        consumer.Received += (model, ea) =>
        {
            var body = ea.Body;
            var message = Encoding.UTF8.GetString(body.ToArray()); 
            Console.WriteLine($"【{message}】，写入文本~~");
        }; 
        //处理消息
        channel.BasicConsume(queue: "DirectExchangeLogAllQueue",
                             autoAck: true,
                             consumer: consumer); 
        Console.ReadLine(); 
    }
}
```

结果是：

**所有类型的日志都被消费了。即使是在消费者端重新定义了绑定的routerkey, 不会改变生产者端绑定的routerkey。**



查看`DirectExchangeLogAllQueue`绑定的`routerkey`还是 **"debug", "info", "warn", "error"** ，如下图所示：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617203690087.png" alt="1617203690087" style="zoom:80%;" />

故，消费者端并不需要重新定义 队列，交换机及其两种之间的绑定，进而消费者端的代码可简化为:

```C#
var factory = new ConnectionFactory();
factory.HostName = "localhost";//RabbitMQ服务在本地运行
factory.UserName = "guest";//用户名
factory.Password = "guest";//密码 
using (var connection = factory.CreateConnection())
{
    using (IModel channel = connection.CreateModel())
    {
        //消费队列中的所有消息；                                   
        var consumer = new EventingBasicConsumer(channel); 
        consumer.Received += (model, ea) =>
        {
            var body = ea.Body;
            var message = Encoding.UTF8.GetString(body.ToArray()); 
            Console.WriteLine($"【{message}】，写入文本~~");
        }; 
        //处理消息
        channel.BasicConsume(queue: "DirectExchangeLogAllQueue",
                             autoAck: true,
                             consumer: consumer); 
        Console.ReadLine(); 
    }
}
        
```



##### Direrct 交换机应用场景

可以定义两个队列
队列1：专门用来记录日志
队列2：专门用来发邮件，发信息



#### topic

前面讲到direct类型的交换器路由规则是完全匹配BindingKey和RoutingKey，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。

topic类型的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定：
RoutingKey为一个点号“.”分隔的字符串（被点号“.”分隔开的每一段独立的字符串称为一个单词），如“com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”；
BindingKey和RoutingKey一样也是点号“.”分隔的字符串；
BindingKey中可以存在两种特殊字符串“*”和“＃”，用于做模糊匹配，其中“＃”用于匹配一个单词，“＃”用于匹配多规格单词（可以是零个）。

> 总觉得一句话：topic交换机和队列的绑定配规则就是 **模糊匹配** 



**路由键和绑定键**

**在topic交换器类型下，RoutingKey和BindingKey之间需要做模糊匹配，两者并不是相同的。**

BindingKey其实也属于路由键中的一种，官方解释为：the routing key to use for the binding。可以翻译为：在

**绑定的时候使用的路由**键。大多数时候，包括官方文档和RabbitMQ Java API中都把BindingKey和RoutingKey看作RoutingKey，为了避免混淆，可以这么理解：

**在使用绑定的时候，其中需要的路由键是BindingKey**。涉及的客户端方法如：channel.exchangeBind、channel.queueBind，对应的AMQP命令为Exchange.Bind、Queue.Bind。
在发送消息的时候，其中需要的路由键是RoutingKey。涉及的客户端方法如channel.basicPublish，对应的AMQP命令为Basic.Publish。
由于某些历史的原因，包括现存能搜集到的资料显示：大多数情况下习惯性地将BindingKey写成RoutingKey，尤其是在使用direct类型的交换器的时候。**本文后面的篇幅中也会将两者合称为路由键**，读者需要注意区分其中的不同，可以根据上面的辨别方法进行有效的区分。



**Topic路由：**



**Exchange绑定队列需要制定Key;  Key 可以有自己的规则；Key可以有占位符；*或者# ，*匹配一个单词(（**被点号“.”分隔开的每一段独立的字符串称为一个单词**）)、#匹配多个单词，在Direct基础上加上模糊匹配；**

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617247199890.png" alt="1617247199890" style="zoom:80%;" />



topic类型的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定：

RoutingKey为一个点号“.”分隔的字符串（**被点号“.”分隔开的每一段独立的字符串称为一个单词**），如“com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”；

BindingKey和RoutingKey一样也是点号“.”分隔的字符串；

BindingKey中可以存在两种特殊字符串“*”和“＃”，用于做模糊匹配，其中“＃”用于匹配一个单词，“＃”用于匹配多规格单词（可以是零个）。

以图下图的配置为例：
●路由键为“com.rabbitmq.client”的消息会同时路由到Queue1和Queue2；
●路由键为“com.hidden.client”的消息只会路由到Queue2中；
●路由键为“com.hidden.demo”的消息只会路由到Queue2中；
●路由键为“java.rabbitmq.demo”的消息只会路由到Queue1中；
●路由键为“java.util.concurrent”的消息将会被丢弃或者返回给生产者（需要设置mandatory参数），因为它没有匹配任何路由键。

![1617246802079](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617246802079.png)





**示例**：

**生产者**

```C#
//1.定义主题类型的交换机
channel.ExchangeDeclare(exchange: "TopicExchange", type: ExchangeType.Topic, durable: true, autoDelete: false, arguments: null); 

//1.定义主题类型的交换机
channel.ExchangeDeclare(exchange: "TopicExchange", type: ExchangeType.Topic, durable: true, autoDelete: false, arguments: null); 

// 2.定义队列
channel.QueueDeclare(queue: "ChinaQueue", durable: true, exclusive: false, autoDelete: false, arguments: null); 
channel.QueueDeclare(queue: "newsQueue", durable: true, exclusive: false, autoDelete: false,  arguments: null);
channel.QueueDeclare(queue: "weatherQueue", durable: true, exclusive: false, autoDelete: false, arguments: null);


//----------绑定交换机和队列---------
//3.1.匹配 routingKey: "China.#" 的消息进入队列 ChinaQueue
channel.QueueBind(queue: "ChinaQueue", exchange: "TopicExchange", routingKey: "China.#", arguments: null);

//3.2.匹配 routingKey: "#.news" 的消息进入队列 newsQueue
channel.QueueBind(queue: "newsQueue", exchange: "TopicExchange", routingKey: "#.news", arguments: null);

//3.3.匹配 routingKey: "#.weather" 的消息进入队列 weatherQueue
channel.QueueBind(queue: "weatherQueue", exchange: "TopicExchange", routingKey: "#.weather", arguments: null);


//4.发送消息：各种路由键（绑定键）的各个消息
{
//"China.news"
string message = "来自中国的新闻消息。。。。";
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: "TopicExchange", routingKey: "China.news", basicProperties: null, body: body);
Console.WriteLine($"消息【{message}】已发送到队列");
}

{
//routingKey: "China.weather"
string message = "来自中国的天气消息。。。。";
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: "TopicExchange", routingKey: "China.weather", basicProperties: null, body: body);
Console.WriteLine($"消息【{message}】已发送到队列");
}
{
//routingKey: "usa.news" 
string message = "来自美国的新闻消息。。。。";
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: "TopicExchange", routingKey: "usa.news", basicProperties: null, body: body);
Console.WriteLine($"消息【{message}】已发送到队列");
} 
{
//routingKey: "usa.weather"
string message = "来自美国的天气消息。。。。";
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: "TopicExchange", routingKey: "usa.weather", basicProperties: null, body: body);
Console.WriteLine($"消息【{message}】已发送到队列");
} 

{
    //----------routingKey: "xxx.yyyy",将被丢弃，因为没有队列与其匹配----------
    string message = "垃圾数据。。。。";
    var body = Encoding.UTF8.GetBytes(message);
    channel.BasicPublish(exchange: "TopicExchange", routingKey: "xxx.yyyy", basicProperties: null, body: body);
     Console.WriteLine($"消息【{message}】，将被丢弃，因为没有队列与其匹配");
}
```

核心代码 解析：

主题类型（**type: ExchangeType.Topic**）的交换机绑定了3个队列：

```C#
//3.1.匹配 routingKey: "China.#" 的消息进入队列 ChinaQueue
channel.QueueBind(queue: "ChinaQueue", exchange: "TopicExchange", routingKey: "China.#", arguments: null);

//3.2.匹配 routingKey: "#.news" 的消息进入队列 newsQueue
channel.QueueBind(queue: "newsQueue", exchange: "TopicExchange", routingKey: "#.news", arguments: null);

//3.3.匹配 routingKey: "#.weather" 的消息进入队列 weatherQueue
channel.QueueBind(queue: "weatherQueue", exchange: "TopicExchange", routingKey: "#.weather", arguments: null);

```

如下消息，没有匹配上述两个队列的路由键，将被丢弃：

```C#
//----------routingKey: "xxx.yyyy",将被丢弃，因为没有队列与其匹配----------
string message = "垃圾数据。。。。";
var body = Encoding.UTF8.GetBytes(message);
channel.BasicPublish(exchange: "TopicExchange", routingKey: "xxx.yyyy", basicProperties: null, body: body);
Console.WriteLine($"消息【{message}】，将被丢弃，因为没有队列与其匹配");
```

> 当然，可以使用：备份交换器（英文名称为Alternate Exchange，简称AE，或者更直白地称之为“备胎交换器”。）来回收这些无法匹配路由规则的消息

运行输出：

```powershell
消息【来自中国的新闻消息。。。。】已发送到队列
消息【来自中国的天气消息。。。。】已发送到队列
消息【来自美国的新闻消息。。。。】已发送到队列
消息【来自美国的天气消息。。。。】已发送到队列
消息【垃圾数据。。。。】，将被丢弃，因为没有队列与其匹配
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617212795081.png" alt="1617212795081" style="zoom:80%;" />

> 生产者发有效的4条消息，被分到所有队列后，消息一共所示6条，
>
> （交换机分配给队列的消息是复制，而不是择其一）



消费者1：绑定队列 ChinaQueue，只关心中国

```C#
//定义消费者                                      
var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =>
{
    var body = ea.Body;
    var message = Encoding.UTF8.GetString(body.ToArray()); 
    Console.WriteLine($"接收成功！【{message}】");
};

//处理消息
channel.BasicConsume(queue: "ChinaQueue",
                     autoAck: true,
                     consumer: consumer);

Console.WriteLine("对来自于中国的消息比较感兴趣的 消费者");
```

运行输出：

```powershell
对来自于中国的消息比较感兴趣的 消费者
接收成功！【来自中国的新闻消息。。。。】
接收成功！【来自中国的天气消息。。。。】

```



消费者2：绑定队列 newsQueue，只关心新闻消息

```C#
//定义消费者                                      
var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =>
{
    var body = ea.Body;
    var message = Encoding.UTF8.GetString(body.ToArray());
    Console.WriteLine($"接收成功！【{message}】");
};

//处理消息
channel.BasicConsume(queue: "newsQueue",
                     autoAck: true,
                     consumer: consumer);

Console.WriteLine("对来新闻比较感兴趣的 消费者");
```

运行输出：

```powershell
对来新闻比较感兴趣的 消费者
接收成功！【来自中国的新闻消息。。。。】
接收成功！【来自美国的新闻消息。。。。】

```



消费者3：绑定队列 newsQueue，只关心天气

```C#
//定义消费者                                      
var consumer = new EventingBasicConsumer(channel);
consumer.Received += (model, ea) =>
{
    var body = ea.Body;
    var message = Encoding.UTF8.GetString(body.ToArray());
    Console.WriteLine($"接收成功！【{message}】");
};

//处理消息
channel.BasicConsume(queue: "weatherQueue",
                     autoAck: true,
                     consumer: consumer);

Console.WriteLine("对来天气感兴趣的 消费者");
```

运行输出：

```powershell
对来天气感兴趣的 消费者
接收成功！【来自中国的天气消息。。。。】
接收成功！【来自美国的天气消息。。。。】
```





##### Topic 交换机应用场景

1. 分组，可以根据交换机绑定队列的规则来指定不同的组；
2. 打标签



#### headers

headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。

**在绑定队列和交换器时制定一组键值对，**

**当发送消息到交换器时，**RabbitMQ会获取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果**完全匹配**则消息会路由到该队列，否则不会路由到该队列。

在绑定Queue与Exchange时指定一组键值对以及x-match参数，x-match参数是字符串类型，可以设置为any或者all。如果设置为any，意思就是只要匹配到了headers表中的任何一对键值即可，all则代表需要全部匹配。

**headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。**



```C#
channel.ExchangeDeclare(exchange: "HeaderExchange", type: ExchangeType.Headers, durable: false, autoDelete: false, arguments: null);
channel.QueueDeclare(queue: "HeaderExchangeAllqueue", durable: false, exclusive: false, autoDelete: false, arguments: null);
channel.QueueDeclare(queue: "HeaderExchangeAnyqueue", durable: false, exclusive: false, autoDelete: false, arguments: null);
Console.WriteLine("生产者准备就绪....");
channel.QueueBind(queue: "HeaderExchangeAllqueue", exchange: "HeaderExchange", routingKey: string.Empty,
                  arguments: new Dictionary<string, object> {
                      { "x-match","all"},
                      { "teacher","Richard"},
                      { "pass","123"}});   
{
    string message = "teacher和pass都相同时发送的消息";
    var props = channel.CreateBasicProperties();
    props.Headers = new Dictionary<string, object>() {
        { "teacher","Richard"},
        { "pass","123"}
    };
    var body = Encoding.UTF8.GetBytes(message);
    //基本发布，这个消息可以进入队列HeaderExchangeAllqueue
    channel.BasicPublish(exchange: "HeaderExchange",
                         routingKey: string.Empty,
                         basicProperties: props,
                         body: body);
    Console.WriteLine($"消息【{message}】已发送");
}
{
    //这个消息被丢弃
    string message = "teacher和pass有一个不相同时发送的消息";
    var props = channel.CreateBasicProperties();
    props.Headers = new Dictionary<string, object>() {
        { "teacher","Richard"},
        { "pass","234"}
    };
    var body = Encoding.UTF8.GetBytes(message); 
    channel.BasicPublish(exchange: "HeaderExchange",
                         routingKey: string.Empty,
                         basicProperties: props,
                         body: body);
    Console.WriteLine($"消息【{message}】已发送");
}
Console.WriteLine("**************************************************************");
{
    channel.QueueBind(queue: "HeaderExchangeAnyqueue",  exchange: "HeaderExchange", routingKey: string.Empty,
                      arguments: new Dictionary<string, object> {
                          { "x-match","any"},
                          { "teacher","Richard"},
                          { "pass","123"},});

    //这个消息进入两个队列
    string msg = "teacher和pass完全相同时发送的消息";
    var props = channel.CreateBasicProperties();
    props.Headers = new Dictionary<string, object>() {
        { "teacher","Richard"},
        { "pass","123"} 
    };
    var body = Encoding.UTF8.GetBytes(msg); 
    channel.BasicPublish(exchange: "HeaderExchange",
                         routingKey: string.Empty,
                         basicProperties: props,
                         body: body);
    Console.WriteLine($"消息【{msg}】已发送"); 
}

{
    //这个消息进入HeaderExchangeAnyqueue
    string msg = "teacher和pass有一个不相同时发送的消息";
    var props = channel.CreateBasicProperties();
    props.Headers = new Dictionary<string, object>() {
        { "teacher","Richard"},
        { "pass","234"}
    };
    var body = Encoding.UTF8.GetBytes(msg);
    channel.BasicPublish(exchange: "HeaderExchange",
                         routingKey: string.Empty,
                         basicProperties: props,
                         body: body);
    Console.WriteLine($"消息【{msg}】已发送");
}

}
```



##### headers交换机应用场景

- 不需要依赖Key
- 更多的时候，像这种Key Value 的键值，可能会存储在数据库中，那么我们就可以定义一个动态规则来拼装这个Key value ，从而达到消息灵活转发到不同的队列中去。。。
  Class-Student    China-Wuhan   存储在数据库中



## 消息确认机制



## 消息事务机制







## RabbitMQ集群

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617256338670.png" alt="1617256338670" style="zoom:80%;" />

集群架构
分布式架构

集群：还是多台服务器，没一台服务器都可以完成整个业务流程；

一个业务流程：分为十个步骤；
有多台服务器；每台服务器负责其中几个步骤；串联起来==分布式架构；



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617256463770.png" alt="1617256463770" style="zoom:80%;" />



**集群以后，除了队列以外，其它东西都是共享的**



集群类型：普通通集群、镜像集群

- 普通集群：结构同步，消息实体只存在一个节点中，但 consumer 在非消息节点获取时，节点间存在消息拉取，易产生性能瓶颈。
- 镜像集群：集群中一个 master，负责调试，处理消息实体，其他节点保存一份数据到本地；性能主要靠 master 承载。



### 普通集群

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617256551755.png" alt="1617256551755" style="zoom:80%;" />



### 



### RabbtiMQ集群实操

#### 环境描述

##### 操作系统

| IP地址          | 主机名称 | 操作系统版本 | erlang 版本 | rabbitmq 版本 |
| --------------- | -------- | ------------ | ----------- | ------------- |
| 192.168.130.129 | centos-1 | CentOS-7.6   | V11.2       | 3.8.14        |
| 192.168.130.130 | centos-2 | CentOS-7.6   | V11.2       | 3.8.14        |
| 192.168.130.131 | centos-3 | CentOS-7.6   | V11.2       | 3.8.14        |

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617680144974.png" alt="1617680144974" style="zoom:80%;" />

##### 设置静态IP

```shell
命令：
# cd /etc/sysconfig/network-scripts/
# vim ifcfg-ens33

修改内容为：
TYPE=Ethernet
PROXY_METHOD=none

BOOTPROTO=static #静态IP

BROWSER_ONLY=no
DEFROUTE=yes

IPADDR=192.168.130.129  #调整
NETMASK=255.255.255.0  #调整
GATEWAY=192.168.1.1   #调整
DNS1=202.106.0.20    #调整

DNS2=8.8.8.8
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=312fb2fd-eade-4e6f-8abb-5602fc8d2da4
DEVICE=ens33

ONBOOT=yes  # 支持静态IP


修改完毕后：执行命令：
# service network restart
重启网卡：
# systemctl restart network
```



##### 修改主机名

```powershell
查看主机名称：
# hostname
修改主机名称：
# hostnamectl set-hostname <主机名称> ## 永久修改了主机名称
```



##### 文件配置

编辑/etc/hosts 文件配置

```shell
#追加
192.168.130.129 centos-1
192.168.130.130 centos-2
192.168.130.131 centos-3
```



##### 关闭防火墙

```shell
查看防火墙：
# systemctl status  firewalld.service
开启防火墙：
# systemctl start firewalld.service    
关闭防火墙
# systemctl stop firewalld.service           #停止firewall
# systemctl disable firewalld.service        #禁止firewall开机启动
```



#### 安装

##### 安装环境依赖包

这里虚拟机系统为Centos7，采用的安装方式是yum安装，为了简单，这里直接使用官方提供的erlang和RabbitMQ-server的自动安装脚本([官方安装文档](https://www.rabbitmq.com/install-rpm.html))，逐行执行下边的代码就可以安装完成erlang和RabbitMQ。

```she
安装socat
# yum install socat
```

##### 安装 erlang

rabbitMQ 是用 erlang 语言写的，所以需要先安装 erlang。

```shell
# curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash
# yum -y install erlang

测试查看版本：
# erl
```



##### 安装 rabbitmq

```shell
# curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash
# yum -y install rabbitmq-server

测试查看版本：rabbitmqctl version
```



##### 启动rabbitmq服务

```shell
启动：
# systemctl start rabbitmq-server
停止：
# rabbitmqctl stop_app

# 查看服务状态
# systemctl status rabbitmq-server

#开启启动服务
# systemctl enable rabbitmq-server
```



##### 添加web管理插件

```shell
插件列表
# rabbitmq-plugins list

开启web管理插件
# rabbitmq-plugins enable rabbitmq_management
```



#### 设置 rabbitMQ

##### 开启 rabbitMQ web 页面访问

```shell
# rabbitmq-plugins enable rabbitmq_management
也可以直接将开启的插件配置写入配置文件
# echo "[rabbitmq_management]." > /usr/local/rabbitmq/etc/rabbitmq/enabled_plugins

外网访问，防火墙开发端口15672
# firewall-cmd --add-port=15672/tcp --permanent ## web管理界面端口
# firewall-cmd --reload ## 刷新放行列表
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617683423283.png" alt="1617683423283" style="zoom:80%;" />



##### 启动 rabbitmq-server

```shell
# rabbitmq-server start    # 前台启动

  ##  ##
  ##  ##      RabbitMQ 3.7.7. Copyright (C) 2007-2018 Pivotal Software, Inc.
  ##########  Licensed under the MPL.  See http://www.rabbitmq.com/
  ######  ##
  ##########  Logs: /usr/local/rabbitmq/var/log/rabbitmq/rabbit@centos-3.log
                    /usr/local/rabbitmq/var/log/rabbitmq/rabbit@centos-3_upgrade.log

              Starting broker...
 completed with 3 plugins.    # 说明 web 管理插件已经启动


# rabbitmq-server  -detached    # 后台启动，不占用终端，推荐
Warning: PID file not written; -detached was passed.7

# rabbitmq-server start_app
# rabbitmq-server stop_app
```



##### 管理账号

```shell
默认有一个属于localhost的用户guest 密码guest，不支持远程访问(只用使用localhost访问)，怎么解决?
1、使用rabbitmqctl来管理用户
# whereis rabbitmq
# cd /usr/lib/rabbitmq/bin

[root@centos-1 ~]# rabbitmqctl list_users
Listing users ...
user    tags
guest   [administrator]


./rabbitmqctl add_user rabbit rabbit ## 添加用户
./rabbitmqctl set_permissions rabbit -p / ".*" ".*" ".*"
./rabbitmqctl set_user_tags rabbit administrator
2、添加端口
# firewall-cmd --add-port=5672/tcp --permanent ## rabbitmq端口
# firewall-cmd --add-port=15672/tcp --permanent ## web管理界面端口
# firewall-cmd --reload ## 刷新放行列表
3、通过http://ip:15672
输入rabbit/rabbit 进行web管界面
```



##### RabbitMQ 端口

★这里有一个需要注意**，记得配置下hosts，在/etc/hosts里加上本机的名称。erlang进程需要host来进行连接，所以它会检查你的hosts配置。还需要设置下防火墙，三个端口要打开。**15672**是管理界面用的，**25672是集群之间使用的端口，4369是erlang进程epmd用来做node连接的。

```shell
1.查看放行端口：
# firewall-cmd --list-port
2、添加端口
# firewall-cmd --add-port=5672/tcp --permanent   ## rabbitmq端口
# firewall-cmd --add-port=15672/tcp --permanent  ## web管理界面端口
# firewall-cmd --add-port=4369/tcp --permanent   ##node通信端口
# firewall-cmd --reload ## 刷新放行列表
```



#### 集群配置

##### 准备工作

| IP地址          | 主机名称 | 操作系统版本 | erlang 版本 | rabbitmq 版本 |
| --------------- | -------- | ------------ | ----------- | ------------- |
| 192.168.130.129 | centos-1 | CentOS-7.6   | V11.2       | 3.8.14        |
| 192.168.130.130 | centos-2 | CentOS-7.6   | V11.2       | 3.8.14        |
| 192.168.130.131 | centos-3 | CentOS-7.6   | V11.2       | 3.8.14        |



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617687976871.png" alt="1617687976871" style="zoom:80%;" />



编辑/etc/hosts 文件配置映射

```shell

# 每台Linux虚拟机都编辑为：
# vim /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.130.129 centos-1
192.168.130.130 centos-2
192.168.130.131 centos-3

# 或者把一个编辑好的复制到其它主机上 
# scp /etc/hosts root@192.168.130.130:/etc/hosts 
# scp /etc/hosts root@192.168.130.131:/etc/hosts 

```

启动RabbitMQ，防火墙放行端口

```shell
命令执行启动前台启动rabbitmq服务：
# rabbitmq-server start

命令执行启动后台启动rabbitmq服务：
# rabbitmq-server  -detached

命令执行停止RabbitMq服务： 
# rabbitmqctl stop

命令执行启用插件：
# rabbitmq-plugins enable rabbitmq_management

查看rabbitMq进程：
# ps -ef | grep rabbitmq


1.查看放行端口：
# firewall-cmd --list-port

2关闭端口：
# firewall-cmd --permanent --zone=public --remove-port=5672/tcp
# firewall-cmd --permanent --zone=public --remove-port=15672/tcp
# firewall-cmd --permanent --zone=public --remove-port=4369/tcp
# firewall-cmd --permanent --zone=public --remove-port=25672/tcp

3、添加端口
# firewall-cmd --add-port=5672/tcp --permanent ## rabbitmq端口
# firewall-cmd --add-port=15672/tcp --permanent ## web管理界面端口
# firewall-cmd --add-port=4369/tcp --permanent ##node erlang通信端口
# firewall-cmd --add-port=25672/tcp --permanent ##node 集群节点通信

# firewall-cmd --reload ## 刷新放行列表
```

>集群管理：没有明显的主从，主要是 disk 和 ram 节点的区别
>
>集群要求：不支持跨网段(erlang 限制)【局域网】
>
>集群类型：普通通集群、镜像集群
>
>- 普通集群：结构同步，消息实体只存在一个节点中，但 consumer 在非消息节点获取时，节点间存在消息拉取，易产生性能瓶颈。
>- 镜像集群：集群中一个 master，负责调试，处理消息实体，其他节点保存一份数据到本地；性能主要靠 master 承载。
>
>持久化，分两部分：
>
>- Rabbitmq 服务器配置持久化：默认的就是持久化(disc类型);
>- 代码持久化：默认情况下，代码创建的消息队列和存放在队列里的消息都是非持久化的，需要在建产队列时指定
>
>



**在配置群集前，必须保证各节点之间的主机名能够相互解析**

RabbitMQ 节点使用域名相互寻址，因此所有群集成员的主机名必须能够从所有群集节点解析，可以修改 `/etc/hosts` 文件或者使用 DNS 解析

如果要使用节点名称的完整主机名（RabbitMQ 默认为短名称），并且可以使用DNS解析完整的主机名，则可能需要调查设置环境变量  `RABBITMQ_USE_LONGNAME = true`

一个群集的组成可以动态改变，所有的 RabbitMQ 开始作为单个节点运行，这些节点可以加入到群集，然后也可以再次脱离群集转加单节点。

RabbitMQ 群集可以容忍单个节点的故障。节点可以随意启动和停止，只要它们在关闭时能和群集成员节点联系。

**节点可以是 Disk 节点或 RAM 节点**

RAM 节点将内部数据库表存储在 RAM 中。这不包括消息，消息存储索引，队列索引和其他节点状态，在 90％ 以上的情况下，您希望所有节点都是磁盘节点;

RAM 节点是一种特殊情况，可用于改善高排队，交换或绑定流失的性能集群。RAM 节点不提供有意义的更高的消息速率。

由于 RAM 节点仅将内部数据库表存储在 RAM 中，因此它们必须在启动时从对等节点同步它们。这意味着**群集必须至少包含一个磁盘节点。因此无法手动删除集群中剩余的最后一个磁盘节点**



##### 设置节点相互信任：Erlang Cookie

RabbitMQ 节点和 CLI 工具（例如 rabbitmqctl ）使用 cookie 来确定它们是否被允许相互通信，要使两个节点能够通信，它们必须具有相同的共享密钥，称为 Erlang Cookie。 Cookie 只是一个字符串，最多可以有 255 个字符。

```shell
[root@centos-1 ~]# cat /var/lib/rabbitmq/.erlang.cookie
UFBDMSIYOKOGGVFJHPUI
```

它通常存储在本地文件中。**该文件必须只能由所有者访问（400 权限）**。每个集群节点必须具有相同的 cookie，文件位置（rpm 安装） /var/lib/rabbitmq/.erlang.cookie，如果是源码安装的 .erlang.cookie 文件在**启动用户的家目录中**。把 rabbit2、rabbit3 设置成和 rabbit1 一样的即可，权限是 400 ，或者直接复制一份过去即可。

```shell
这里采用复制的方式

命令Copy文件：
# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.130.130:/var/lib/rabbitmq
# scp /var/lib/rabbitmq/.erlang.cookie root@192.168.130.131:/var/lib/rabbitmq

采用源码安装的 rabbitmq .erlang.cookie 文件在 /root 目录下
# scp /root/.erlang.cookie centos-2:/root/
root@centos-2's password: 
.erlang.cookie   100%   20     2.3KB/s   00:00    
# scp /root/.erlang.cookie centos-3:/root/
root@centos-3's password: 
.erlang.cookie   100%   20     7.5KB/s   00:00 
```



##### 正常方式启动所有节点

```shell
# rabbitmq-server -detached   #后台启动  在所有节点上启动 rabbitmq-server
```



##### 查看群集状态

centos-1:

```shell
[root@centos-1 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@centos-1 ...
Basics

Cluster name: rabbit@centos-1

Disk Nodes

rabbit@centos-1

Running Nodes

rabbit@centos-1

Versions

rabbit@centos-1: RabbitMQ 3.8.14 on Erlang 23.3.1

Maintenance status

Node: rabbit@centos-1, status: not under maintenance

Alarms

(none)

Network Partitions

(none)

Listeners

Node: rabbit@centos-1, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@centos-1, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@centos-1, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

Feature flags

Flag: drop_unroutable_metric, state: disabled
Flag: empty_basic_get_metric, state: disabled
Flag: implicit_default_bindings, state: enabled
Flag: maintenance_mode_status, state: enabled
Flag: quorum_queue, state: enabled
Flag: user_limits, state: enabled
Flag: virtual_host_metadata, state: enabled

```

centos-2:

```shell
[root@centos-2 ~]# abbitmqctl cluster_status
bash: abbitmqctl: 未找到命令...
[root@centos-2 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@centos-2 ...
Basics

Cluster name: rabbit@centos-2

Disk Nodes

rabbit@centos-2

Running Nodes

rabbit@centos-2

Versions

rabbit@centos-2: RabbitMQ 3.8.14 on Erlang 23.3.1

Maintenance status

Node: rabbit@centos-2, status: not under maintenance

Alarms

(none)

Network Partitions

(none)

Listeners

Node: rabbit@centos-2, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@centos-2, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@centos-2, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

Feature flags

Flag: drop_unroutable_metric, state: disabled
Flag: empty_basic_get_metric, state: disabled
Flag: implicit_default_bindings, state: enabled
Flag: maintenance_mode_status, state: enabled
Flag: quorum_queue, state: enabled
Flag: user_limits, state: enabled
Flag: virtual_host_metadata, state: enabled

```



##### 创建群集

**a. 停止 centos-02 的 rabbitmq 应用程序**

```shell
# 在其余节点上操作
关闭所有rabbitmq进程：  pkill rabbitmq
根据进程ID关闭进程: kill -9 9038

#只执行下面命名即可
[root@centos-2 ~]# rabbitmqctl stop_app
Stopping rabbit application on node rabbit@centos-2 ...

```

**b. 加入 rabbit@centos-1 群集1**

```shell
# 在其余节点上操作
[root@centos-2 ~]# rabbitmqctl join_cluster rabbit@centos-1
Clustering node rabbit@centos-2 with rabbit@centos-1
   
# 如果这一步报错的话，请在所有节点打开相应的端口，打开 4369 端口 （Refuse Access）,解决方式
# firewall-cmd --add-port=4369/tcp --permanent
# firewall-cmd --add-port=25672/tcp --permanent #rabbitmq 节点间的CLI通信端口
 
# firewall-cmd --reload
```



**c. 启动 rabbitMQ 程序**

```shell
# 在其余个节点上操作
#  rabbitmqctl start_app
[root@centos-2 ~]# rabbitmqctl start_app
Starting node rabbit@centos-2 ...

```



**b. 查看群集状态**

```shell
在群集任何一个节点上都可以查看到群集的状态
[root@centos-2 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@centos-2 ...
Basics

Cluster name: rabbit@centos-1

Disk Nodes

rabbit@centos-1
rabbit@centos-2

Running Nodes

rabbit@centos-1
rabbit@centos-2

Versions

rabbit@centos-1: RabbitMQ 3.8.14 on Erlang 23.3.1
rabbit@centos-2: RabbitMQ 3.8.14 on Erlang 23.3.1

Maintenance status

Node: rabbit@centos-1, status: not under maintenance
Node: rabbit@centos-2, status: not under maintenance

Alarms

(none)

Network Partitions

(none)

Listeners

Node: rabbit@centos-1, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@centos-1, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@centos-1, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0
Node: rabbit@centos-2, interface: [::], port: 15672, protocol: http, purpose: HTTP API
Node: rabbit@centos-2, interface: [::], port: 25672, protocol: clustering, purpose: inter-node and CLI tool communication
Node: rabbit@centos-2, interface: [::], port: 5672, protocol: amqp, purpose: AMQP 0-9-1 and AMQP 1.0

Feature flags

Flag: drop_unroutable_metric, state: disabled
Flag: empty_basic_get_metric, state: disabled
Flag: implicit_default_bindings, state: enabled
Flag: maintenance_mode_status, state: enabled
Flag: quorum_queue, state: enabled
Flag: user_limits, state: enabled
Flag: virtual_host_metadata, state: enabled

```

![1617716310111](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617716310111.png)

通过上面的步骤，我们可以在群集运行的同时随时向群集添加新节点

已加入群集的节点可以随时停止，也可以崩溃。在这两种情况下，群集的其余部分都会继续运行，并且节点在再次启动时，会自动 ”跟上“（同步）其它群集节点。



比如：停掉`rabbit@centos-3`节点：

```shell
[root@centos-3 ~]# rabbitmqctl stop_app
Stopping rabbit application on node rabbit@centos-3 ...
```

在节点1中查看集群状态:

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617718263458.png" alt="1617718263458" style="zoom:80%;" />

```shell
[root@centos-1 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@centos-1 ...
Basics

Cluster name: rabbit@centos-1

Disk Nodes

rabbit@centos-1
rabbit@centos-2
rabbit@centos-3

Running Nodes

rabbit@centos-1
rabbit@centos-2

```



再启动`rabbit@centos-3`节点 ：

```shell
[root@centos-3 ~]# rabbitmqctl start_app
Starting node rabbit@centos-3 ...
```

在节点1中查看集群状态:

```shell
[root@centos-1 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@centos-1 ...
Basics

Cluster name: rabbit@centos-1

Disk Nodes

rabbit@centos-1
rabbit@centos-2
rabbit@centos-3

Running Nodes

rabbit@centos-1
rabbit@centos-2
rabbit@centos-3

```

![1617718474572](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617718474572.png)



> 注意：
>
> 当整个集群关闭时，最后一个关闭的节点必须是第一个启动的节点，如果不是这样，节点会等待 30s 等待最后的磁盘节点恢复状态，然后失败。如果最后下线的节点不能上线，可以使用 forget_cluster_node 命令将其从群集中删除。如果所有的节点不受控制的同时宕机，比如掉电，会进入所有的节点都会认为其他节点比自己宕机的要晚，即自己先宕机，这种情况下可以使用 force_boot 指令来启动一个节点。



###### **普通队列(集群)**

 exchange，buindling再所有的节点上都会保存一份，但是queue只会存储在其中的一个节点上，但是所有的节点都会存储一份queue的meta信息 

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617724058505.png" alt="1617724058505" style="zoom:80%;" />

> 注意：集群后，各节点除队列(队列的结构是共享的，但是消息不共享)外，其它都是共享的

到目前为止，集群的方式是普通集群，通过集群方式连接后，会选择一个节点创建队列并存储消息，其它集群的记得也能看到队列消息，但是，其它节点看到的队列消息是来自某个节点：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617722071071.png" alt="1617722071071" style="zoom:80%;" />

这时，**把节点1停掉, **

```shell
[root@centos-1 ~]# rabbitmqctl stop_app
Stopping rabbit application on node rabbit@centos-1 ...
```

这时的队列状态是：down，如下图所示

![1617723222400](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617723222400.png)

**消息来自节点1，消费者将无法消费消息，因为真正的数据在节点1上**

>节点1停止后，消费者连接节点2消费消息，会抛出异常：
>
>The AMQP operation was interrupted: AMQP close-reason, initiated by Peer, code=404, text='NOT_FOUND - home node 'rabbit@centos-1' of durable queue 'ColonyProducerMessage' in vhost '/' is down or inaccessible', classId=60, methodId=20



综上：

**普通集群方式，无法达到真正的高可用**，要实现真正的高可用，得使用镜像集群



###### 镜像队列(集群)

每一个节点都是队列结构+消息数据

任何一个单机宕机了，可以切换到其他单机消费消息；如果宕机的单机恢复了，消息可以自动同步；

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617724408120.png" alt="1617724408120" style="zoom:80%;" />



**d. 设置群集模式为"镜像队列"模式**



```shell
# rabbitmqctl set_policy ha-all "^" '{"ha-mode":"all","ha-sync-mode":"automatic"}'

rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]


-p Vhost： 可选参数，针对指定vhost下的queue进行设置
Name: policy的名称
Pattern: queue的匹配模式(正则表达式)
    注意："^"，这个规则要根据自己修改，比如："^ha\."，这个是指同步"ha."开头的队列名称
    
Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode
	ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes
		all：表示在集群中所有的节点上进行镜像
		exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定
		nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定
	ha-params：ha-mode模式需要用到的参数
	ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual
priority：可选参数，policy的优先级
```

`ha-sync-mode`： 如果此节点不进行设置，在其中一台服务器宕机再启动后 会报  Unsynchronised Mirrors XXXX  错误。这时候在队列详细信息页面需要手动点击同步队列，或者用命令行执行命令 `rabbitmqctl sync_queue name`



下面的命令，把队列设置为镜像队列，可以在集群中的任意一个节点中执行：

```shell
[root@centos-3 ~]# rabbitmqctl set_policy ha-all "^" '{"ha-mode":"all","ha-sync-mode":"automatic"}'
Setting policy "ha-all" for pattern "^" to "{"ha-mode":"all","ha-sync-mode":"automatic"}" with priority "0" for vhost "/" ...

```

设置了镜像队列后，队列的信息有了变化，如下图所示：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617726634148.png" alt="1617726634148" style="zoom:80%;" />

> 交换机的特性也发生了变化：
>
> <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617726725737.png" alt="1617726725737" style="zoom:80%;" />



**验证镜像队列的高可用**

消费者使用集群IP列表创建连接，如下所示：

```shell
var factory = new ConnectionFactory();
//factory.HostName = "192.168.130.129";//RabbitMQ服务在本地运行
factory.Port = 5672;
factory.UserName = "rabbit";//用户名
factory.Password = "rabbit";//密码 
factory.VirtualHost = "/";  //虚拟主机，默认斜杠
using (var connection = factory.CreateConnection(new List<string>() {
"192.168.130.129",
"192.168.130.130",
"192.168.130.131"
}))
{
    using (IModel channel = connection.CreateModel())
    {
        //监听消息
    }
 }
```

这时，消费者从上IP列表中随机连接一个节点, 这里假设是连接节点2，

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617727619812.png" alt="1617727619812" style="zoom:80%;" />

这时，停止掉消费者连接的节点2：

```shell
[root@centos-2 ~]# rabbitmqctl start_app
Starting node rabbit@centos-2 ...
```

**等待大概10秒左右，消费者会自动切换到集群的其它节点（这里是节点1）**

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617727702311.png" alt="1617727702311" style="zoom:80%;" />



在节点2被停止的这段时间了，新增的队列和消息，在节点2恢复后，自动同步，如下图所示：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617766633956.png" alt="1617766633956" style="zoom:80%;" />



#### 群集移除节点

当节点不再是节点的一部分时，需要从群集中明确地删除节点。

将 rabbit@centos-2 从群集中删除，回到独立模式

```shell
在 rabbit@centos-2 上操作：
1、停止 RabbitMQ 应用程序。
# rabbitmqctl stop_app
Stopping rabbit application on node rabbit@centos-2 ...

2、重置节点。
# rabbitmqctl reset
Resetting node rabbit@centos-2 ...

3、重新启动 RabbitMQ 应用程序。
# rabbitmqctl start_app
Starting node rabbit@centos-2 ...
 completed with 3 plugins.
 
4、在节点上运行 cluster_status 命令，确认 rabbit@centos-2 现在已经不再是群集的一部分，并独立运行
# rabbitmqctl cluster_status
```



也可以远程删除节点，例如，在处理无响应的节点时，这很有用。

例如，在节点 rabbit@node01 上把 rabbit@centos-3 从群集中移除

```shell
1、先在 rabbit@centos-3 上将 RabbitMQ 应用停掉
# rabbitmqctl stop_app
Stopping rabbit application on node rabbit@centos-3 ...

2、在 rabbit@node01 上远程将 rabbit@centos-3 删除
# rabbitmqctl forget_cluster_node rabbit@centos-3
Removing node rabbit@centos-3 from the cluster

3、请注意，这时，rabbit@centos-3 仍然认为它还在 rabbit@node01 的群集里面，并试图启动它，这将会导致错误。我们需要将 rabbit@centos-3 重新设置才能重新启动它。(在 rabbit@centos-3 上操作)
[root@centos-3 ~]# rabbitmqctl start_app
Starting node rabbit@centos-3 ...
Error:
{:rabbit, {{:inconsistent_cluster, 'Node \'rabbit@centos-3\' thinks it\'s clustered with node \'rabbit@centos-1\', but \'rabbit@centos-1\' disagrees'}, {:rabbit, :start, [:normal, []]}}}

# rabbitmqctl reset
Resetting node rabbit@centos-3 ...

4、重新启动 rabbit@centos-3
# rabbitmqctl start_app
Starting node rabbit@centos-3 ...
```

> rabbitmqctl reset
>
> 该命令会删除，交换机，队列，账号（只保留原始的guet账号）





现在，三个节点都是作为独立的节点在运行。

> 注意：此时，rabbit@node01 保留了簇的剩余状态，而 rabbicentos-202 和 rabbit@centos-3 是刚刚初始化的 RabbitMQ。如果想重新初始化 rabbit@node01 的话，需要按照与其它节点相同的步骤进行即可：
>
> 1、停止 RabbitMQ 应用程序
>
> 2、 重置 RabbitMQ
>
> 3、启动 RabbitMQ 应用程序



#### 使用集群

**生产者**

连接集群

```C#
ConnectionFactory factory = new ConnectionFactory();
//factory.HostName = "192.168.130.129";//RabbitMQ服务在本地运行 

factory.Port = 5672;
factory.UserName = "rabbit";//用户名
factory.Password = "rabbit";//密码 
//factory.AutomaticRecoveryEnabled = true; //如果connection挂掉是否重新连接 
//factory.TopologyRecoveryEnabled = true;//连接恢复后，连接的交换机，队列等是否一同恢复 
factory.VirtualHost = "/";  //虚拟主机，默认斜杠
using (var connection = factory.CreateConnection(new List<string>() {
    "192.168.130.129",
    "192.168.130.130",
    "192.168.130.131"
}))
{

    using (IModel channel = connection.CreateModel())
    {
            //发送消息代码，见下
    }
}
```

使用集群发送消息

```shell
channel.QueueDeclare(queue: "ColonyProducerMessage", durable: true, exclusive: false, autoDelete: false, arguments: null);

channel.ExchangeDeclare(exchange: "ColonyProducerMessageExChange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);

channel.QueueBind(queue: "ColonyProducerMessage", exchange: "ColonyProducerMessageExChange", routingKey: "ColonyProducerMessageExChangeKey", arguments: null);

Console.ForegroundColor = ConsoleColor.Red;
Console.WriteLine("生产者ColonyProducerDemo已准备就绪~~~");
int i = 1;

while (true)
{
    IBasicProperties basicProperties = channel.CreateBasicProperties();
    basicProperties.Persistent = true;
    string message = $"消息{i}";
    byte[] body = Encoding.UTF8.GetBytes(message);
    channel.BasicPublish(exchange: "ColonyProducerMessageExChange",
    routingKey: "ColonyProducerMessageExChangeKey",
    basicProperties: basicProperties,
    body: body);
    Console.WriteLine($"集群消息：{message} 已发送~");
    i++;
    Thread.Sleep(10);

    if (i >= 200)
    {
       break;
    }
}
```



**消费者**：

```she
var factory = new ConnectionFactory();
            //factory.HostName = "192.168.130.129";//RabbitMQ服务在本地运行
            factory.Port = 5672;
            factory.UserName = "rabbit";//用户名
            factory.Password = "rabbit";//密码 
            factory.VirtualHost = "/";  //虚拟主机，默认斜杠
            using (var connection = factory.CreateConnection(new List<string>() {
                    "192.168.130.129",
                    "192.168.130.130",
                    "192.168.130.131"
            }))
            {
                using (IModel channel = connection.CreateModel())
                {
                    #region EventingBasicConsumer
                    //定义消费者                                      
                    var consumer = new EventingBasicConsumer(channel);
                    int i = 0;
                    consumer.Received += (model, ea) =>
                    {
                        var message = Encoding.UTF8.GetString(ea.Body.ToArray()); 
                        //手动确认  消息正常消费  告诉Broker：你可以把当前这条消息删除掉了
                        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);
                        Console.WriteLine(message);
                        Thread.Sleep(2000);
                    };
                    //autoAck: false  显示确认； 
                    channel.BasicConsume(queue: "ColonyProducerMessage", autoAck: false, consumer: consumer); 
                    Console.ReadKey();
                    #endregion
                }
            }
        }
```



## 生产端消息确认

生产端如何知道Broker收到消息呢

### Tx事务模式

基于AMPQ协议；可以让信道设置成一个带事务的信道，从AMQP协议层面上来的事务模式，分为三步：
channel.TxSelect(); 开启一个事务
channel.TxCommit();提交事务
channel.TxRollback(); //事务回滚

**事务模式是同步模式，在事务提交之前不能继续发送消的，所以事务模式效率差一些；**



**示例**

```shell
//创建通道channel
using (var channel = connection.CreateModel())
{
    Console.WriteLine("生产者准备就绪....");
    channel.QueueDeclare(queue: "MessageTxQueue01", durable: true, exclusive: false, autoDelete: false, arguments: null);
    channel.QueueDeclare(queue: "MessageTxQueue02", durable: true, exclusive: false, autoDelete: false, arguments: null);
    //声明交换机exchang
    channel.ExchangeDeclare(exchange: "MessageTxQueueExchange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);
    //绑定exchange和queue
    channel.QueueBind(queue: "MessageTxQueue01", exchange: "MessageTxQueueExchange", routingKey: "MessageTxKey01");
    channel.QueueBind(queue: "MessageTxQueue02", exchange: "MessageTxQueueExchange", routingKey: "MessageTxKey02");
    string message = "";
    
//发送消息
//在控制台输入消息，按enter键发送消息
while (!message.Equals("quit", StringComparison.CurrentCultureIgnoreCase))
{
    message = Console.ReadLine();
    var body = Encoding.UTF8.GetBytes(message);
    try
    {
        //开启事务机制
        channel.TxSelect(); //事务是协议支持的
        //发送消息
        //同时给多个队列发送消息；要么都成功；要么都失败；
        channel.BasicPublish(exchange: "MessageTxQueueExchange", routingKey: "MessageTxKey01", basicProperties: null, body: body);
        channel.BasicPublish(exchange: "MessageTxQueueExchange", routingKey: "MessageTxKey02", basicProperties: null, body: body);

        //模拟异常
        //int i = 0;
        //int j = 1;
        //int b = j / i;

        //事务提交
        channel.TxCommit(); //只有事务提交成功以后，才会真正的写入到队列里面去
        Console.WriteLine($"【{message}】发送到Broke成功！");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"【{message}】发送到Broker失败！");
        channel.TxRollback(); //事务回滚
        //可以在这里还重试一下。。。
        throw;
    }
}
```



### Confirm模式

生产者将信道设置成confirm（确认）模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一ID），这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。RabbitMQ回传给生产者的确认消息中的deliveryTag包含了确认消息的序号，此外RabbitMQ也可以设置channel.basicAck方法中的multiple参数，表示到这个序号之前的所有消息都已经得到了处理

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617767216573.png" alt="1617767216573" style="zoom:80%;" />

注意辨别这里的确认(生产端的确认，是上图左边部分)和消费时候的确认(上图右边部分)之间的异同,



就是应答模式，生产者发送一条消息之后，Rabbitmq服务器做了个响应，OK,收到了；

**Confirm模式是异步模式**，在应答之前，可以继续发送消息；单条消息、批量消息

**RabbitMQ引入了publisher confirm机制来弥补事务机制的缺陷，提高了整体的吞吐量**



**生产端确认**

1  单条消息确认： channel.waitForConfirms()
2  批量消息确认： channel.waitForConfirmsOrDie()批量确认模式 
3  异步监听消息确认：channel.addConfirmListener()

channel.ConfirmSelect();开启确认模式
消息发送以后，提供一个回执方法WaitForConfirms(); 返回一个bool 值；



**示例**

```shell
Console.WriteLine("生产者准备就绪....");
channel.QueueDeclare(queue: "ConfirmSelectQueue", durable: true, exclusive: false, autoDelete: false, arguments: null);
//声明交换机exchang
channel.ExchangeDeclare(exchange: "ConfirmSelectQueueExchange", type: ExchangeType.Direct, durable: true, autoDelete: false, arguments: null);
//绑定exchange和queue
channel.QueueBind(queue: "ConfirmSelectQueue", exchange: "ConfirmSelectQueueExchange", routingKey: "ConfirmSelectKey");
string message = "";
//发送消息
//在控制台输入消息，按enter键发送消息
while (!message.Equals("quit", StringComparison.CurrentCultureIgnoreCase))
{
    message = Console.ReadLine();
    var body = Encoding.UTF8.GetBytes(message);
    try
    {
        //开启消息确认模式
        channel.ConfirmSelect();
        //发送消息
        channel.BasicPublish(exchange: "ConfirmSelectQueueExchange", routingKey: "ConfirmSelectKey", basicProperties: null, body: body);
        //事务提交 
        if (channel.WaitForConfirms()) //如果一条消息或多消息都确认发送
        {
           Console.WriteLine($"【{message}】发送到Broke成功！");
        }
        else
        { 
        //可以记录个日志，重试一下；
        }

        //如果所有消息发送成功 就正常执行；如果有消息发送失败；就抛出异常；
        channel.WaitForConfirmsOrDie();
        }
        catch (Exception)
        {
            Console.WriteLine($"【{message}】发送到Broker失败！");
            //就应该通知管理员
            // 重新试一下
        }
}
```



## 消费端消息确认

消费端消息确认

- 自动确认

  是消费消息的时候，只要收到消息，就直接回执给RabbitMQ，OK没问题；  

  存在的问题：如果只是消费成功了一条消息；RabbitMQ也会认为你是全部成功了，会把所有消息从队列中移除；这样会导致消息的丢失；

  ```shell
  //定义消费者                                      
  var consumer = new EventingBasicConsumer(channel);
  int i = 0;
  consumer.Received += (model, ea) =>
  {
      var message = Encoding.UTF8.GetString(ea.Body.ToArray()); 
      Console.WriteLine(message);
      Thread.Sleep(2000);
  };
  //autoAck: true  自动确认； 
  channel.BasicConsume(queue: "ColonyProducerMessage", autoAck: ture, consumer: consumer); 
  Console.ReadKey();
  ```

  只有要在`var message = ....`这行代码打一个断点，只要有一条消息被消费，消息队列里面的消息马上清空，队列里的消息给默认分给该消费者，其它消费者是没有分配到消息，如下图所示：

  <img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E4%BA%8C)/1617782009411.png" alt="1617782009411" style="zoom:80%;" />

​         **此时，消费者端可以进行消费消息，但是自动确认留下一个严重的隐患是：**

​         **如果消费者端在出现异常，重启消费者后，再也无法消费未消费的消息**



- 显示确认

  又称手动确认，消费者消费一条，回执给RabbitMq一条消息，Rabbitmq 只删除当前这一条消息；相当于是一条消费了，删除一条消息；
  性能稍微低一些；

  ```shell
  //定义消费者                                      
  var consumer = new EventingBasicConsumer(channel);
  int i = 0;
  consumer.Received += (model, ea) =>
  {
      var message = Encoding.UTF8.GetString(ea.Body.ToArray());
      
      //手动确认  消息正常消费  告诉Broker：你可以把当前这条消息删除掉了
      channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);
      Console.WriteLine(message);
      Thread.Sleep(2000);
  };
  //autoAck: false  显示确认； 
  channel.BasicConsume(queue: "ColonyProducerMessage", autoAck: false, consumer: consumer); 
  Console.ReadKey();
  ```



综上，推荐使用 显示确认模式







