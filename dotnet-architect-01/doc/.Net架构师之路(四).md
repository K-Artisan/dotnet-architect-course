[TOC]

# 分布式锁

【Course 056】

## 秒杀场景

秒杀代码：

`NormalSecondsKill.cs`

```C#
public class NormalSecondsKill
{
    private static Userinfo olock = new Userinfo();
    public static void Show()
    {
        using (var client = new RedisClient("127.0.0.1", 6379,"123456"))
        {

            //库存数量
            var inventory = client.Get<int>("inventoryNum");
            if (inventory > 0)
            {
                //给库存-1
                client.Set<int>("inventoryNum", inventory - 1);
                //订单数量 +1
                var orderNum = client.Incr("orderNum");

                Console.WriteLine($"抢购成功*****线程id：{ Thread.CurrentThread.ManagedThreadId.ToString("00")},库存：{inventory},订单数量：{orderNum}");
            }
            else
            {
                Console.WriteLine("抢购失败");
            }
        }
    }
}
```

然后，模拟秒杀场景

```C#
static void Main(string[] args)
{
    //命令行参数启动
    //dotnet Zhaoxi.LockService.dll --minute=18
    var builder = new ConfigurationBuilder().AddCommandLine(args);
    var configuration = builder.Build();
    int minute = int.Parse(configuration["minute"]);
    using (var client = new RedisClient("127.0.0.1", 6379, "123456"))
    {

        //票的库存
        client.Set<int>("inventoryNum", 10);
        //订单数
        client.Set<int>("orderNum", 0);
    }
    //开启10个线程去抢购
    Console.WriteLine($"在{minute}分0秒正式开启秒杀！");
    var flag = true;
    while (flag)
    {
        //循环到这个时间（分钟）的时候，我们可以开始抢票
        if (DateTime.Now.Minute == minute)
        {
            flag = false;
            Parallel.For(0, 30, (i) =>
                         {
                             int temp = i;
                             Task.Run(() =>
                                      {
                                          NormalSecondsKill.Show();
                                      });
                         });
        }
    }


    Console.ReadKey();
}
```

在main 中设置库存 为 10, 开启 30个 并发线程模拟用户进行抢购， 运行程:

```powershell
dotnet Zhaoxi.LockService.dll --minute=42
```

输出结果：

```powershell
在42分0秒正式开启秒杀！
抢购成功*****线程id：10,库存：10,订单数量：5
抢购成功*****线程id：11,库存：10,订单数量：6
抢购成功*****线程id：06,库存：10,订单数量：4
抢购成功*****线程id：08,库存：10,订单数量：3
抢购成功*****线程id：05,库存：10,订单数量：1
抢购成功*****线程id：09,库存：10,订单数量：2
抢购成功*****线程id：07,库存：10,订单数量：7
抢购成功*****线程id：12,库存：10,订单数量：8
抢购成功*****线程id：10,库存：9,订单数量：9
抢购成功*****线程id：05,库存：8,订单数量：10
抢购成功*****线程id：09,库存：8,订单数量：12
抢购成功*****线程id：06,库存：8,订单数量：11
抢购成功*****线程id：08,库存：8,订单数量：13
抢购成功*****线程id：07,库存：7,订单数量：15
抢购成功*****线程id：10,库存：6,订单数量：16
抢购成功*****线程id：11,库存：7,订单数量：14
抢购成功*****线程id：12,库存：6,订单数量：17
抢购成功*****线程id：05,库存：5,订单数量：18
抢购成功*****线程id：06,库存：5,订单数量：19
抢购成功*****线程id：08,库存：5,订单数量：20
抢购成功*****线程id：09,库存：4,订单数量：22
抢购成功*****线程id：07,库存：4,订单数量：21
抢购成功*****线程id：10,库存：4,订单数量：23
抢购成功*****线程id：11,库存：3,订单数量：24
抢购成功*****线程id：12,库存：3,订单数量：25
抢购成功*****线程id：06,库存：2,订单数量：26
抢购成功*****线程id：05,库存：2,订单数量：27
抢购失败
抢购成功*****线程id：08,库存：1,订单数量：29
抢购成功*****线程id：09,库存：1,订单数量：28
```

库存总数为：10， 订单却为29。



## 对象锁

现在改进上一节的`NormalSecondsKill`的代码，为其加锁

```C#
private static object olock = new object();

public static void Show()
{
    lock(olock)
    {
        using (var client = new RedisClient("127.0.0.1", 6379,"123456"))
        {
            ......
        }
    }
}
```

再次运行程序，输出结果：

```powershell
抢购成功*****线程id：07,库存：10,订单数量：1
抢购成功*****线程id：07,库存：9,订单数量：2
抢购成功*****线程id：07,库存：8,订单数量：3
抢购成功*****线程id：07,库存：7,订单数量：4
抢购成功*****线程id：07,库存：6,订单数量：5
抢购成功*****线程id：11,库存：5,订单数量：6
抢购成功*****线程id：11,库存：4,订单数量：7
抢购成功*****线程id：11,库存：3,订单数量：8
抢购成功*****线程id：11,库存：2,订单数量：9
抢购成功*****线程id：11,库存：1,订单数量：10
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
```



### 对象锁原理

lock对象前，对象内部的同步索引块值为 -1

![1618565279411](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618565279411.png)



当有线程获取到锁后，对象内部的同步索引块值变成 0

![1618565203511](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618565203511.png)

没有获得锁的线程，进行排队，

第一个线程在使用完锁的，对象内部的同步索引块值变成 -1，

第二个线程看到对象内部的同步索引块值变成 -1后，获取锁并且把同步索引块值变成0

依次往复



### 同进程内对象锁的问题

如果同时开启两个程序(模拟分布式中的两个服务)，

第一个程序运行结果：

```powershell
...> dotnet Zhaoxi.LockService.dll --minute=38
在38分0秒正式开启秒杀！
抢购成功*****线程id：05,库存：10,订单数量：1
抢购成功*****线程id：05,库存：9,订单数量：3
抢购成功*****线程id：05,库存：7,订单数量：5
抢购成功*****线程id：05,库存：5,订单数量：8
抢购成功*****线程id：05,库存：4,订单数量：9
抢购成功*****线程id：05,库存：3,订单数量：11
抢购成功*****线程id：05,库存：1,订单数量：14
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
```

第二个程序运行结果：

```powershell
...>dotnet Zhaoxi.LockService.dll --minute=38
在38分0秒正式开启秒杀！
抢购成功*****线程id：07,库存：10,订单数量：2
抢购成功*****线程id：05,库存：8,订单数量：4
抢购成功*****线程id：05,库存：7,订单数量：6
抢购成功*****线程id：05,库存：6,订单数量：7
抢购成功*****线程id：05,库存：4,订单数量：10
抢购成功*****线程id：05,库存：3,订单数量：12
抢购成功*****线程id：10,库存：2,订单数量：13
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
抢购失败
```

查看Redis，订单数`orderNum`为：14。

出现这个问题的原因是：

锁的范围是同一进程内

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618566280550.png" alt="1618566280550" style="zoom:80%;" />

当我们开启两个程序后，即开启了两个进程，第一个进程内的锁对于第二个进程内的锁是无效的。

**即：n个程序=n个进程=n个锁**



### 解决方案

解决方案思路：

​        把多个线程的锁，变成成一个锁，而这个锁不再使用内存对象，而是使用文件。

在C盘存放一个文件，文件里面存一个值，如果有值就代表有人拿到了锁。如果没有值，就可以使用共享代码块。

这个方案的前提是：

- 文本文件只能有一个人读，可以操作文件的时候
- 现在能解决-- 当前的电脑上面，开启了三个进程，可以解决



但是如果三个进程不再台电脑，上述解决方案不可行。于是想到如下方案：

数据库，创建一个表，有一个字段，提交事务，去操作

那么mysql数据库可以解决吗？答案是：不可以。

关系型数据库操作的是硬盘，在高并发情况下性能会大大的降低。



所以我们需要的是一个**分布式而且是内存的数据库**



## Redis分布式锁

基于一节的讨论，我们需要的是一个**分布式而且是内存的数据库**。

>警告：分布式锁，能不用就不用！！！



### 阻塞锁

具体实现代码如下，可用于生产的代码

```C#
public static void Show(int i, string key, TimeSpan timeout)
{
    using (var client = new RedisClient("127.0.0.1", 6379, "123456"))
    {
        //只是加了这么一句话,下面所有的代码都是单线程的执行
        using (var datalock = client.AcquireLock("DataLock:" + key, timeout))
        {
            //共享代码
        }
    }
}
```

完整代码如下： 

`BlockingLock.cs`

```C#
public class BlockingLock
{
    //这个是阻塞的锁
    public static void Show(int i, string key, TimeSpan timeout)
    {
        using (var client = new RedisClient("127.0.0.1", 6379, "123456"))
        {
            //只是加了这么一句话,下面所有的代码都是单线程的执行
            using (var datalock = client.AcquireLock("DataLock:" + key, timeout))
            {
                //库存数量
                var inventory = client.Get<int>("inventoryNum");
                if (inventory > 0)
                {
                    client.Set<int>("inventoryNum", inventory - 1);
                    //订单数量
                    var orderNum = client.Incr("orderNum");
                    Console.WriteLine($"{i}抢购成功*****线程id：{ Thread.CurrentThread.ManagedThreadId.ToString("00")},库存：{inventory},订单数量：{orderNum}");
                }
                else
                {
                    Console.WriteLine($"{i}抢购失败");
                }

                //client.Remove("DataLock:" + key);
                Thread.Sleep(300);
            }
        }
    }
}
```

核心代码：

```C#
client.AcquireLock(key, timeout)
```

只是加了这么一句话
如果有一个线程先进去了，写入了key: DataLock + key。它执行完需要200毫秒
    
同时来了三个线程，他们发现 key里面有值了，循环等待，什么时候，key里面没有值，然后自己可以执行代码

用到了微循环，那必然要给一个限制，这个就是`timeout `这个参数的意义，我最多等待这么长时间，如果拿不到，则我不需要在等待了,所以我们设置这个时间的时候，要合理一些
    
这个时间还有一个意义

表示当前拿到锁进去的这个线程，最多能活多久，这个锁的存活的时间，如果在规定时间还没出来，就把锁释放掉



现在来测试下，

`main.cs`修改为：

```C#
Parallel.For(0, 30, (i) =>
{
    int temp = i;
    Task.Run(() =>{
     BlockingLock.Show(i, "akey", TimeSpan.FromSeconds(100));
});
```

开启3个程序

```powershell
dotnet Zhaoxi.LockService.dll --minute=12
```

第一个程序运行结果：

```powershell
6抢购成功*****线程id：05,库存：10,订单数量：1
5抢购成功*****线程id：05,库存：9,订单数量：2
7抢购成功*****线程id：05,库存：8,订单数量：3
11抢购成功*****线程id：05,库存：7,订单数量：4
12抢购成功*****线程id：05,库存：6,订单数量：5
8抢购成功*****线程id：05,库存：5,订单数量：6
21抢购成功*****线程id：05,库存：4,订单数量：7
22抢购成功*****线程id：05,库存：3,订单数量：8
28抢购失败
14抢购失败
15抢购失败
16抢购失败
17抢购失败
18抢购失败
19抢购失败
20抢购失败
24抢购失败
1抢购失败
26抢购失败
0抢购失败
25抢购失败
13抢购失败
27抢购失败
29抢购失败
23抢购失败
3抢购失败
9抢购失败
2抢购失败
4抢购失败
10抢购失败
```



第二个程序运行结果;

```powershell
在12分0秒正式开启秒杀！
13抢购成功*****线程id：12,库存：2,订单数量：9
15抢购成功*****线程id：12,库存：1,订单数量：10
16抢购失败
17抢购失败
18抢购失败
19抢购失败
20抢购失败
21抢购失败
1抢购失败
2抢购失败
4抢购失败
5抢购失败
7抢购失败
25抢购失败
29抢购失败
0抢购失败
10抢购失败
23抢购失败
12抢购失败
27抢购失败
6抢购失败
22抢购失败
14抢购失败
11抢购失败
9抢购失败
24抢购失败
26抢购失败
8抢购失败
3抢购失败
28抢购失败
```



第三个程序运行结果：

```powershell
在12分0秒正式开启秒杀！
0抢购失败
19抢购失败
20抢购失败
21抢购失败
13抢购失败
22抢购失败
24抢购失败
25抢购失败
26抢购失败
27抢购失败
28抢购失败
29抢购失败
1抢购失败
2抢购失败
4抢购失败
9抢购失败
8抢购失败
15抢购失败
11抢购失败
3抢购失败
23抢购失败
18抢购失败
16抢购失败
17抢购失败
14抢购失败
10抢购失败
7抢购失败
6抢购失败
12抢购失败
5抢购失败
```

阻塞锁原理：
尝试在redis中创建一个字符串结构缓存，方法传入的key，value为锁的过期时间timeout的时间戳。

- 若redis中没有这个key，则创建成功（即抢到锁），然后立即返回。

- 若已经有这个key，则先watch，然后校验value中的时间戳是否已经超过当前时间。

- 若已超过当前时间，则**尝试使用提交事务的方式覆盖新的时间戳，事务提交成功（即抢到锁）**，
  然后立即返回；若未超过当前时间或事务提交失败（即被别人抢到锁），（即：可设置key的值的线程被视为拿到锁）

  > 如果两个线程同时判断到了锁的过期了,redis给他返回了一个当前的key的版本号 
  >
  > 两个线程同时判断value里面的值过期了，然后拿到版本号是1 
  >
  > 开启事务-- 保证两个线程只能有一个线程去写key的值，只会有一个线程拿到锁 
  >
  > 版本号是1 , 提交事务的时候，再去验证版本号是不是1，如果版本号是1，你可以提交，如果不是，抛异常，返回
  >
  > **如果我们A执行的比较快，则立刻马上把值写进去，然后版本号变成2** 
  >
  > **然后同时去往redis里面写值 ，key的值是当前时间+timeout,当其他线程来获取锁发现key的值<当前时间,就说明锁过期了,直接设置新的value就算拿到锁了** 

  失败的线程则进入  一个内部优化过的微循环，不断重试。

  

传入的timeout还有一个作用，就是控制重试时间，重试超时后则抛异常。
using完成方法调用或者显式调用dispose，都会直接清除key。

**注意：**
**timeout有两个意思，一是如果成功加锁后锁的过期时间， 二是未成功加锁后阻塞等待的时间，**
**数据锁服务通过检查value中时间戳来判断是否过期，**

**并不是利用redis在key上设置expire time来通过key的过期实现。**



#### 锁的释放时机

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618584905914.png" alt="1618584905914" style="zoom:80%;" />

前面我们是靠设置合理的时间去设置锁的拥有时间，如果我们需要让先获得锁的线程a，在未完成业务前不释放锁。如何做呢？

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618585067691.png" alt="1618585067691" style="zoom:80%;" />

守护进行为其增加时间，但是这样太复杂了。

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618585238043.png" alt="1618585238043" style="zoom:67%;" />



### 非阻塞锁

使用一个自动过期的对象作为锁，实现分布式锁

```C#
using (var client = new RedisClient("127.0.0.1", 6379))
{
    bool isLocked = client.Add<string>("DataLock:" + key, key, timeout);
    if (isLocked)
    {
        ......
    }
}

```





非阻塞加锁：   

上述代码，如果已经存在当前的key，则执行失败，然后false，

但是 `timeout` 一般在生产环境，给一个不要超过3s就可以

运行两个程序，输出结果：

```C#
6抢购失败：原因：没有拿到锁
5抢购失败：原因：没有拿到锁
3抢购失败：原因：没有拿到锁
4抢购失败：原因：没有拿到锁
2抢购失败：原因：没有拿到锁
1抢购失败：原因：没有拿到锁
7抢购失败：原因：没有拿到锁
8抢购失败：原因：没有拿到锁
9抢购失败：原因：没有拿到锁
10抢购失败：原因：没有拿到锁
11抢购失败：原因：没有拿到锁
12抢购失败：原因：没有拿到锁
14抢购失败：原因：没有拿到锁
13抢购失败：原因：没有拿到锁
15抢购失败：原因：没有拿到锁
17抢购失败：原因：没有拿到锁
16抢购失败：原因：没有拿到锁
18抢购失败：原因：没有拿到锁
19抢购失败：原因：没有拿到锁
21抢购失败：原因：没有拿到锁
20抢购失败：原因：没有拿到锁
22抢购失败：原因：没有拿到锁
23抢购失败：原因：没有拿到锁
25抢购失败：原因：没有拿到锁
0抢购成功*****线程id：06,库存：10,订单数量：1
24抢购失败：原因：没有拿到锁
26抢购失败：原因：没有拿到锁
28抢购失败：原因：没有拿到锁
29抢购失败：原因：没有拿到锁
27抢购成功*****线程id：08,库存：9,订单数量：2
```

第二个程序的结果：

```C#
1抢购失败：原因：没有拿到锁
29抢购失败：原因：没有拿到锁
4抢购失败：原因：没有拿到锁
6抢购失败：原因：没有拿到锁
5抢购失败：原因：没有拿到锁
3抢购失败：原因：没有拿到锁
2抢购失败：原因：没有拿到锁
0抢购失败：原因：没有拿到锁
7抢购失败：原因：没有拿到锁
28抢购失败：原因：没有拿到锁
8抢购失败：原因：没有拿到锁
10抢购失败：原因：没有拿到锁
12抢购失败：原因：没有拿到锁
9抢购失败：原因：没有拿到锁
11抢购失败：原因：没有拿到锁
13抢购失败：原因：没有拿到锁
14抢购失败：原因：没有拿到锁
27抢购失败：原因：没有拿到锁
16抢购失败：原因：没有拿到锁
19抢购失败：原因：没有拿到锁
15抢购失败：原因：没有拿到锁
18抢购失败：原因：没有拿到锁
17抢购失败：原因：没有拿到锁
20抢购失败：原因：没有拿到锁
21抢购失败：原因：没有拿到锁
22抢购失败：原因：没有拿到锁
26抢购失败：原因：没有拿到锁
23抢购失败：原因：没有拿到锁
24抢购失败：原因：没有拿到锁
25抢购失败：原因：没有拿到锁
```

**发现，10个库存并没有被全部消费**



尝试在redis中创建一个字符串结构缓存项,方法传入的key，value无意义，过期时间为传入的timeout。

- 若redis中没有这个key，则创建成功（即抢到锁），然后立即返回true。
- 若已经有这个key，则立即返回false。



以上过程为全局单线程原子操作，整个过程为独占式操作。IsLock可以检测key是否存在。
注意：

timeout即成功加锁后锁的过期时间
利用redis在key上设置expire time来通过key的过期实现。
不要先用IsLock判断是否有锁再用Add加锁，因为这两个操作非原子性操作，期间会被其他操作干掉



这个非阻塞锁 与阻塞锁的区别是，

**非阻塞锁中，失败的线程则不会进入一个内部优化过的微循环，不会重试。**



## 问题

**如何阻塞锁和非阻塞锁的选择**

目前分布式微服务架构的公司，如果他们家是.net ，100% 用的就是老师的这两种

没有折中，办法，二者选其一，根据业务和需求



**zookeper的分布式锁和redis相比，优劣势，适用场景是什么？**

servicesstack.redis是收费的

redis使用阻塞锁，用的是事务，性能稍微低一些 

zookeper 用的强一致行，然后性能稍高

java 分布式锁，大部分是zookeper+大数据生态圈里面还有其他方式 



**stackExchange.redis 和 serviceStack.redis 性能相比如何**

serviceStack 的性能高。目前生产环境上用他的比较多 



# 微服务架构进阶

【Course 055，0057】

## Consul

官网：https://www.consul.io/

其它：https://www.cnblogs.com/cuishuai/p/8194345.html



使用流程图

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618477838957.png" alt="1618477838957" style="zoom:80%;" />

 

### 启动Consul

这里的版本是`consul_1.8.0_windows_amd64`,  在其所在的目录打开**CMD**，输入如下命令，以开放模式启动

```powershell
consul.exe agent -dev
```

然后访问：http://localhost:8500/

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618470102566.png" alt="1618470102566" style="zoom:80%;" />



###  WebApi项目

 新建 WebApi项目 , 新建`UsersController`, 其提供两个方法：

- 获取所有用户
- 根据ID获取单个用户的数据



用户数据是在内存在模拟数据

`UsersController.cs`主要代码如下：

```C#
private List<User> _UserList = new List<User>()
{
    new User()
    {
        Id=1,
        Account="Administrator",
        Email="57265177@qq.com",
        Name="Eleven",
        Password="1234567890",
        LoginTime=DateTime.Now,
        Role="Admin"
    },
    new User()
    {
        Id=1,
        Account="Apple",
        Email="57265177@qq.com",
        Name="Apple",
        Password="1234567890",
        LoginTime=DateTime.Now,
        Role="Admin"
    },
    new User()
    {
        Id=1,
        Account="Cole",
        Email="57265177@qq.com",
        Name="Cole",
        Password="1234567890",
        LoginTime=DateTime.Now,
        Role="Admin"
    },
};

[HttpGet]
[Route("All")]
public IEnumerable<User> Get()
{
    this._logger.LogInformation($"This is UserController-Get {this._IConfiguration["port"]}");
    return this._UserList.Select(u => new User()
                                 {
                                     Id = u.Id,
                                     Account = u.Account,
                                     Name = u.Name,
                                     Role = $"{ this._IConfiguration["ip"]}{ this._IConfiguration["port"]}",
                                     Email = u.Email,
                                     LoginTime = u.LoginTime,
                                     Password = u.Password
                                 });
}

[HttpGet]
[Route("Get")]
public User Get(int id)
{
    return this._UserList.FirstOrDefault(u => u.Id == id);
}
```



### 服务注册

 consul支持两种方式实现服务注册，一种是通过consul的服务注册http API，由服务自己调用API实现注册，另一种方式是通过json个是的配置文件实现注册，将需要注册的服务以json格式的配置文件给出。consul官方建议使用第二种方式。 



现在需要在 WebApi 项目 启动时在Consul中进行服务注册。注册方法封装在类`ConsulHelper.cs`中，如下代码所示：

> 需要引用 Nuget安装 Consul 包，然后进行服务注册
>
>   <PackageReference Include="Consul" Version="1.6.1.1" />

```C#
public static class ConsulHelper
{
        public static async void ConsulRegist(this IConfiguration configuration)
        {
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);
            int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);
            using (ConsulClient client = new ConsulClient(c =>
             {
                 c.Address = new Uri("http://localhost:8500/");
                 c.Datacenter = "dc1";
             }))
            {
                await client.Agent.ServiceRegister(new AgentServiceRegistration()
                {
                    ID = "service " + ip + ":" + port,//独一无二
                    Name = "ZhaoxiUserService",//分组
                    Address = ip,
                    Port = port,
                    Tags = new string[] { weight.ToString() },
                    Check = new AgentServiceCheck()
                    {
                        Interval = TimeSpan.FromSeconds(12),
                        HTTP = $"http://{ip}:{port}/Api/Health/Index",
                        Timeout = TimeSpan.FromSeconds(5),
                        DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(20)
                    }
                });
                //命令行参数获取
                Console.WriteLine($"{ip}:{port}--weight:{weight}");
            }
        }
}
```

调用该扩展方法

```C#
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    //......
    this.Configuration.ConsulRegist();
}
```

注意到，

- 心跳：还得为Consul提供检查心跳的地址

```C#
                    Check = new AgentServiceCheck()
                    {
                        Interval = TimeSpan.FromSeconds(12),
                        HTTP = $"http://{ip}:{port}/Api/Health/Index",
                        Timeout = TimeSpan.FromSeconds(5),
                        DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(20)
                    }
```

上述代码的意思是，每12秒去调用一次心跳地址，如果5秒内无响应，Consu 会在20秒后将该WebApi 撤销登记

心跳接口：`/HealthController/Index`：

```C#
    [Route("api/[controller]")]
    [ApiController]
    public class HealthController : ControllerBase
    {
        private IConfiguration _iConfiguration;

        public HealthController(IConfiguration configuration)
        {
            this._iConfiguration = configuration;
        }
        [HttpGet]
        [Route("Index")]
        public IActionResult Index()
        {
            Console.WriteLine($"This is HealthController  {this._iConfiguration["port"]} Invoke");
            
            return Ok();//只是个200 
        }

    }
```

返回  响应码 200 即可



- Consul 保持某值, 

  用于服务器端保存某值，客户端到时可以读取该值

  比如，将服务器自身权重在保持起来，客户端取出用于权重决策

  ```#
  Tags = new string[] { weight.ToString() },
  ```

  

启动在 WebApi 项目 的多个实例，模拟负载均衡场景

```powershell
dotnet Zhaoxi.Microservice.WebApiDemo.dll --urls="http://*:5726" --ip="127.0.0.1" --port=5726 --weight=1

dotnet Zhaoxi.Microservice.WebApiDemo.dll --urls="http://*:5727" --ip="127.0.0.1" --port=5727 --weight=5

dotnet Zhaoxi.Microservice.WebApiDemo.dll --urls="http://*:5728" --ip="127.0.0.1" --port=5728 --weight=10
```



这时查看Consul，发现我们的服务已经注册成功，如下图所示：

![1618471757245](images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618471757245.png)



### 客户端

​        我的目标是，不管WebApi部署了几台服务器，或者因为故障，要禁止访问某台服务，对于客户端来说都是隐藏的不可见的，不需要客户端保存每个服务器的地址 或者因要禁止使用某台服务器而要去修改客户端的代码或者配置。

```C#
public async Task<IActionResult> Index()
{
    //常规是去读数据库---这会儿换成调用服务--这里不要维护那么多服务地址

    {
        string url = "http://ZhaoxiUserService/api/users/all";
        Uri uri = new Uri(url);
        string serviceName = uri.Host; //ZhaoxiUserService
  
        //比如：127.0.0.1:5726
        string addressPort = this._IConsulDispatcher.ChooseAddress(serviceName);
        
        //比如：http://127.0.0.1:5726/api/users/all
        url = $"{uri.Scheme}://{addressPort}{uri.PathAndQuery}";

        string content = HttpHelper.InvokeApi(url);
        base.ViewBag.Users = Newtonsoft.Json.JsonConvert.DeserializeObject<IEnumerable<User>>(content);
        Console.WriteLine($"This is {url} Invoke");
    }
}
```

代码解析：

```c#
url = $"{uri.Scheme}://{addressPort}{uri.PathAndQuery}";
uri.Scheme= http
addressPort = 127.0.0.1:5726
uri.PathAndQuery = /api/users/all
```





其中接口`IConsulDispatcher`, 

```C#
    public interface IConsulDispatcher
    {
        /// <summary>
        /// 负载均衡获取地址
        /// </summary>
        /// <param name="serviceName"></param>
        /// <returns></returns>
        string ChooseAddress(string serviceName);
    }
```

该接口，会根据各种方案来获取 具体某个负载均衡 的服务IP地址，

比如：

- 根据轮询方式获取负载均衡的某台服务器IP的实现类`PollingDispatcher`

```C#
public class PollingDispatcher : IConsulDispatcher
    {
        private static int _iTotalCount = 0;
        private static int iTotalCount
        {
            get
            {
                return _iTotalCount;
            }
            set
            {
                _iTotalCount = value >= Int32.MaxValue ? 0 : value;
            }
        }
        public string ChooseAddress(string serviceName)
        {
            ConsulClient client = new ConsulClient(c =>//TODO:根据集群找可用Consul Agent地址
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            var response = client.Agent.Services().Result.Response;
            foreach (var item in response)
            {
                Console.WriteLine("***************************************");
                Console.WriteLine(item.Key);
                var service = item.Value;
                Console.WriteLine($"{service.Address}--{service.Port}--{service.Service}");
                Console.WriteLine("***************************************");
            }

            AgentService agentService = null;
            var serviceDictionary = response.Where(s => s.Value.Service.Equals(serviceName, StringComparison.OrdinalIgnoreCase)).ToArray();
            {
                int index = iTotalCount++ % serviceDictionary.Length;
                agentService = serviceDictionary[index].Value;
                //轮询
            }

            return $"{agentService.Address}:{agentService.Port}";
        }
    }
```



- 根据轮询方式获取负载均衡的某台服务器IP的实现类`WeightDispatcher`

```C#
 public class WeightDispatcher : IConsulDispatcher
    {
        private static int _iTotalCount = 0;
        private static int iTotalCount
        {
            get
            {
                return _iTotalCount;
            }
            set
            {
                _iTotalCount = value >= Int32.MaxValue ? 0 : value;
            }
        }
        public string ChooseAddress(string serviceName)
        {
            ConsulClient client = new ConsulClient(c =>//TODO:根据集群找可用Consul Agent地址
            {
                c.Address = new Uri("http://localhost:8500/");
                c.Datacenter = "dc1";
            });
            var response = client.Agent.Services().Result.Response;
            foreach (var item in response)
            {
                Console.WriteLine("***************************************");
                Console.WriteLine(item.Key);
                var service = item.Value;
                Console.WriteLine($"{service.Address}--{service.Port}--{service.Service}");
                Console.WriteLine("***************************************");
            }

            AgentService agentService = null;

            var serviceDictionary = response.Where(s => s.Value.Service.Equals(serviceName, StringComparison.OrdinalIgnoreCase)).ToArray();
            //加权轮询
            var serviceDictionaryNew = new List<AgentService>();
            foreach (var service in serviceDictionary)
            {
                serviceDictionaryNew.AddRange(Enumerable.Repeat(service.Value, int.TryParse(service.Value.Tags?[0], out int iWeight) ? 1 : iWeight));
            }
            int index = new Random(DateTime.Now.Millisecond).Next(0, int.MaxValue) % serviceDictionaryNew.Count;
            agentService = serviceDictionaryNew[index];

            return $"{agentService.Address}:{agentService.Port}";
        }
    }
```



综上，

客户端最终还是访问具体的负载均衡服务器群中的某台服务器：

```powershell
http://127.0.0.1:5726/api/users/all
```





## gRPC + Consul

### gRPC

#### 服务端

新建gRPC项目，添加服务`Score.proto`

```C#
syntax = "proto3";

option csharp_namespace = "Zhaoxi.gRPCDemo.ScoreServer";

package score;

service Score {
  rpc GetScore (ScoreRequest) returns (ScoreReply);
}

message ScoreRequest {
  string lessonId = 1;
}
message ScoreReply {
  int32 score = 1;
}

```

`ScoreService.cs`

```C#
public class ScoreService : Score.ScoreBase
{
    private readonly ILogger<ScoreService> _logger;
    public ScoreService(ILogger<ScoreService> logger)
    {
        _logger = logger;
    }

    public override Task<ScoreReply> GetScore(ScoreRequest request, ServerCallContext context)
    {
        this._logger.LogInformation($"This is ScoreService GetScore {request.LessonId}");
        return Task.FromResult(new ScoreReply()
                               {
                                   Score = 100
                               });
    }
}
```



添加服务路由：

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapGrpcService<ScoreService>();
            })
在项目的根目录下，运行项目：

```powershell
dotnet Zhaoxi.gRPCDemo.ScoreServer.dll --urls="http://*:9898" --ip="127.0.0.1"
```



#### 客户端

将 `/Protos/Score/proto`文件拷贝到客户项目的`/Protos`目录下

然后将点击项目，右键 > 编辑项目文件，

将`GrpcServices="Server" `改为`GrpcServices="Client" `,如下所示：

```xaml
  <ItemGroup>
    <Protobuf Include="Protos\Score.proto" GrpcServices="Client" />
  </ItemGroup>
```

在`HomeController`编写方法进行调用：

```C#
public async Task<IActionResult> Index()
{

    string targetUrl = "http://localhost:9898";
    using (var channel = GrpcChannel.ForAddress(targetUrl))
    {
        var client = new Score.ScoreClient(channel);

        Console.WriteLine("***************单次调用************");
        {
            var reply = await client.GetScoreAsync(new ScoreRequest() { LessonId = "123" });
            string result = Newtonsoft.Json.JsonConvert.SerializeObject(reply.Score);
            Console.WriteLine($"ScoreClient {Thread.CurrentThread.ManagedThreadId} 服务返回数据1:{result} ");
            base.ViewBag.Result = result;
        }
    }
   

    return View();
}
```



#### Protopuf

gRPC 数据格式，类似JSON，但是人是无法阅读。序列化速度高，数据小

下面做个测试，对比Protopuf和Json数据序列化和反序列化的速率和数据大小

引用包

```xaml
 <PackageReference Include="protobuf-net" Version="3.0.29" />
```

测试代码

```C#
#region InitData
List<PostInfo> list = new List<PostInfo>();
for (int i = 0; i < 15000; i++)
{
    PostInfo postInfo = new PostInfo()
    {
        Content = "这是内容",
        ID = i,
        Title = "title"
    };
    list.Add(postInfo);
}
#endregion

#region protpuf格式

#endregion
{
    byte[] datas;
    Stopwatch stopwatch = new Stopwatch();
    stopwatch.Restart();
    using (var stream = new MemoryStream())
    {
        Serializer.Serialize(stream, list);
        datas = stream.ToArray();
    }
    stopwatch.Stop();
    Console.WriteLine($"protobuf 长度为：{datas.Length}");
    Console.WriteLine($"protobuf 序列化用时：{stopwatch.Elapsed.TotalMilliseconds}");

    stopwatch.Restart();
    using (var stream = new MemoryStream())
    {
        stream.Write(datas, 0, datas.Length);
        stream.Position = 0;
        var listtemp = ProtoBuf.Serializer.Deserialize<List<PostInfo>>(stream);
    }
    stopwatch.Stop();
    Console.WriteLine($"protobuf 反序列化用时：{stopwatch.Elapsed.TotalMilliseconds}");

}
{
    Stopwatch stopwatch = new Stopwatch();
    stopwatch.Start();
    string tempjson = JsonConvert.SerializeObject(list); //把当前集合转换成json
    stopwatch.Stop();
    Console.WriteLine($"json 长度为：{UTF8Encoding.UTF8.GetBytes(tempjson).Length}");
    Console.WriteLine($"json 序列化用时：{stopwatch.Elapsed.TotalMilliseconds}");
    stopwatch.Start();
    var jsonp = JsonConvert.DeserializeObject<List<PostInfo>>(tempjson);//把当前集合转换成json
    stopwatch.Stop();
    Console.WriteLine($"json 反序列化用时：{stopwatch.Elapsed.TotalMilliseconds}");

}
```

输出结果：

```powershell
protobuf 长度为：389870
protobuf 序列化用时：309.1053
protobuf 反序列化用时：37.0969
json 长度为：1068891
json 序列化用时：310.9463
json 反序列化用时：400.7012
```



**同样的`15000`条数据，json数据格式是protobuf的三倍**, 这也就是gRPC的优点所在



### 集成 Consul

#### 服务端

在gRPC 服务端项目中，使用Consul,

```C#
 public void Configure(.....)
 {
     app.UseConsul(
                new ConsulConfigModel()
                {
                    IP = "127.0.0.1",
                    Port = 8500
                },
                new HealthConfigModel()
                {
                    IP = "127.0.0.1",
                    GroupName = "LessonService",
                    Port = int.Parse(this.Configuration["port"]),
                    CheckPort = int.Parse(this.Configuration["checkport"])
                }
                );
 }   

```

 `app.UseConsul()`是自定义的一个扩展方法：

服务端的在Consuld 的注册于WebApi代码是一样的：

```C#
    /// <summary>
    /// HTTP模式
    /// </summary>
    public static class ConsulHelper
    {
        public static async Task UseConsul(this IApplicationBuilder app, ConsulConfigModel consulService, HealthConfigModel healthService)
        {

            string ip = healthService.IP;// configuration["ip"];
            int port = healthService.Port;// int.Parse(configuration["port"]);//命令行参数必须传入
            //int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);//命令行参数必须传入

            using (ConsulClient client = new ConsulClient(c =>
             {
                 c.Address = new Uri($"http://{consulService.IP}:{consulService.Port}/");
                 c.Datacenter = "dc1";
             }))
            {
                await client.Agent.ServiceRegister(new AgentServiceRegistration()
                {
                    ID = "grpcService" + ip + ":" + port,//唯一的
                    Name = healthService.GroupName,//组名称-Group
                    Address = ip,
                    Port = port,
                    Tags = healthService.Tag,
                    Check = new AgentServiceCheck()
                    {
                        Interval = TimeSpan.FromSeconds(12),
                        HTTP = $"http://{ip}:{healthService.CheckPort}/Health",
                        Timeout = TimeSpan.FromSeconds(5),
                        DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
                    }
                });
                Console.WriteLine($"http://{ip}:{port}完成注册");

            }
        }
    }
```

启动在 gRPC 项目 的多个实例，模拟负载均衡场景

```powershell
dotnet Zhaoxi.gRPCDemo.LessonServer.dll --urls="http://*:8000" --ip="127.0.0.1" --port=8000

```



#### 客户端

使用轮询方式，（因为该示例不想搞得太复杂）

```C#
services.AddSingleton<IConsulDispatcher, PollingDispatcher>();
```

客户端调用gRPC，

```C#
//比如："http://localhost:8000"
string targetUrl = $"http://{this._IConsulDispatcher.ChooseAddress("LessonService")}";

AppContext.SetSwitch("System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport", true);
using (var channel = GrpcChannel.ForAddress(targetUrl))
{
    var client = new ZhaoxiLesson.ZhaoxiLessonClient(channel);

    Console.WriteLine("***************单次调用************");
    {
        var reply = await _lessonClient.FindLessonAsync(new ZhaoxiLessonRequest() { Id = 123 });
        string result = Newtonsoft.Json.JsonConvert.SerializeObject(reply.Lesson);
        Console.WriteLine($"_lessonClient {Thread.CurrentThread.ManagedThreadId} 服务返回数据1:{result} ");
        base.ViewBag.Result = result;
    }
}
```



关键代码：

```C#
 AppContext.SetSwitch("System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport", true);
```

转化为http协议

(不看了，烦死了)



#### Consul调用客户端心跳

##### 一个进程两个协议多个IP

```C#
public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IOptions<ConsulConfigModel> consulService)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.Map("/Health", applicationBuilder => applicationBuilder.Run(async context =>
              {
                  Console.WriteLine($"This is Health Check");
                  context.Response.StatusCode = (int)HttpStatusCode.OK;
                  await context.Response.WriteAsync("OK");
              }));
```

直接在中间件中进行连接心跳地址`/Health`,但是心跳地址是`http1.0`

```C#
Check = new AgentServiceCheck()
{
    Interval = TimeSpan.FromSeconds(12),
    HTTP = $"http://{ip}:{healthService.CheckPort}/Health",
    Timeout = TimeSpan.FromSeconds(5),
    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5)
}
```

而gRPC 使用的是 `http 2.0`，所以服务器端配置了两个端口，8000监听 http2.0, 端口7000监听http1.0，这样就是**一个进程两个协议多个IP**

```C#
 public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.ConfigureKestrel(options =>
                    {
                        options.ListenLocalhost(8000, o => o.Protocols =
                            HttpProtocols.Http2);
                        options.ListenLocalhost(7000, o => o.Protocols =
                           HttpProtocols.Http1);
                        //这里的HttpHeader就被Kestral

                        //options.ListenLocalhost(7000, o => o.Protocols =
                        //    HttpProtocols.Http1AndHttp2);//失败
                    });

                    webBuilder.UseStartup<Startup>();
                });
```

同时在配置文件`appsettings.json`设置 `Kestrel`的，默认http协议

```json
  "Kestrel": {
    "EndpointDefaults": {
      "Protocols": "Http2"
    }
  },
```



##### NConsul

引用包


```xaml
 <PackageReference Include="NConsul.AspNetCore" Version="0.7.4" />
```



## Cousul KV 存储

就是一个独立的存储，可以Put  可以Delete

通过HTTP API和通过CLI API
文档：https://www.consul.io/api-docs/kv

本身提供Acquire和Release可以完成分布式锁



<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618626472945.png" alt="1618626472945" style="zoom:80%;" />



命令行操作

```powershell
consul kv put mykey 7
consul kv get mykey
```



### Net读写操作

```C#
using (ConsulClient client = new ConsulClient(c =>
{
    c.Address = new Uri(http://localhost:8500");
    c.Datacenter = "dc1";
})){
   //读写操作
}
```

写：

```C#
client.KV.Put(new KVPair("mykey") 
              { Value = Encoding.UTF8.GetBytes("This is Teacher") }
             );

```

读：

```C#
Console.WriteLine(client.KV.Get("mykey"));

```

删：

```C#
client.KV.Delete("mykey");
```





### Consul 分布式锁

Consul 提供Acquire和Release可以完成分布式锁。

> 为什么能实现分布式锁，因为Consul 是所有服务调用的入口，故Consul能为他们所有进程提供共享存储作为分布式锁。原理可见章节：分布式锁

能提供分布式锁，这是Consul锁的价值所在。



#### 分布式锁

单进程下，多线程操作同一个对象，可以用`lock`锁保证只有一个线程能进入



多进程(分布式)下，如何保证该对象在任意时刻只能一个线程进入呢？

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618629762534.png" alt="1618629762534" style="zoom:80%;" />

答案是：分布式锁。跨进程的互斥机制来控制共享资源的访问，这就是分布式锁



#### Consul分布式锁

acquire操作只有当锁不存在持有者时才会返回true，并且set设置的Value值，同时执行操作的session会持有对该Key的锁，否则就返回false
release操作则是使用指定的session来释放某个Key的锁，如果指定的session无效，那么会返回false，否则就会set设置Value值，并返回true

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618633268916.png" alt="1618633268916" style="zoom:67%;" />



#### NConsul实现分布式锁

引用

```xml
<PackageReference Include="NConsul" Version="0.7.4" />
```

分布式锁接口:

```C#
public interface IConsulIDistributed : IDisposable
{
    Task<IDistributedLock> AcquireLock(string key);
    
    //包装了一层，委托嵌套
    Task ExecuteLocked(string key, Action action);
}
```

基于`Nconsul`实现分布式锁

> 源代码在 NConsul 项目的Lock文件中

`ConsulIDistributed.cs`

```C#
using NConsul;
using NConsul.Interfaces;
.....
    
public class ConsulIDistributed : IConsulIDistributed
{
    #region Identity
    private string _Address = $"http://127.0.0.1:{8500}/";
    private string _Datacenter = "dc1";
    private static string prefix = "consullock_";  // 同步锁参数前缀
    private ConsulClient consulClient;

    public ConsulIDistributed():this($"http://127.0.0.1:{8500}/")
    {
    }
    public ConsulIDistributed(string address)
    {
        this._Address = address;
        this.consulClient = new ConsulClient(c =>
         {
              c.Address = new Uri(this._Address);
              c.Datacenter = this._Datacenter;
         });
    }
    #endregion


    #region 分布式锁

        /// <summary>
        /// 需要先初始化
        /// </summary>
        /// <param name="key"></param>
    public Task<IDistributedLock> AcquireLock(string key)
    {
        LockOptions opts = new LockOptions($"{prefix}{key}");//默认值
        //{
        //    LockRetryTime = TimeSpan.FromSeconds(5),
        //    LockWaitTime = TimeSpan.FromSeconds(3),
        //    MonitorRetryTime = TimeSpan.FromSeconds(1)
        //};
        return this.consulClient.AcquireLock(opts);
    }



    /// <summary>
    /// 包装了一层，委托嵌套
    /// </summary>
    /// <param name="key"></param>
    /// <param name="action"></param>
    /// <returns></returns>
    public Task ExecuteLocked(string key, Action action)
    {
        //Console.WriteLine($"{prefix}{key}");
        LockOptions opts = new LockOptions($"{prefix}{key}");//默认值
        //{
        //    LockRetryTime = TimeSpan.FromSeconds(5),
        //    LockWaitTime = TimeSpan.FromSeconds(3),
        //    MonitorRetryTime = TimeSpan.FromSeconds(1)
        //};
        return this.consulClient.ExecuteLocked(opts, action);
    }

    public void Dispose()
    {
        if (this.consulClient != null)
        {
            this.consulClient.Dispose();
        }
    }
    #endregion
}
```

测试代码

```C#

for (int i = 0; i < 10; i++)
{
    int k = i;
    Console.WriteLine($"Start  out {k}");
    Task.Run(() =>
    {
        Console.WriteLine($"Start  in {k}");
        consulIDistributed.ExecuteLocked("Eleven", new Action(() =>
        {                                                                                 Console.WriteLine($"This is UserController-Get-{k} Start");
                                                                                           Thread.Sleep(new Random().Next(100, 999));                                     Console.WriteLine($"This is UserController-Get-{k}   End");
         }));
     });
}
```

main.cs

调用执行

```C#
var builder = new ConfigurationBuilder()
    .AddCommandLine(args);
var configuration = builder.Build();
string port = configuration["port"] ?? "8500";

DistributedLockTest.Show(port);
```



通过执行如下命令，同时运行多个程序：

```powershell
dotnet Zhaoxi.Microservice.TestProject.dll --port=8500
dotnet Zhaoxi.Microservice.TestProject.dll --port=9500
```

用肉眼看到，同一时间只能有一个线程在执行

> 注意：
>
> ​       目前Consul本身还是单实例，如果是 Consul 是集群该如何保证分布式锁呢? 后面再做讨论



## Consul 集群

https://www.cnblogs.com/cuishuai/p/8194345.html

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618635754155.png" alt="1618635754155" style="zoom: 80%;" />



**Client/Server**

 每个节点都需要运行agent，他有两种运行模式server和client。每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。 

**Client-Server数据都是一样的**



- Client

  Client表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。

- Sever

   SERVER表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。

-  server-leader 

   中间那个SERVER下面有**LEADER**的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。 



### Docker集群



#### 获取镜像

```shell
docker pull consul:latest
```



#### 搭建集群

节点部署

| 容器名称     | 容器IP地址 | 映射端口号    | 宿主机IP地址    | 服务运行模式  |
| ------------ | ---------- | ------------- | --------------- | ------------- |
| consul-node1 | 172.17.0.2 | 8500 -> 8500  | 192.168.130.129 | Server Leader |
| consul-node2 | 172.17.0.3 | 9500 -> 8500  | 192.168.130.129 | Server        |
| consul-node3 | 172.17.0.4 | 10500 -> 8500 | 192.168.130.129 | Server        |
| consul-node4 | 172.17.0.5 | 11500 -> 8500 | 192.168.130.129 | Client        |

>这里我们没有启动多个虚拟机进行部署，而是采用 端口的来区分 各个Consul 节点



##### Server Leader

运行 consul 镜像，启动 Server Master 节点 node1 ： 

```shell
docker run -d --name=consul-node1 --restart=always \
 -e 'CONSUL_LOCAL_CONFIG={"skip_leave_on_interrupt": true}' \
 -p 8300:8300 \
 -p 8301:8301 \
 -p 8301:8301/udp \
 -p 8302:8302/udp \
 -p 8302:8302 \
 -p 8400:8400 \
 -p 8500:8500 \
 -p 8600:8600 \
 -h consul-node1 \
 consul agent -server -bind=0.0.0.0 -bootstrap-expect=3 -node=consul-node1 \
 -data-dir=/tmp/data-dir -client 0.0.0.0 -ui
```

参数说明：

`  -server`: 启动为`server`模式



查看node1情况 , 

```shell
docker logs -f consul-node1 

.....
# 因为还没有选举出  leader ，所以有error， 等到启动其它节点（）
 2021-04-17T06:08:09.795Z [ERROR] agent.anti_entropy: failed to sync remote state: error="No cluster leader"

```

> 集群至少有3个 server，否则无法进行选举，因为集群中至少（n/2 + 1）个server才能进行选举



访问：http://192.168.130.129:8500/ui/dc1/nodes

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618638733000.png" alt="1618638733000" style="zoom:80%;" />

此时没有任何数据，是因为还没有选择出`Leader`



##### Server Follower

**启动 node2**:

```shell
docker run -d --name=consul-node2 --restart=always \
 -e 'CONSUL_LOCAL_CONFIG={"skip_leave_on_interrupt": true}' \
 -p 9300:8300 \
 -p 9301:8301 \
 -p 9301:8301/udp \
 -p 9302:8302/udp \
 -p 9302:8302 \
 -p 9400:8400 \
 -p 9500:8500 \
 -p 9600:8600 \
 -h consul-node2 \
 consul agent -server -bind=0.0.0.0 \
 -join=192.168.130.129 -node-id=$(uuidgen | awk '{print tolower($0)}') \
 -node=consul-node2 \
 -data-dir=/tmp/data-dir -client 0.0.0.0 -ui
```

参数说明：

`-join=192.168.130.129`,加入集群



查看集群状态：

使用`Leader`或者`Follower`节点查看

```shell
# docker exec -t consul-node1 consul members

Node          Address          Status  Type    Build  Protocol  DC   Segment
consul-node1  172.17.0.2:8301  alive   server  1.9.5  2         dc1  <all>
consul-node2  172.17.0.3:8301  alive   server  1.9.5  2         dc1  <all>

```



**启动 node3**

```shell
docker run -d --name=consul-node3 --restart=always \
 -e 'CONSUL_LOCAL_CONFIG={"skip_leave_on_interrupt": true}' \
 -p 10300:8300 \
 -p 10301:8301 \
 -p 10301:8301/udp \
 -p 10302:8302/udp \
 -p 10302:8302 \
 -p 10400:8400 \
 -p 10500:8500 \
 -p 10600:8600 \
 -h consul-node2 \
 consul agent -server -bind=0.0.0.0 \
 -join=192.168.130.129 -node-id=$(uuidgen | awk '{print tolower($0)}') \
 -node=consul-node3 \
 -data-dir=/tmp/data-dir -client 0.0.0.0 -ui
```

查看集群信息：

```shell
[root@centos-1 ~]# docker exec -t consul-node3 consul members
Node          Address          Status  Type    Build  Protocol  DC   Segment
consul-node1  172.17.0.2:8301  alive   server  1.9.5  2         dc1  <all>
consul-node2  172.17.0.3:8301  alive   server  1.9.5  2         dc1  <all>
consul-node3  172.17.0.4:8301  alive   server  1.9.5  2         dc1  <all>

```



##### 选择 Leader

```shell
[root@centos-1 ~]# docker exec -t consul-node1 consul operator raft list-peers
Node          ID                                    Address          State     Voter  RaftProtocol
consul-node1  826f5d25-ae7f-e4a9-e580-b9c1c536a54a  172.17.0.2:8300  leader    true   3
consul-node2  0ddeebaa-6238-4744-8a62-404bae26d00f  172.17.0.3:8300  follower  true   3
consul-node3  f6557d86-79e1-4081-9990-1bea18e35f0b  172.17.0.4:8300  follower  true   3

```

`consul-node1`节点被选举为`Leader`

node2 和 node3 都成功join到了 node1 所在的数据中心 dc1 。

当集群中有3台 Consul Server 启动时， node1 被选举为 dc1 中的主节点。然后， node1 会通过心跳检查的方式，不断地对 node2 和 node3 进行健康检查。 



这时再访问`Leader`: http://192.168.130.129:8500/ui/dc1/nodes

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618640742461.png" alt="1618640742461" style="zoom:80%;" />

节点node2:http://192.168.130.129:9500/ui/dc1/nodes

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618640814396.png" alt="1618640814396" style="zoom:80%;" />



##### Client 节点

启动node4

```shell
docker run -d --name=consul-node4 --restart=always \
 -e 'CONSUL_LOCAL_CONFIG={"leave_on_terminate": true}' \
 -p 11300:8300 \
 -p 11301:8301 \
 -p 11301:8301/udp \
 -p 11302:8302/udp \
 -p 11302:8302 \
 -p 11400:8400 \
 -p 11500:8500 \
 -p 11600:8600 \
 -h consul-node4 \
 consul agent -bind=0.0.0.0 -retry-join=192.168.130.129 \
 -node-id=$(uuidgen | awk '{print tolower($0)}') \
 -node=consul-node4 -client 0.0.0.0 -ui
```

参数说明：

` -client`: 启动为 client模式

查看集群信息：

```shell
[root@centos-1 ~]# docker exec -t consul-node1 consul members
Node          Address          Status  Type    Build  Protocol  DC   Segment
consul-node1  172.17.0.2:8301  alive   server  1.9.5  2         dc1  <all>
consul-node2  172.17.0.3:8301  alive   server  1.9.5  2         dc1  <all>
consul-node3  172.17.0.4:8301  alive   server  1.9.5  2         dc1  <all>
consul-node4  172.17.0.5:8301  alive   client  1.9.5  2         dc1  <default>

```

访问client：http://192.168.130.129:11500/ui/dc1/nodes

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618641585473.png" alt="1618641585473" style="zoom: 50%;" />



node4 是以 Client 模式启动运行的。启动后完成后，把 dc1 数据中心中的以 Server 模式 

启动的节点 node1 、 node2 和 node3 都添加到**本地缓存列表**中。

**当客户端向 node4 发起服务发现的请求后， node4 会通过 RPC 将请求转发给 Server 节点中的其中一台做处理。**



### 集群KV操作测试

```shell
集群参数get/set测试

# Leader节点存在值
[root@centos-1 ~]# docker exec -t consul-node1 consul kv put mykey 11
Success! Data written to: mykey
#follower节点
[root@centos-1 ~]# docker exec -t consul-node2 consul kv get mykey
11
#Client节点
[root@centos-1 ~]# docker exec -t consul-node4 consul kv get mykey
11

## 在Client节点修改值，Server节点更新
[root@centos-1 ~]# docker exec -t consul-node4 consul kv put mykey 7
Success! Data written to: myke
[root@centos-1 ~]# docker exec -t consul-node2 consul kv get mykey
7

```



### Consul集群分布式锁

测试代码：

> 还是基于 Nconsul 实现的分布式锁

```C#
            //连接Consul集群
            IConsulIDistributed consulIDistributed = new ConsulIDistributed($"http://192.168.130.129:{port}/");

            for (int i = 0; i < 10; i++)
            {
                int k = i;
                Console.WriteLine($"Start  out {k}");
                Task.Run(() =>
                {
                    Console.WriteLine($"Start  in {k}");
                    consulIDistributed.ExecuteLocked("Eleven", new Action(() =>
                    {
                        Console.WriteLine($"This is UserController-Get-{k} Start");
                        Thread.Sleep(new Random().Next(100, 999));
                        //Thread.Sleep(new Random().Next(1100, 9999));
                        Console.WriteLine($"This is UserController-Get-{k}   End");
                    }));
                });
            }
```

通过执行如下命令，同时运行多个程序：

```powershell
dotnet Zhaoxi.Microservice.TestProject.dll --port=8500
dotnet Zhaoxi.Microservice.TestProject.dll --port=9500
dotnet Zhaoxi.Microservice.TestProject.dll --port=10500
dotnet Zhaoxi.Microservice.TestProject.dll --port=11500
```

用肉眼看到，同一时间只能有一个线程在执行。

不管是从那个Consul节点访问的线程，共用一个锁



**结论**：

**不管是从那个Consul节点访问的线程，共用一个锁**

**Consul集群中的分布式锁是自动完成的，我们不需要关心Consu是单体还是集群，直接用就可以了。**



### 故障Leader选举

```shell
# Leader 节点宕机
[root@centos-1 ~]# docker stop consul-node1

[root@centos-1 ~]# docker exec -t consul-node2 consul members
Node          Address          Status  Type    Build  Protocol  DC   Segment
consul-node1  172.17.0.2:8301  left    server  1.9.5  2         dc1  <all>
consul-node2  172.17.0.3:8301  alive   server  1.9.5  2         dc1  <all>
consul-node3  172.17.0.4:8301  alive   server  1.9.5  2         dc1  <all>
consul-node4  172.17.0.5:8301  alive   client  1.9.5  2         dc1  <default>

# 查看主从信息，node3 已经被选举为Leader
[root@centos-1 ~]# docker exec -t consul-node2 consul operator raft list-peers
Node          ID                                    Address          State     Voter  RaftProtocol
consul-node2  0ddeebaa-6238-4744-8a62-404bae26d00f  172.17.0.3:8300  follower  true   3
consul-node3  f6557d86-79e1-4081-9990-1bea18e35f0b  172.17.0.4:8300  leader    true   3


# node3 恢复后
[root@centos-1 ~]# docker start consul-node1
consul-node1
# node3 还是Leader
[root@centos-1 ~]# docker exec -t consul-node2 consul operator raft list-peers
Node          ID                                    Address          State     Voter  RaftProtocol
consul-node2  0ddeebaa-6238-4744-8a62-404bae26d00f  172.17.0.3:8300  follower  true   3
consul-node3  f6557d86-79e1-4081-9990-1bea18e35f0b  172.17.0.4:8300  leader    true   3
consul-node1  826f5d25-ae7f-e4a9-e580-b9c1c536a54a  172.17.0.2:8300  follower  false  3


```



### 实战：Consul集群 + .Net Core WebAPI 集群



#### 部署WebApi：Dockerfile

这个实战，是基于前几个搭建的Consul 集群，要确保之前的搭建的集群可以正常工作

##### Consul注册

```C#
    public static async void ConsulRegist(this IConfiguration configuration)
        {
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);
            int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);
            using (ConsulClient client = new ConsulClient(c =>
             {
                 c.Address = new Uri(configuration["ConsulAddress"]);
                 c.Datacenter = configuration["ConsulCenter"];
             }))
            {
                await client.Agent.ServiceRegister(new AgentServiceRegistration()
                {
                    ID = "service " + ip + ":" + port,//独一无二
                    Name = "ZhaoxiUserService",//分组
                    Address = ip,
                    Port = port,
                    Tags = new string[] { weight.ToString() },
                    Check = new AgentServiceCheck()
                    {
                        Interval = TimeSpan.FromSeconds(12),
                        HTTP = $"http://{ip}:{port}/Api/Health/Index",
                        Timeout = TimeSpan.FromSeconds(5),
                        DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(20)
                    }
                });
                //命令行参数获取
                Console.WriteLine($"{ip}:{port}--weight:{weight}");
            }
        }
```

配置文件`appsettings.json`添加相关配置：

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "ip": "192.168.130.129",
  "port": 5726,
  "weight": 1,
  "ConsulAddress": "http://192.168.130.129:11500/",
  "ConsulCenter": "dc1"
}

```



##### 构建Api镜像

点击【WebApi项目】右键“添加/ Docker支持”，自动添加`Dockerfiler`文件：

```dockerfile
#See https://aka.ms/containerfastmode to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.

FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
WORKDIR /src
COPY ["Zhaoxi.Microservice.WebApiDemo/Zhaoxi.Microservice.WebApiDemo.csproj", "Zhaoxi.Microservice.WebApiDemo/"]
COPY ["Zhaoxi.AgilityFramework/Zhaoxi.AgilityFramework.csproj", "Zhaoxi.AgilityFramework/"]
RUN dotnet restore "Zhaoxi.Microservice.WebApiDemo/Zhaoxi.Microservice.WebApiDemo.csproj"
COPY . .
WORKDIR "/src/Zhaoxi.Microservice.WebApiDemo"
RUN dotnet build "Zhaoxi.Microservice.WebApiDemo.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "Zhaoxi.Microservice.WebApiDemo.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "Zhaoxi.Microservice.WebApiDemo.dll"]
```

将文件`Dockerfiler`拷贝到`*.csproj`的上一级目录中，然后在该目录下执行如下命令，构建镜像文件

```shell
docker build -t api-3.1-v1.0 -f Dockerfile .
```

然后导出镜像，先创建输出文件夹`D:\Docker\images`,然后执行如下命令

```powershell
docker save -o D://Docker/images/api-3.1-v1.0.tar api-3.1-v1.0
```



##### 上传镜像

将上一节导出的Docker镜像`api-3.1-v1.0.tar`，上传的Linux服务器的如下目录中

```shell
# mkdir -p /workbench/docker/images
```

还原镜像

```shell
[root@centos-1 ~]# docker load  -i /workbench/docker/images/api-3.1-v1.0.tar
7e718b9c0c8c: Loading layer [==================================================>]  72.52MB/72.52MB
3cf53a68ca2f: Loading layer [==================================================>]  41.71MB/41.71MB
b11cb364ccec: Loading layer [==================================================>]   2.36MB/2.36MB
71c1fc503ae7: Loading layer [==================================================>]   76.9MB/76.9MB
5dfad66dd70d: Loading layer [==================================================>]  17.95MB/17.95MB
569b65645abb: Loading layer [==================================================>]  2.048kB/2.048kB
5f70bf18a086: Loading layer [==================================================>]  1.024kB/1.024kB
5a3b91893768: Loading layer [==================================================>]  20.78MB/20.78MB
Loaded image: api-3.1-v1.0:latest

[root@centos-1 ~]# docker images api-3.1-v1.0
REPOSITORY     TAG       IMAGE ID       CREATED          SIZE
api-3.1-v1.0   latest    0948f6ac1788   29 minutes ago   228MB
```



##### 运行Api镜像

```shell
docker run -itd  --name webapi-node1 --restart=always  -p 5726:80 api-3.1-v1.0:latest  
```

然后访问：http://192.168.130.129:5726/api/users/all

返回数据,说明部署成功

```json
[{"id":1,"name":"Eleven","account":"Administrator","password":"1234567890","email":"57265177@qq.com","role":"192.168.130.1295726","loginTime":"2021-04-17T09:52:59.3098983+00:00"},{"id":1,"name":"Apple","account":"Apple","password":"1234567890","email":"57265177@qq.com","role":"192.168.130.1295726","loginTime":"2021-04-17T09:52:59.3257933+00:00"},{"id":1,"name":"Cole","account":"Cole","password":"1234567890","email":"57265177@qq.com","role":"192.168.130.1295726","loginTime":"2021-04-17T09:52:59.3258026+00:00"}]
```



##### 检查Consul

按上述步骤部署完webApi, 虽然在webApi项目使用的是Consul的某一节点进行注册服务

```
"ConsulAddress": "http://192.168.130.129:11500/",
```

但是这时在Consul的任何节点查看服务信息：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618653400697.png" alt="1618653400697" style="zoom:80%;" />



#### 部署WebApi：原镜像+修改配置文件

现在搭建WebApi集群中的第二个 WebApi实例，部署方式是

在第一个实例构建的镜像中微调，修改配置文件的方式进行部署。

```shell
[root@centos-1 webapi-node2]# docker run -itd  --name webapi-node2 --restart=always  -p 5727:80 api-3.1-v1.0:latest
cd2a6a3eef586a5b410e990a86e70cf301834bc2beaea8248149d2624c30a3b5

[root@centos-1 webapi-node2]# docker exec -it webapi-node2 /bin/bash
root@cd2a6a3eef58:/app#
root@68b8a00bd05d:/app#cat appsettings.json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "ip": "192.168.130.129",
  "port": 5726,
  "weight": 1,
  "ConsulAddress": "http://192.168.130.129:11500/",
  "ConsulCenter": "dc1"
}

```

需要修改`appsettings.json`文件中的`"port": 5726`,修改为`"port": 5727,`

因为这个参数用于在Consul注册的服务，并且我们`webapi-inode2`也监听着`5727`端口监听

```C#
            string ip = configuration["ip"];
            int port = int.Parse(configuration["port"]);
            int weight = string.IsNullOrWhiteSpace(configuration["weight"]) ? 1 : int.Parse(configuration["weight"]);
            using (ConsulClient client = new ConsulClient(c =>
             {
                 c.Address = new Uri(configuration["ConsulAddress"]);
                 c.Datacenter = configuration["ConsulCenter"];
             }))
            {
                await client.Agent.ServiceRegister(new AgentServiceRegistration()
                {
                    ID = "service " + ip + ":" + port,//独一无二
```

所有我们得修改这个配置。但是 默认的 asp.net core 的镜像没有安装 vim，

```shell
root@cd2a6a3eef58:/app# vim appsettings.json
bash: vim: command not found
```

**在docker 中安装vim**

```shell
# 第一次安装 vim 失败
root@cd2a6a3eef58:/app# apt-get install vim
Reading package lists... Done
Building dependency tree
Reading state information... Done
E: Unable to locate package vim

## apt-get update。这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引。这样才干获取到最新的软件包
root@cd2a6a3eef58:/app# apt-get update
Get:1 http://security.debian.org/debian-security buster/updates InRelease [65.4 kB]
Get:2 http://deb.debian.org/debian buster InRelease [121 kB]
Get:3 http://security.debian.org/debian-security buster/updates/main amd64 Packages [272 kB]
Get:4 http://deb.debian.org/debian buster-updates InRelease [51.9 kB]
Get:5 http://deb.debian.org/debian buster/main amd64 Packages [7907 kB]
Get:6 http://deb.debian.org/debian buster-updates/main amd64 Packages [9504 B]
Fetched 8427 kB in 2min 53s (48.6 kB/s)
Reading package lists... Done

## 再进行安装vim
root@cd2a6a3eef58:/app# apt-get install vim
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  libgpm2 vim-common vim-runtime xxd
Suggested packages:
  gpm ctags vim-doc vim-scripts
The following NEW packages will be installed:
  libgpm2 vim vim-common vim-runtime xxd
0 upgraded, 5 newly installed, 0 to remove and 0 not upgraded.
Need to get 7425 kB of archives.
After this operation, 33.8 MB of additional disk space will be used.
......
```

修改配置文件

```shell
root@cd2a6a3eef58:/app# vim appsettings.json
 "port": 5726 修改为 "port": 5727
 
 :wq
root@cd2a6a3eef58:/app# 组合键【Ctrl+p+q】退出容器
```

重启容器

```shell
[root@centos-1 ~]# docker restart webapi-node2
webapi-node2
```

访问webapi服务器：http://192.168.130.129:5727/api/users/all

```json
[{"id":1,"name":"Eleven","account":"Administrator","password":"1234567890","email":"57265177@qq.com","role":"192.168.130.1295727","loginTime":"2021-04-17T15:16:23.6926654+00:00"},{"id":1,"name":"Apple","account":"Apple","password":"1234567890","email":"57265177@qq.com","role":"192.168.130.1295727","loginTime":"2021-04-17T15:16:23.6971902+00:00"},{"id":1,"name":"Cole","account":"Cole","password":"1234567890","email":"57265177@qq.com","role":"192.168.130.1295727","loginTime":"2021-04-17T15:16:23.6972009+00:00"}]
```

访问Consul集群中某个节点，查看服务是否注册成功：

http://192.168.130.129:8500/ui/dc1/services/ZhaoxiUserService/instances

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618672652561.png" alt="1618672652561" style="zoom:80%;" />

从上图看出, webapi-node2 已经注册成功了

查看Docker日志：

```shell
[root@centos-1 webapi-node2]# docker logs -f webapi-node2
info: Microsoft.Hosting.Lifetime[0]
      Now listening on: http://[::]:80
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /app
192.168.130.129:5726--weight:1
......
This is HealthController  5727 Invoke
This is HealthController  5727 Invoke
This is HealthController  5727 Invoke
......
```





##### 使用分卷挂载（失败）

使用上传的Docker镜像`api-3.1-v1.0.tar`, 运行时使用`Docker`的**卷**技术，把docker容器的目录都映射的Linux宿主机上

```shell
[root@centos-1 ~]# docker exec -it webapi-node2 /bin/bash
root@68b8a00bd05d:/app#
Consul.dll                                                         Zhaoxi.AgilityFramework.dll
Microsoft.AspNetCore.Razor.Language.dll                            Zhaoxi.AgilityFramework.pdb
Microsoft.CodeAnalysis.CSharp.Workspaces.dll                       Zhaoxi.Microservice.WebApiDemo
Microsoft.CodeAnalysis.CSharp.dll                                  Zhaoxi.Microservice.WebApiDemo.deps.json
Microsoft.CodeAnalysis.Razor.dll                                   Zhaoxi.Microservice.WebApiDemo.dll
Microsoft.CodeAnalysis.Workspaces.dll                              Zhaoxi.Microservice.WebApiDemo.pdb
Microsoft.CodeAnalysis.dll                                         Zhaoxi.Microservice.WebApiDemo.runtimeconfig.json
Microsoft.Extensions.Configuration.Abstractions.dll                appsettings.Development.json
Microsoft.Extensions.Primitives.dll                                appsettings.json
Microsoft.VisualStudio.Web.CodeGeneration.Contracts.dll            cs
Microsoft.VisualStudio.Web.CodeGeneration.Core.dll                 de
Microsoft.VisualStudio.Web.CodeGeneration.EntityFrameworkCore.dll  dotnet-aspnet-codegenerator-design.dll
Microsoft.VisualStudio.Web.CodeGeneration.Templating.dll           es
Microsoft.VisualStudio.Web.CodeGeneration.Utils.dll                fr
Microsoft.VisualStudio.Web.CodeGeneration.dll                      it
Microsoft.VisualStudio.Web.CodeGenerators.Mvc.dll                  ja
NConsul.dll                                                        ko
Newtonsoft.Json.dll                                                pl
NuGet.Frameworks.dll                                               pt-BR
System.Composition.AttributedModel.dll                             ru
System.Composition.Convention.dll                                  tr
System.Composition.Hosting.dll                                     web.config
System.Composition.Runtime.dll                                     zh-Hans
System.Composition.TypedParts.dll                                  zh-Hant

root@68b8a00bd05d:/app#组合键【Ctrl+p+q】退出容器
```

注意到 asp.net core 3.1 的容器的工作目录就是`/app`

重新创建容器，使用卷挂载到宿主机目录

```shell
[root@centos-1 ~]# docker run -itd  --name webapi-node-v --restart=always -p 5827:80 -v /workbench/dotnet/webpulish/webapi-node-v:/app api-3.1-v1.0:latest

# 这样运行失败，
[root@centos-1 ~]# docker exec -it webapi-node-v /bin/bash
Error response from daemon: Container f0f883794bff616faa12be32b9aab587301434dc163f503cd837494b0bd493b6 is restarting, wait until the container is running

# 容器老是在`Restarting` 状态
[root@centos-1 compose]# docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS                            PORTS                                                                                                                                                                                                              NAMES
f0f883794bff   api-3.1-v1.0:latest   "dotnet Zhaoxi.Micro…"   11 minutes ago   Restarting (145) 19 seconds ago                                                                                                                                                                                                                      webapi-node-v


# 查看日志：
# [root@centos-1 ~]# docker logs webapi-node-v
  It was not possible to find any installed .NET Core SDKs
  Did you mean to run .NET Core SDK commands? Install a .NET Core SDK from:
      https://aka.ms/dotnet-download


# 在成功的webapi-node1容器，发现dotnet 也没安装？！
[root@centos-1 ~]# docker exec -it webapi-node1 /bin/bash
root@c030c784850c:/app# dotnet -v
  It was not possible to find any installed .NET Core SDKs
  Did you mean to run .NET Core SDK commands? Install a .NET Core SDK from:
      https://aka.ms/dotnet-download
root@c030c784850c:/app#

```

**这样不行，报错见上述输出的日志。挂载宿主机也不成功**





#### 部署WebApi：docker-compose

现在搭建WebApi集群中的第3和4个 WebApi实例，部署方式是：

使用`docker-compose`,

创建`docker-compose.yml`文件：

```yaml
version: '3.3'
services:
  service3:
    build:
      context: /dotnet-webapi/src
    image: api-3.1-v1.0_by_compose
    ports:
      - 5728:80/tcp
    command: ["dotnet", "/app/Zhaoxi.Microservice.WebApiDemo"]
    volumes:
      - /elevenmicro/webapidemo/appsettings/appsettings5728.json:/app/appsettings.json
  service4:
    image: api-3.1-v1.0_by_compose
    ports:
      - 5729:80/tcp
    command: ["dotnet", "/app/Zhaoxi.Microservice.WebApiDemo"]
    volumes:
      - /elevenmicro/webapidemo/appsettings/appsettings5729.json:/app/appsettings.json
```

参数说明：

```shell
- image - 指定了我们用来运行容器的镜像，如果指定的image不存在，它会自动从远程仓库下载
- ports - 指定了我们映射端口，这里把容器80端口映射到宿主机器8081/8082端口
- volumes - 指定了容器里的存储路径以volume挂载方式映射到宿主机器上

- context- 指定Dockerfile所在的位置

service3:容器启动后，容器的名称将会是：compose_service3_1
```

注意到：

```yaml
    build:
      context: /dotnet-webapi/src
    image: api-3.1-v1.0_by_compose
```

这个需要我们把项目`WebApi`的源码 拷贝到 Linux 服务器（即：Docker的宿主机中）。实际生产中肯定不能这样做。

所以必须做下修改，不再自己build 镜像了，而是直接使用上一节上传的`api-3.1-v1.0`的镜像

```yaml
version: '3.3'
services:
  webapi-node3:
    image: api-3.1-v1.0
    restart: always
    ports:
      - 5728:80/tcp
    command: ["dotnet", "/app/Zhaoxi.Microservice.WebApiDemo"]
    volumes:
      - /workbench/dotnet/webpulish/appsettings/webapi/appsettings5728.json:/app/appsettings.json
  webapi-node4:
    image: api-3.1-v1.0
    restart: always
    ports:
      - 5729:80/tcp
    command: ["dotnet", "/app/Zhaoxi.Microservice.WebApiDemo"]
    volumes:
      - /workbench/dotnet/webpulish/appsettings/webapi/appsettings5729.json:/app/appsettings.json

```

在宿主机中创建如下文件夹，并上传`docker-compose.yml`文件

```shell
[root@centos-1 ~]# mkdir -p /workbench/docker/compose
#上传文件`docker-compose.yml`到此目录
[root@centos-1 ~]# cd /workbench/docker/compose
[root@centos-1 compose]# ls
docker-compose.yml
```



下载compose

```shell
[root@centos-1 compose]# docker-compose -v
bash: docker-compose: 未找到命令...
[root@centos-1 compose]# curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   423  100   423    0     0    133      0  0:00:03  0:00:03 --:--:--   133
100 16.2M  100 16.2M    0     0  1935k      0  0:00:08  0:00:08 --:--:-- 3508k

[root@centos-1 compose]# docker-compose -v
-bash: /usr/local/bin/docker-compose: 权限不够
```

给docker-compose 授权：

```shell
[root@centos-1 compose]#  chmod +x /usr/local/bin/docker-compose
[root@centos-1 compose]# docker-compose -v
docker-compose version 1.25.0, build 0a186604
```

切换到``docker-compose.yml`文件所在的目录

> 请确保在存在`docker-compose.yml`文件的目录中运行， docker-compose

```C#
[root@centos-1 compose]# cd /workbench/docker/compose
```

启动 docker-compose：

```shell
[root@centos-1 compose]# docker-compose up --d
Creating compose_webapi-node3_1 ... done
Creating compose_webapi-node4_1 ... done


ERROR: for compose_service4_1  Cannot start service service4: OCI runtime create failed: container_linux.go:367: starting container process caused: process_linux.go:495: container init caused: rootfs_linux.go:60: mounting "/workbench/dotnet/webpulish/appsettings/webapi/appsettings5729.json" to rootfs at "/var/lib/docker/overlay2/e92fa97bef4a8312efc430c5d8e0dd47a94d2ebfa02ab49dc0ebcd61f974cd02/merged/app/appsettings.json" caused: not a directory: unknown: Are you trying to mount a directory onto a file (or vice-versa)? ChecCreating compose_service3_1 ... error

```

提示没有配置文件，创建配置文件

`appsettings5728.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "ip": "192.168.130.129",
  "port": 5728,
  "weight": 1,
  "ConsulAddress": "http://192.168.130.129:8500/",
  "ConsulCenter": "dc1"
}

```



`appsettings5729.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "ip": "192.168.130.129",
  "port": 5729,
  "weight": 1,
  "ConsulAddress": "http://192.168.130.129:8500/",
  "ConsulCenter": "dc1"
}

```

并把它们拷贝到Docker的宿主机： `/workbench/dotnet/webpulish/appsettings/webapi/`目录中,

再次启动 `docker-compose`:

```shell
[root@centos-1 compose]# docker-compose up -d
Creating compose_webapi-node3_1 ... done
Creating compose_webapi-node4_1 ... done
```

检查Docker实例是否正常启动：

```shell
[root@centos-1 compose]# docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS         PORTS                                                                                                                                                                                                              NAMES
2a6dcbbe7aff   api-3.1-v1.0          "dotnet Zhaoxi.Micro…"   9 seconds ago   Up 7 seconds   443/tcp, 0.0.0.0:5728->80/tcp                                                                                                                                                                                      compose_webapi-node3_1
4576cfe67359   api-3.1-v1.0          "dotnet Zhaoxi.Micro…"   9 seconds ago   Up 7 seconds   443/tcp, 0.0.0.0:5729->80/tcp                                                                                                                                                                                      compose_webapi-node4_1


```

http://192.168.130.129:5728/api/users/all

http://192.168.130.129:5729/api/users/all

都返回数据，

且Consul注册服务成功，如下图所示：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618679840175.png" alt="1618679840175" style="zoom:80%;" />

#### 注册 Consul 引发的问题

**Consul集群中，如果某个 Consul 节点出现故障挂掉了，那么 以该Consul注册服务的WebApi 在Consul 服务中看不到。**

示例：实战示例中，WebApi节点 **192.168.130.129:5726** 和 节点 **192.168.130.129:5727** 都是以 Consul节点 **192.168.130.129:11500** 进行注册的，如果该Consul挂掉了：

```shell
# 让consul-node4挂掉了
[root@centos-1 compose]# docker stop consul-node4
consul-node4
```

查看服务器状态：

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618682091543.png" alt="1618682091543" style="zoom:80%;" />

**WebApi节点 192.168.130.129:5726 和 节点 192.168.130.129:5727 的服务列表中被移除了**，

Consul节点 **192.168.130.129:11500** 恢复后，这两个节点又被加入会服务列表中

```shell
# 让consul-node4 恢复
[root@centos-1 compose]# docker start consul-node4
consul-node4
```

<img src="images/.Net%E6%9E%B6%E6%9E%84%E5%B8%88%E4%B9%8B%E8%B7%AF(%E5%9B%9B)/1618682633566.png" alt="1618682633566" style="zoom:80%;" />



产生这个问题的原因是：

​       **WebApi 向哪个 Consul 节点注册的服务，哪个 Consul 节点 才负责 检查该WebApi的心跳，如果该 Consul 节点挂掉了，其它Consul 节点不会帮其检查心跳。**



**这个问题该怎么办？** 
1 多客户端注册:

   类似服务网格Servermesh



2 或者就不健康检查

使用Registrator

```shell
Registrator—可以发现全部服务并注册

1拉取Registrator的镜像*

docker pull gliderlabs/registrator:latest 

2启动Registrator节点

docker run -d --name=registrator \ 

 -v /var/run/docker.sock:/tmp/docker.sock \ 

 --net=host \ 

 gliderlabs/registrator -ip="192.168.130.129" consul://:8500 

--net指定为host表明使用主机模式。 -ip用于指定宿主机的IP地址，用于健康检查的通信地址。 

consul://92.168.130.129:8500: 使用Consul作为服务注册表，指定具体的Consul通信地址进行服务注册和 

注销（注意：8500是Consul对外暴露的HTTP通信端口）。 

3.查看 Registrator 的容器进程启动日志：
docker logs -f registrator'

Registrator 在启动过程完成了以下几步操作：
1. 查看Consul数据中心的leader节点，作为服务注册表；
2. 同步当前宿主机的启用容器，以及所有的服务端口；
3. 分别将各个容器发布的服务地址/端口注册到Consul的服务注册列表。

这样 Consul 会看到好多根本原本不想看到的 监听端口，好无语，不想用
```



###  Raft 一致性协议简介 

比如ETCD、TiDB还有各种Docker容器的编排系统 Consul用的也是 

为了保证一致性（Consensus)，是构建具有容错性（fault-tolerant）的分布式系统的基础。 在一个具 

有一致性的性质的集群里面，同一时刻所有的结点对存储在其中的某个值都有相同的结果，即对其共享 

的存储保持一致。 

集群具有自动恢复的性质，当少数结点失效的时候不影响集群的正常工作，当大多数集群中的结点失效 

的时候，集群则会停止服务（不会返回一个错误的结果）。 

在一个典型的一致性架构中，整个集群系统是由多个副本状态机（replicated state mathines)组成，对 

外部客户端的访问，整个系统就想一台非常可靠的状态机。

系统中每个结点，有三个组件日志（*Log*）、一致性模块（*Concensus Module*） 、状态机（*State* 

*Machine*） 三个部分组成。 

状态机：当我们说一致性的时候，实际就是在说要保证这个状态机的一致性。状态机会从log里面取出 

所有的命令，然后执行一遍，得到的结果就是我们对外提供的保证了一致性的数据。Log：Log中保存了所有的修改记录，比如如果是个hash表的话，就会依次记录各种set、delete信息。 

一致性模块： 一致性模块算法就是用来保证写入的log的命令的一致性，这里可以是paxos算法也可以 

是raft算法



### Gossip 协议 

#### Gossip是什么

Gossip协议是一个通信协议，一种传播消息的方式，灵感来自于：瘟疫、社交网络等。使用Gossip协议 

的有：Redis Cluster、Consul、Apache Cassandra等。 



#### 六度分隔理论

说到社交网络，就不得不提著名的**六度分隔理论**。1967年，哈佛大学的心理学教授Stanley Milgram想 

要描绘一个连结人与社区的人际连系网。做过一次连锁信实验，结果发现了“六度分隔”现象。简单地 

说：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过六个人你就能够认识任 

何一个陌生人。 

数学解释该理论：若每个人平均认识260人，其六度就是260↑6 =1,188,137,600,000。消除一些节点重 

复，那也几乎**覆盖**了整个地球人口若干多多倍，这也是Gossip协议的雏形。 



#### **原理** 

Gossip协议基本思想就是：一个节点想要分享一些信息给网络中的其他的一些节点。于是，它**周期性**的 

**随机**选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些 

信息传递给其他一些随机选择的节点。一般而言，信息会周期性的传递给N个目标节点，而不只是一 

个。这个N被称为**fanout**（这个单词的本意是扇出）



#### **用途** 

Gossip协议的主要用途就是**信息传播和扩散**：即把一些发生的事件传播到全世界。它们也被用于数据库 

复制，信息扩散，集群成员身份确认，故障探测等。 

基于Gossip协议的一些有名的系统：Apache Cassandra，Redis（Cluster模式），Consul等。